name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.21'
  ANTLR_VERSION: '4.13.1'

jobs:
  # Single change detection job for all workflows
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      go-files: ${{ steps.final-decision.outputs.go-files }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Detect file changes
      uses: dorny/paths-filter@v3
      id: changes
      with:
        filters: |
          go-files:
            - '**/*.go'
            - 'go.mod'
            - 'go.sum'
            - 'tools/grammar/**'
          makefile-changes:
            - 'Makefile'
          has-changes:
            - '**'
            
    - name: Set up Go (for change detection)
      if: ${{ steps.changes.outputs.makefile-changes == 'true' }}
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'

    - name: Analyze Makefile changes for Go relevance
      id: makefile-analysis
      if: ${{ steps.changes.outputs.makefile-changes == 'true' }}
      run: |
        cd tools/change-detector
        go build -o change-detector .
        output=$(./change-detector makefile-analysis)
        echo "$output"
        GO_RELATED=$(echo "$output" | grep "go-related=" | cut -d'=' -f2)
        echo "go-related=$GO_RELATED" >> $GITHUB_OUTPUT
        
    - name: Final Go files decision
      id: final-decision  
      run: |
        cd tools/change-detector
        if [ ! -f change-detector ]; then
          go build -o change-detector .
        fi
        
        BASIC_GO="${{ steps.changes.outputs.go-files }}"
        MAKEFILE_GO="${{ steps.makefile-analysis.outputs.go-related || 'false' }}"
        
        output=$(./change-detector final-decision "$BASIC_GO" "$MAKEFILE_GO")
        echo "$output"
        GO_FILES=$(echo "$output" | grep "go-files=" | cut -d'=' -f2)
        echo "go-files=$GO_FILES" >> $GITHUB_OUTPUT

  # Fast skip job for non-Go changes  
  skip-build:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.go-files == 'false' }}
    steps:
    - name: Skip Go workflows
      run: |
        echo "✅ Skipping Go builds and tests - no Go-related files changed"
        echo "Changed files are only: documentation, VSCode extension, examples, etc."

  # Parallel job: Build & Basic Tests
  build-and-test:
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: ${{ needs.detect-changes.outputs.go-files == 'true' }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        
    # Cache Go modules
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum', '**/go.mod') }}
        restore-keys: |
          ${{ runner.os }}-go-${{ env.GO_VERSION }}-
          
    # Cache ANTLR installation
    - name: Cache ANTLR
      id: antlr-cache
      uses: actions/cache@v4
      with:
        path: /usr/local/lib/antlr.jar
        key: ${{ runner.os }}-antlr-${{ env.ANTLR_VERSION }}
        
    - name: Install ANTLR
      if: steps.antlr-cache.outputs.cache-hit != 'true'
      run: |
        wget https://www.antlr.org/download/antlr-${{ env.ANTLR_VERSION }}-complete.jar -O /tmp/antlr.jar
        sudo mv /tmp/antlr.jar /usr/local/lib/
        
    - name: Setup ANTLR binary
      run: |
        echo '#!/bin/bash' | sudo tee /usr/local/bin/antlr4
        echo 'java -jar /usr/local/lib/antlr.jar "$@"' | sudo tee -a /usr/local/bin/antlr4
        sudo chmod +x /usr/local/bin/antlr4
        
    - name: Install Go dependencies
      run: |
        go mod download || echo "No modules to download"
        go mod tidy || echo "No go.mod yet"
        
    # Cache parser generation
    - name: Cache generated parsers
      id: parser-cache
      uses: actions/cache@v4
      with:
        path: tools/gen/
        key: ${{ runner.os }}-parser-${{ hashFiles('tools/grammar/**') }}
        
    - name: Generate parsers
      if: steps.parser-cache.outputs.cache-hit != 'true'
      run: |
        if [ -f "tools/grammar/Vex.g4" ]; then
          make go || echo "Parser generation failed, continuing..."
        fi
        
    - name: Run Go tests
      run: |
        if find . -name "*_test.go" | grep -q .; then
          echo "🧪 Running Go tests..."
          go test -v ./... || {
            echo "❌ Tests failed, but checking if this should block..."
            # In early development, test failures are warnings only
            if [ $(find . -name "*.go" -not -name "*_test.go" | wc -l) -lt 5 ]; then
              echo "⚠️ Early development detected - treating test failures as warnings"
              exit 0
            else
              echo "💥 Sufficient codebase exists - test failures are blocking"
              exit 1
            fi
          }
        else
          echo "✅ No tests found yet - this is expected for early development"
        fi
        
    - name: Build Go project
      run: |
        if find . -name "main.go" | grep -q .; then
          echo "🔨 Building Go packages..."
          go build ./... || {
            echo "❌ Build failed"
            exit 1
          }
        else
          echo "✅ No main packages to build yet - this is expected"
        fi

  # Parallel job: Coverage Analysis
  test-coverage:
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: ${{ needs.detect-changes.outputs.go-files == 'true' }}
    steps:
    - name: Checkout code with history
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        
    # Cache Go modules
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum', '**/go.mod') }}
        restore-keys: |
          ${{ runner.os }}-go-${{ env.GO_VERSION }}-
          
    - name: Install Go dependencies
      run: |
        go mod download || echo "No modules to download"
        go mod tidy || echo "No go.mod yet"
        
    - name: Install coverage tools
      run: |
        go install github.com/axw/gocov/gocov@latest
        go install github.com/AlekSi/gocov-xml@latest
        
    - name: Run Go tests with coverage
      run: |
        mkdir -p coverage
        echo "🧪 Running tests with coverage analysis..."
        
        if find . -name "*_test.go" | grep -q .; then
          # Tests exist, run with coverage
          go test -v -coverprofile=coverage/total.out -coverpkg=./... ./... || {
            echo "❌ Tests failed during coverage analysis"
            # In early development, still generate coverage even if tests fail
            if [ $(find . -name "*.go" -not -name "*_test.go" | wc -l) -lt 5 ]; then
              echo "⚠️ Early development - generating coverage despite test failures"
              go test -coverprofile=coverage/total.out -coverpkg=./... ./... || true
            else
              exit 1
            fi
          }
        else
          echo "✅ No tests found - skipping coverage analysis"
          echo "0" > coverage/total.out
        fi
        
    - name: Calculate coverage
      id: coverage
      run: |
        if [ -f "coverage/total.out" ] && [ -s "coverage/total.out" ]; then
          TOTAL_COV=$(go tool cover -func=coverage/total.out | grep "total:" | awk '{print $3}' | sed 's/%//' || echo "0")
          echo "total-coverage=$TOTAL_COV" >> $GITHUB_OUTPUT
          echo "📊 Coverage: $TOTAL_COV%"
          
          # Coverage requirements based on project maturity
          GO_FILE_COUNT=$(find . -name "*.go" -not -name "*_test.go" | wc -l)
          if [ $GO_FILE_COUNT -lt 5 ]; then
            echo "⚠️ Early development - no coverage requirements yet"
          elif [ $GO_FILE_COUNT -lt 20 ]; then
            echo "📈 Growing project - aim for 40%+ coverage"
          else
            echo "🎯 Mature project - aim for 70%+ coverage"
          fi
        else
          echo "total-coverage=0" >> $GITHUB_OUTPUT
          echo "📊 No coverage data available"
        fi
        
    - name: Upload coverage artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-report
        path: coverage/
        retention-days: 30

  # Parallel job: Linting & Quality
  lint-and-quality:
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: ${{ needs.detect-changes.outputs.go-files == 'true' }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        
    # Cache Go modules
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum', '**/go.mod') }}
        restore-keys: |
          ${{ runner.os }}-go-${{ env.GO_VERSION }}-
          
    - name: Install Go dependencies
      run: |
        go mod download || echo "No modules to download"
        go mod tidy || echo "No go.mod yet"
        
    # Cache linting tools
    - name: Cache linting tools
      uses: actions/cache@v4
      with:
        path: ~/go/bin
        key: ${{ runner.os }}-go-tools-${{ env.GO_VERSION }}-lint
        
    - name: Install Go linting tools
      run: |
        go install golang.org/x/tools/cmd/goimports@latest
        go install golang.org/x/lint/golint@latest
        
    - name: Check formatting (changed files only)
      run: |
        if find . -name "*.go" | grep -q .; then
          echo "🔍 Checking Go code formatting..."
          
          # Get list of changed Go files in this PR
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_GO_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..HEAD | grep '\.go$' || true)
          else
            CHANGED_GO_FILES=$(find . -name "*.go")
          fi
          
          if [ -n "$CHANGED_GO_FILES" ]; then
            echo "Changed Go files: $CHANGED_GO_FILES"
            echo "$CHANGED_GO_FILES" | xargs goimports -l > /tmp/goimports.out || true
            
            if [ -s /tmp/goimports.out ]; then
              echo "❌ Formatting issues found in changed files:"
              cat /tmp/goimports.out
              echo ""
              echo "🔧 Run: goimports -w $(echo $CHANGED_GO_FILES | tr '\n' ' ')"
              exit 1
            else
              echo "✅ All changed Go files are properly formatted"
            fi
            
            # Check all files but only warn for unchanged ones
            goimports -l . > /tmp/all_goimports.out || true
            if [ -s /tmp/all_goimports.out ]; then
              echo ""
              echo "⚠️ Additional formatting issues found in unchanged files (not blocking):"
              cat /tmp/all_goimports.out
            fi
          else
            echo "✅ No Go files changed in this PR"
          fi
        else
          echo "✅ No Go files found - skipping formatting check"
        fi
        
    - name: Run Go linting (smart failure handling)
      run: |
        if find . -name "*.go" | grep -q .; then
          echo "🔍 Running Go linting..."
          
          # Get changed files for strict checking
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_GO_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..HEAD | grep '\.go$' || true)
          else
            CHANGED_GO_FILES=$(find . -name "*.go")
          fi
          
          LINT_FAILED=false
          
          if [ -n "$CHANGED_GO_FILES" ]; then
            echo "Linting changed files strictly..."
            for file in $CHANGED_GO_FILES; do
              if [ -f "$file" ]; then
                echo "Checking: $file"
                if ! golint "$file"; then
                  echo "❌ Linting issues in changed file: $file"
                  LINT_FAILED=true
                fi
              fi
            done
          fi
          
          # Check all files but only warn for issues in unchanged files
          echo ""
          echo "🔍 Checking all files (warnings for unchanged files)..."
          golint ./... > /tmp/all_lint.out 2>&1 || true
          
          if [ -s /tmp/all_lint.out ]; then
            echo "⚠️ All linting issues found:"
            cat /tmp/all_lint.out
          fi
          
          if [ "$LINT_FAILED" = "true" ]; then
            echo ""
            echo "💥 Linting failed for changed files - this blocks merging"
            exit 1
          else
            echo "✅ No blocking linting issues in changed files"
          fi
        else
          echo "✅ No Go files found - skipping linting"
        fi

  # Summary job that depends on all parallel jobs
  ci-summary:
    runs-on: ubuntu-latest
    needs: [detect-changes, skip-build, build-and-test, test-coverage, lint-and-quality]
    if: always()
    steps:
    - name: Report CI Results
      run: |
        echo "## 📊 CI Summary" >> $GITHUB_STEP_SUMMARY
        
        if [[ "${{ needs.detect-changes.outputs.go-files }}" == "false" ]]; then
          echo "✅ **Fast skip**: No Go-related files changed" >> $GITHUB_STEP_SUMMARY
          echo "⚡ **Time saved**: ~5-8 minutes" >> $GITHUB_STEP_SUMMARY
          echo "- Skip Build: ${{ needs.skip-build.result }}" >> $GITHUB_STEP_SUMMARY
        else
          echo "🔄 **Full CI**: Go-related files changed" >> $GITHUB_STEP_SUMMARY
          echo "- Build & Test: ${{ needs.build-and-test.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Coverage: ${{ needs.test-coverage.result }}" >> $GITHUB_STEP_SUMMARY  
          echo "- Linting: ${{ needs.lint-and-quality.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 🧠 Smart Failure Handling" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **Changed files**: Strict error checking" >> $GITHUB_STEP_SUMMARY
          echo "- ⚠️  **Unchanged files**: Warning-only for legacy issues" >> $GITHUB_STEP_SUMMARY
          echo "- 🚀 **Early development**: Graceful failure handling" >> $GITHUB_STEP_SUMMARY
          echo "- 📊 **Coverage**: Adaptive requirements based on project size" >> $GITHUB_STEP_SUMMARY
          
          # Intelligent failure handling - only fail if jobs actually failed
          # (not if they succeeded with warnings)
          if [[ "${{ needs.build-and-test.result }}" == "failure" || 
                "${{ needs.test-coverage.result }}" == "failure" || 
                "${{ needs.lint-and-quality.result }}" == "failure" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "❌ **CI blocked** - Issues found in changed files" >> $GITHUB_STEP_SUMMARY
            echo "Check individual jobs for specific issues that need fixing." >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "✅ **All checks passed** - Ready to merge!" >> $GITHUB_STEP_SUMMARY
          fi
        fi
