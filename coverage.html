
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
                <title>vex-transpiler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
                                <option value="file0">github.com/thsfranca/vex/cmd/vex-transpiler/main.go (0.0%)</option>
				
				<option value="file1">github.com/thsfranca/vex/internal/transpiler/ast_visitor.go (0.0%)</option>
				
				<option value="file2">github.com/thsfranca/vex/internal/transpiler/codegen.go (0.0%)</option>
				
				<option value="file3">github.com/thsfranca/vex/internal/transpiler/macro_collector.go (0.0%)</option>
				
				<option value="file4">github.com/thsfranca/vex/internal/transpiler/macro_expander.go (0.0%)</option>
				
				<option value="file5">github.com/thsfranca/vex/internal/transpiler/macro_registry.go (0.0%)</option>
				
				<option value="file6">github.com/thsfranca/vex/internal/transpiler/parser/vex_base_listener.go (0.0%)</option>
				
				<option value="file7">github.com/thsfranca/vex/internal/transpiler/parser/vex_base_visitor.go (0.0%)</option>
				
				<option value="file8">github.com/thsfranca/vex/internal/transpiler/parser/vex_lexer.go (0.0%)</option>
				
				<option value="file9">github.com/thsfranca/vex/internal/transpiler/parser/vex_parser.go (0.0%)</option>
				
				<option value="file10">github.com/thsfranca/vex/internal/transpiler/semantic_visitor.go (0.0%)</option>
				
				<option value="file11">github.com/thsfranca/vex/internal/transpiler/symbols.go (0.0%)</option>
				
				<option value="file12">github.com/thsfranca/vex/internal/transpiler/tests/test_helpers.go (32.5%)</option>
				
				<option value="file13">github.com/thsfranca/vex/internal/transpiler/transpiler.go (0.0%)</option>
				
				<option value="file14">github.com/thsfranca/vex/internal/transpiler/type_checker.go (0.0%)</option>
				
				<option value="file15">github.com/thsfranca/vex/internal/transpiler/type_inference.go (0.0%)</option>
				
				<option value="file16">github.com/thsfranca/vex/internal/transpiler/types.go (0.0%)</option>
				
				<option value="file17">github.com/thsfranca/vex/tools/gen/go/vex_base_listener.go (0.0%)</option>
				
				<option value="file18">github.com/thsfranca/vex/tools/gen/go/vex_base_visitor.go (0.0%)</option>
				
				<option value="file19">github.com/thsfranca/vex/tools/gen/go/vex_lexer.go (0.0%)</option>
				
				<option value="file20">github.com/thsfranca/vex/tools/gen/go/vex_parser.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "io/ioutil"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/thsfranca/vex/internal/transpiler"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">command := os.Args[1]
        switch command </span>{
        case "transpile":<span class="cov0" title="0">
                transpileCommand(os.Args[2:])</span>
        case "run":<span class="cov0" title="0">
                runCommand(os.Args[2:])</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown command: %s\n\n", command)
                printUsage()
                os.Exit(1)</span>
        }
}

func printUsage() <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, "Vex - A statically-typed functional programming language\n\n")
        fmt.Fprintf(os.Stderr, "Usage:\n")
        fmt.Fprintf(os.Stderr, "  vex transpile -input &lt;file.vex&gt; [-output &lt;file.go&gt;] [-verbose]\n")
        fmt.Fprintf(os.Stderr, "  vex run -input &lt;file.vex&gt; [-verbose]\n\n")
        fmt.Fprintf(os.Stderr, "Commands:\n")
        fmt.Fprintf(os.Stderr, "  transpile  Transpile Vex source code to Go\n")
        fmt.Fprintf(os.Stderr, "  run        Transpile and run Vex source code\n\n")
        fmt.Fprintf(os.Stderr, "Examples:\n")
        fmt.Fprintf(os.Stderr, "  vex transpile -input example.vex -output example.go\n")
        fmt.Fprintf(os.Stderr, "  vex run -input example.vex\n")
}</span>

func transpileCommand(args []string) <span class="cov0" title="0">{
        transpileFlags := flag.NewFlagSet("transpile", flag.ExitOnError)
        var (
                inputFile  = transpileFlags.String("input", "", "Input .vex file to transpile")
                outputFile = transpileFlags.String("output", "", "Output .go file (optional, defaults to stdout)")
                verbose    = transpileFlags.Bool("verbose", false, "Enable verbose output")
        )
        transpileFlags.Parse(args)

        if *inputFile == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: -input flag is required\n\n")
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "üîÑ Transpiling: %s\n", *inputFile)
        }</span>

        // Read input file
        <span class="cov0" title="0">content, err := ioutil.ReadFile(*inputFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error reading file %s: %v\n", *inputFile, err)
                os.Exit(1)
        }</span>

        // Create transpiler
        <span class="cov0" title="0">t := transpiler.New()

        // Transpile
        goCode, err := t.TranspileFromInput(string(content))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Transpilation error: %v\n", err)
                os.Exit(1)
        }</span>

        // Output result
        <span class="cov0" title="0">if *outputFile != "" </span><span class="cov0" title="0">{
                err = ioutil.WriteFile(*outputFile, []byte(goCode), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Error writing output file %s: %v\n", *outputFile, err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚úÖ Transpilation complete: %s\n", *outputFile)
                }</span>
        } else<span class="cov0" title="0"> {
                // Output to stdout
                fmt.Print(goCode)
        }</span>
}

func runCommand(args []string) <span class="cov0" title="0">{
        runFlags := flag.NewFlagSet("run", flag.ExitOnError)
        var (
                inputFile = runFlags.String("input", "", "Input .vex file to run")
                verbose   = runFlags.Bool("verbose", false, "Enable verbose output")
        )
        runFlags.Parse(args)

        if *inputFile == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: -input flag is required\n\n")
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "üöÄ Running Vex file: %s\n", *inputFile)
        }</span>

        // Read input file
        <span class="cov0" title="0">content, err := ioutil.ReadFile(*inputFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error reading file %s: %v\n", *inputFile, err)
                os.Exit(1)
        }</span>

        // Create transpiler
        <span class="cov0" title="0">t := transpiler.New()

        // Transpile
        goCode, err := t.TranspileFromInput(string(content))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Transpilation error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "üîÑ Transpilation complete, executing...\n")
        }</span>

        // Create temporary file for Go code
        <span class="cov0" title="0">tmpDir := os.TempDir()
        baseName := strings.TrimSuffix(filepath.Base(*inputFile), filepath.Ext(*inputFile))
        tmpGoFile := filepath.Join(tmpDir, baseName+"_temp.go")

        // Write Go code to temporary file
        err = ioutil.WriteFile(tmpGoFile, []byte(goCode), 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error writing temporary Go file: %v\n", err)
                os.Exit(1)
        }</span>

        // Clean up temporary file when done
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := os.Remove(tmpGoFile); err != nil &amp;&amp; *verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ö†Ô∏è  Warning: could not remove temporary file %s: %v\n", tmpGoFile, err)
                }</span>
        }()

        // Run the Go code
        // Note: Go will complain about unused variables, but the code will compile if syntax is correct
        <span class="cov0" title="0">cmd := exec.Command("go", "build", "-o", strings.TrimSuffix(tmpGoFile, ".go"), tmpGoFile)
        var buildErr error
        buildOutput, buildErr := cmd.CombinedOutput()

        if buildErr != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Build error: %v\n%s", buildErr, string(buildOutput))
                os.Exit(1)
        }</span>

        // If build succeeded, run the executable
        <span class="cov0" title="0">executable := strings.TrimSuffix(tmpGoFile, ".go")
        defer os.Remove(executable) // Clean up executable

        runCmd := exec.Command(executable)
        runCmd.Stdout = os.Stdout
        runCmd.Stderr = os.Stderr

        err = runCmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Execution error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚úÖ Execution complete\n")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package transpiler

import (
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// ASTVisitor implements the visitor pattern for Vex AST nodes
type ASTVisitor struct {
        parser.BaseVexVisitor
        codeGen       *CodeGenerator
        macroRegistry *MacroRegistry
}

// NewASTVisitor creates a new AST visitor with a code generator
func NewASTVisitor() *ASTVisitor <span class="cov0" title="0">{
        return &amp;ASTVisitor{
                codeGen:       NewCodeGenerator(),
                macroRegistry: NewMacroRegistry(),
        }
}</span>

// GetGeneratedCode returns the generated Go code
func (v *ASTVisitor) GetGeneratedCode() string <span class="cov0" title="0">{
        return v.codeGen.GetCode()
}</span>

// GetCodeGenerator returns the code generator for accessing imports
func (v *ASTVisitor) GetCodeGenerator() *CodeGenerator <span class="cov0" title="0">{
        return v.codeGen
}</span>

// VisitProgram visits the root node of the parse tree
func (v *ASTVisitor) VisitProgram(ctx *parser.ProgramContext) interface{} <span class="cov0" title="0">{
        // Visit all child lists
        for _, listCtx := range ctx.AllList() </span><span class="cov0" title="0">{
                listCtx.Accept(v)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// VisitList visits a list expression (s-expression)
func (v *ASTVisitor) VisitList(ctx *parser.ListContext) interface{} <span class="cov0" title="0">{
        children := ctx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{ // '(' ... ')'
                return nil
        }</span>

        // Skip opening parenthesis, process content, skip closing parenthesis
        <span class="cov0" title="0">content := children[1 : len(children)-1]

        if len(content) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check if this is a special form (function call, def, etc.)
        <span class="cov0" title="0">firstChild := content[0]

        // Get the text of the first element
        var firstElement string
        if symbolCtx, ok := firstChild.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                firstElement = symbolCtx.GetText()
        }</span>

        <span class="cov0" title="0">switch firstElement </span>{
        case "def":<span class="cov0" title="0">
                v.handleDefinition(content)</span>
        case "import":<span class="cov0" title="0">
                v.handleImport(content[1:])</span> // Skip the "import" symbol
        case "macro":<span class="cov0" title="0">
                v.handleMacroDefinition(content[1:])</span> // Skip the "macro" symbol
        case "fn":<span class="cov0" title="0">
                v.handleFunctionLiteral(content[1:])</span> // Skip the "fn" symbol
        case "+", "-", "*", "/":<span class="cov0" title="0">
                v.handleArithmetic(firstElement, content[1:])</span>
        default:<span class="cov0" title="0">
                // Check if it's a registered macro
                if v.macroRegistry.IsMacro(firstElement) </span><span class="cov0" title="0">{
                        v.handleMacroCall(firstElement, content[1:])
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(firstElement, ".") </span><span class="cov0" title="0">{
                        // Check if it's a method call (starts with .)
                        v.handleMethodCall(firstElement, content[1:])
                }</span> else<span class="cov0" title="0"> if strings.Contains(firstElement, "/") </span><span class="cov0" title="0">{
                        // Check if it's a package function call with slash notation (contains /)
                        v.handleSlashNotationCall(firstElement, content[1:])
                }</span> else<span class="cov0" title="0"> {
                        // Handle other expressions or function calls
                        v.handleExpression(content)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// VisitArray visits an array literal
func (v *ASTVisitor) VisitArray(ctx *parser.ArrayContext) interface{} <span class="cov0" title="0">{
        // For now, just visit children
        // Arrays will be implemented in a later phase
        return v.VisitChildren(ctx)
}</span>

// handleDefinition handles variable definitions like (def x 10)
func (v *ASTVisitor) handleDefinition(content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                v.codeGen.writeIndented("// Invalid definition\n")
                return
        }</span>

        // Get variable name
        <span class="cov0" title="0">var varName string
        if symbolCtx, ok := content[1].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                varName = symbolCtx.GetText()
        }</span>

        // Get value
        <span class="cov0" title="0">value := v.evaluateExpression(content[2])
        v.codeGen.EmitVariableDefinition(varName, value)</span>
}

// handleArithmetic handles arithmetic expressions like (+ 1 2)
func (v *ASTVisitor) handleArithmetic(operator string, operands []antlr.Tree) <span class="cov0" title="0">{
        var operandValues []string
        for _, operand := range operands </span><span class="cov0" title="0">{
                operandValues = append(operandValues, v.evaluateExpression(operand))
        }</span>
        <span class="cov0" title="0">v.codeGen.EmitArithmeticExpression(operator, operandValues)</span>
}

// handleImport handles import statements like (import "net/http")
func (v *ASTVisitor) handleImport(content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 1 </span><span class="cov0" title="0">{
                v.codeGen.writeIndented("// Invalid import\n")
                return
        }</span>

        // Get the import path
        <span class="cov0" title="0">importPath := v.evaluateExpression(content[0])
        v.codeGen.EmitImport(importPath)</span>
}

// handleMethodCall handles method calls like (.HandleFunc router "/path" handler)
func (v *ASTVisitor) handleMethodCall(methodName string, content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 1 </span><span class="cov0" title="0">{
                v.codeGen.writeIndented("// Invalid method call\n")
                return
        }</span>

        // Get the receiver (first argument)
        <span class="cov0" title="0">receiver := v.evaluateExpression(content[0])

        // Get the method arguments
        var args []string
        for _, arg := range content[1:] </span><span class="cov0" title="0">{
                args = append(args, v.evaluateExpression(arg))
        }</span>

        <span class="cov0" title="0">v.codeGen.EmitMethodCall(receiver, methodName[1:], args)</span> // Remove the dot from method name
}

// handleSlashNotationCall handles package function calls like (fmt/Println "message")
func (v *ASTVisitor) handleSlashNotationCall(packageFunction string, content []antlr.Tree) <span class="cov0" title="0">{
        // Split package/function on the slash
        parts := strings.Split(packageFunction, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                v.codeGen.writeIndented("// Invalid slash notation: " + packageFunction + "\n")
                return
        }</span>

        <span class="cov0" title="0">packageName := parts[0]
        functionName := parts[1]

        // Get the function arguments
        var args []string
        for _, arg := range content </span><span class="cov0" title="0">{
                args = append(args, v.evaluateExpression(arg))
        }</span>

        <span class="cov0" title="0">v.codeGen.EmitSlashNotationCall(packageName, functionName, args)</span>
}

// handleMacroDefinition handles macro definitions like (macro name [params] body)
func (v *ASTVisitor) handleMacroDefinition(content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                v.codeGen.writeIndented("// Invalid macro definition\n")
                return
        }</span>

        // Get macro name
        <span class="cov0" title="0">var macroName string
        if symbolCtx, ok := content[0].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                macroName = symbolCtx.GetText()
        }</span>

        // Get parameters from array
        <span class="cov0" title="0">paramList := content[1]
        var params []string
        if arrayCtx, ok := paramList.(*parser.ArrayContext); ok </span><span class="cov0" title="0">{
                children := arrayCtx.GetChildren()
                // Skip [ and ] brackets
                for i := 1; i &lt; len(children)-1; i++ </span><span class="cov0" title="0">{
                        if terminalNode, ok := children[i].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                                params = append(params, terminalNode.GetText())
                        }</span>
                }
        }

        // Macro body template (remaining content)
        <span class="cov0" title="0">if len(content) &gt; 2 </span><span class="cov0" title="0">{
                template := content[2] // For now, just take the first body element
                v.macroRegistry.RegisterMacro(macroName, params, template)

                // Don't generate any Go code for macro definitions
                v.codeGen.writeIndented("// Registered macro: " + macroName + "\n")
        }</span>
}

// handleMacroCall handles calls to user-defined macros
func (v *ASTVisitor) handleMacroCall(macroName string, args []antlr.Tree) <span class="cov0" title="0">{
        expanded, err := v.macroRegistry.ExpandMacro(macroName, args)
        if err != nil </span><span class="cov0" title="0">{
                v.codeGen.writeIndented("// Error expanding macro " + macroName + ": " + err.Error() + "\n")
                return
        }</span>

        // Re-parse and process the expanded code
        <span class="cov0" title="0">err = v.processExpandedCode(expanded)
        if err != nil </span><span class="cov0" title="0">{
                v.codeGen.writeIndented("// Error processing expanded macro " + macroName + ": " + err.Error() + "\n")
                v.codeGen.writeIndented("// Expanded code was: " + expanded + "\n")
        }</span>
}

// handleFunctionLiteral handles function literals like (fn [w r] body)
func (v *ASTVisitor) handleFunctionLiteral(content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 2 </span><span class="cov0" title="0">{
                v.codeGen.writeIndented("// Invalid function literal\n")
                return
        }</span>

        // First element should be parameter list (array)
        <span class="cov0" title="0">paramList := content[0]

        // Extract parameter names
        var params []string
        if arrayCtx, ok := paramList.(*parser.ArrayContext); ok </span><span class="cov0" title="0">{
                children := arrayCtx.GetChildren()
                // Skip [ and ] brackets
                for i := 1; i &lt; len(children)-1; i++ </span><span class="cov0" title="0">{
                        if terminalNode, ok := children[i].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                                params = append(params, terminalNode.GetText())
                        }</span>
                }
        }

        // Function body (rest of the arguments)
        <span class="cov0" title="0">bodyElements := content[1:]

        functionLiteral := v.codeGen.EmitFunctionLiteral(params, bodyElements, v)
        // This returns a function literal expression, but we need to handle it as a value
        v.codeGen.EmitExpressionStatement(functionLiteral)</span>
}

// handleExpression handles general expressions
func (v *ASTVisitor) handleExpression(content []antlr.Tree) <span class="cov0" title="0">{
        // For now, just evaluate each element as a standalone expression
        for _, element := range content </span><span class="cov0" title="0">{
                value := v.evaluateExpression(element)
                v.codeGen.EmitExpressionStatement(value)
        }</span>
}

// evaluateExpression evaluates a single expression and returns its Go representation
func (v *ASTVisitor) evaluateExpression(node antlr.Tree) string <span class="cov0" title="0">{
        switch ctx := node.(type) </span>{
        case *antlr.TerminalNodeImpl:<span class="cov0" title="0">
                text := ctx.GetText()

                // Check if it's a string literal
                if strings.HasPrefix(text, "\"") &amp;&amp; strings.HasSuffix(text, "\"") </span><span class="cov0" title="0">{
                        return text // Already properly quoted
                }</span>

                // Check if it's a number
                <span class="cov0" title="0">if isNumber(text) </span><span class="cov0" title="0">{
                        return text
                }</span>

                // Otherwise, it's a symbol/identifier
                <span class="cov0" title="0">return text</span>

        case *parser.ListContext:<span class="cov0" title="0">
                return v.evaluateListExpression(ctx)</span>

        default:<span class="cov0" title="0">
                return "/* unknown */"</span>
        }
}

// evaluateListExpression evaluates a list expression and returns its Go representation
// This method handles the same logic as VisitList but returns values instead of emitting code
func (v *ASTVisitor) evaluateListExpression(ctx *parser.ListContext) string <span class="cov0" title="0">{
        children := ctx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{ // '(' ... ')'
                return "/* empty list */"
        }</span>

        // Skip opening parenthesis, process content, skip closing parenthesis
        <span class="cov0" title="0">content := children[1 : len(children)-1]

        if len(content) == 0 </span><span class="cov0" title="0">{
                return "/* empty list */"
        }</span>

        // Get the first element
        <span class="cov0" title="0">firstChild := content[0]
        var firstElement string
        if symbolCtx, ok := firstChild.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                firstElement = symbolCtx.GetText()
        }</span>

        <span class="cov0" title="0">switch firstElement </span>{
        case "+", "-", "*", "/":<span class="cov0" title="0">
                // Handle arithmetic expressions - return the result directly
                return v.evaluateArithmeticExpression(firstElement, content[1:])</span>
        case "fn":<span class="cov0" title="0">
                // Handle function literals - return the function literal expression
                return v.evaluateFunctionLiteral(content[1:])</span>
        default:<span class="cov0" title="0">
                // Check if it's a method call (starts with .)
                if strings.HasPrefix(firstElement, ".") </span><span class="cov0" title="0">{
                        return v.evaluateMethodCall(firstElement, content[1:])
                }</span> else<span class="cov0" title="0"> if strings.Contains(firstElement, "/") </span><span class="cov0" title="0">{
                        // Handle slash notation
                        return v.evaluateSlashNotationCall(firstElement, content[1:])
                }</span> else<span class="cov0" title="0"> {
                        // Handle regular function calls
                        return v.evaluateFunctionCall(firstElement, content[1:])
                }</span>
        }
}

// evaluateArithmeticExpression evaluates arithmetic expressions and returns the result
func (v *ASTVisitor) evaluateArithmeticExpression(operator string, operands []antlr.Tree) string <span class="cov0" title="0">{
        goOperands := getStringSlice()
        defer putStringSlice(goOperands)
        for _, operand := range operands </span><span class="cov0" title="0">{
                value := v.evaluateExpression(operand)
                goOperands = append(goOperands, value)
        }</span>

        <span class="cov0" title="0">if len(goOperands) &lt; 2 </span><span class="cov0" title="0">{
                return "/* invalid arithmetic */"
        }</span>

        <span class="cov0" title="0">goOperator := v.codeGen.convertOperator(operator)
        return strings.Join(goOperands, " "+goOperator+" ")</span>
}

// evaluateMethodCall evaluates method call expressions and returns the result
func (v *ASTVisitor) evaluateMethodCall(methodName string, args []antlr.Tree) string <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return "/* invalid method call */"
        }</span>

        // First argument is the receiver
        <span class="cov0" title="0">receiver := v.evaluateExpression(args[0])

        // Rest are method arguments
        methodArgs := getStringSlice()
        defer putStringSlice(methodArgs)
        for i := 1; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                argValue := v.evaluateExpression(args[i])
                methodArgs = append(methodArgs, argValue)
        }</span>

        <span class="cov0" title="0">argsStr := strings.Join(methodArgs, ", ")
        return receiver + "." + methodName[1:] + "(" + argsStr + ")"</span>
}

// evaluateSlashNotationCall evaluates slash notation calls and returns the result
func (v *ASTVisitor) evaluateSlashNotationCall(packageFunction string, args []antlr.Tree) string <span class="cov0" title="0">{
        parts := strings.Split(packageFunction, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "/* invalid slash notation */"
        }</span>

        <span class="cov0" title="0">packageName := parts[0]
        functionName := parts[1]

        // Extract arguments
        var goArgs []string
        for _, arg := range args </span><span class="cov0" title="0">{
                argValue := v.evaluateExpression(arg)
                goArgs = append(goArgs, argValue)
        }</span>

        <span class="cov0" title="0">argsStr := strings.Join(goArgs, ", ")
        return packageName + "." + functionName + "(" + argsStr + ")"</span>
}

// evaluateFunctionCall evaluates regular function calls and returns the result
func (v *ASTVisitor) evaluateFunctionCall(functionName string, args []antlr.Tree) string <span class="cov0" title="0">{
        var goArgs []string
        for _, arg := range args </span><span class="cov0" title="0">{
                argValue := v.evaluateExpression(arg)
                goArgs = append(goArgs, argValue)
        }</span>

        <span class="cov0" title="0">argsStr := strings.Join(goArgs, ", ")
        return functionName + "(" + argsStr + ")"</span>
}

// evaluateFunctionLiteral evaluates function literals and returns the result
func (v *ASTVisitor) evaluateFunctionLiteral(content []antlr.Tree) string <span class="cov0" title="0">{
        if len(content) &lt; 2 </span><span class="cov0" title="0">{
                return "/* invalid function literal */"
        }</span>

        // First element should be parameter list (array)
        <span class="cov0" title="0">paramList := content[0]

        // Extract parameter names
        var params []string
        if arrayCtx, ok := paramList.(*parser.ArrayContext); ok </span><span class="cov0" title="0">{
                children := arrayCtx.GetChildren()
                // Skip [ and ] brackets
                for i := 1; i &lt; len(children)-1; i++ </span><span class="cov0" title="0">{
                        if terminalNode, ok := children[i].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                                params = append(params, terminalNode.GetText())
                        }</span>
                }
        }

        // Function body (rest of the arguments)
        <span class="cov0" title="0">bodyElements := content[1:]

        // Create a temporary code generator to generate the function literal
        tempCodeGen := NewCodeGenerator()
        return tempCodeGen.EmitFunctionLiteral(params, bodyElements, v)</span>
}

// processExpandedCode re-parses and processes expanded macro code
func (v *ASTVisitor) processExpandedCode(expandedCode string) error <span class="cov0" title="0">{
        // Create a new lexer and parser for the expanded code
        inputStream := antlr.NewInputStream(expandedCode)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)

        // Parse the expanded code
        tree := vexParser.List() // Parse as a single list expression

        // Visit the parsed tree with the current visitor
        tree.Accept(v)

        return nil
}</span>

// isNumber checks if a string represents a numeric value
func isNumber(s string) bool <span class="cov0" title="0">{
        for _, char := range s </span><span class="cov0" title="0">{
                if char &lt; '0' || char &gt; '9' </span><span class="cov0" title="0">{
                        if char != '.' &amp;&amp; char != '-' </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov0" title="0">return len(s) &gt; 0</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package transpiler

import (
        "strconv"
        "strings"
        "sync"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// stringSlicePool provides pooled string slices to reduce allocations
var stringSlicePool = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{
                return make([]string, 0, 8) // Pre-allocate capacity for common use cases
        }</span>,
}

// CodeGenerator handles the generation of Go code from AST nodes
type CodeGenerator struct {
        indentLevel   int
        buffer        strings.Builder
        imports       map[string]bool   // Track unique imports
        indentCache   []string          // Cache for indent strings
        operatorCache map[string]string // Cache for operator conversions
}

// NewCodeGenerator creates a new code generator instance
func NewCodeGenerator() *CodeGenerator <span class="cov0" title="0">{
        cg := &amp;CodeGenerator{
                indentLevel:   0,
                buffer:        strings.Builder{},
                imports:       make(map[string]bool, 8),   // Pre-allocate for common imports
                indentCache:   make([]string, 0, 10),      // Pre-allocate for common indentation levels
                operatorCache: make(map[string]string, 4), // Cache for +, -, *, /
        }
        cg.buffer.Grow(1024) // Pre-allocate capacity for typical Go code generation
        return cg
}</span>

// EmitNumber generates Go code for a numeric literal
func (cg *CodeGenerator) EmitNumber(value string) <span class="cov0" title="0">{
        cg.writeIndented("_ = " + value + "\n")
}</span>

// EmitString generates Go code for a string literal
func (cg *CodeGenerator) EmitString(value string) <span class="cov0" title="0">{
        cg.writeIndented("_ = " + value + "\n")
}</span>

// EmitSymbol generates Go code for a symbol
func (cg *CodeGenerator) EmitSymbol(symbol string) <span class="cov0" title="0">{
        cg.writeIndented("_ = " + symbol + "\n")
}</span>

// EmitVariableDefinition generates Go code for variable definition
// (def x 10) -&gt; x := 10
// TODO: This should only be called if semantic analysis determines the variable is used later
// Otherwise, Go will produce "declared and not used" errors, which is correct behavior
func (cg *CodeGenerator) EmitVariableDefinition(name, value string) <span class="cov0" title="0">{
        cg.writeIndented(name + " := " + value + "\n")
}</span>

// EmitExpressionStatement generates Go code for standalone expressions
// (42) or (+ 1 2) -&gt; _ = 42 or _ = 1 + 2 (discarded result)
func (cg *CodeGenerator) EmitExpressionStatement(expression string) <span class="cov0" title="0">{
        cg.writeIndented("_ = " + expression + "\n")
}</span>

// EmitArithmeticExpression generates Go code for arithmetic operations
// (+ 1 2) -&gt; 1 + 2
func (cg *CodeGenerator) EmitArithmeticExpression(operator string, operands []string) <span class="cov0" title="0">{
        if len(operands) &lt; 2 </span><span class="cov0" title="0">{
                cg.writeIndented("// Invalid arithmetic expression with " + strconv.Itoa(len(operands)) + " operands\n")
                return
        }</span>

        // Convert Lisp prefix notation to Go infix notation
        <span class="cov0" title="0">goOperator := cg.convertOperator(operator)
        expression := strings.Join(operands, " "+goOperator+" ")
        cg.writeIndented("_ = " + expression + "\n")</span>
}

// EmitImport collects import statements for later generation
// (import "net/http") -&gt; adds to imports collection
func (cg *CodeGenerator) EmitImport(importPath string) <span class="cov0" title="0">{
        // Clean the import path (remove quotes if they exist, then add them back)
        cleanPath := strings.Trim(importPath, "\"")
        cg.imports["\""+cleanPath+"\""] = true
}</span>

// EmitMethodCall generates Go method calls
// (.HandleFunc router "/path" handler) -&gt; router.HandleFunc("/path", handler)
func (cg *CodeGenerator) EmitMethodCall(receiver, methodName string, args []string) <span class="cov0" title="0">{
        argsStr := strings.Join(args, ", ")
        cg.writeIndented("_ = " + receiver + "." + methodName + "(" + argsStr + ")\n")
}</span>

// EmitSlashNotationCall generates Go package function calls from slash notation
// (fmt/Println "message") -&gt; fmt.Println("message")
func (cg *CodeGenerator) EmitSlashNotationCall(packageName, functionName string, args []string) <span class="cov0" title="0">{
        argsStr := strings.Join(args, ", ")
        cg.writeIndented(packageName + "." + functionName + "(" + argsStr + ")\n")
}</span>

// EmitFunctionLiteral generates Go function literals
// (fn [w r] body) -&gt; func(w http.ResponseWriter, r *http.Request) { body }
func (cg *CodeGenerator) EmitFunctionLiteral(params []string, bodyElements []antlr.Tree, visitor *ASTVisitor) string <span class="cov0" title="0">{
        var result strings.Builder
        result.Grow(128) // Pre-allocate capacity for typical function literals

        // Start function literal
        result.WriteString("func(")

        // Add parameters with types
        if len(params) == 2 </span><span class="cov0" title="0">{
                // Assume HTTP handler signature for 2 parameters
                result.WriteString(params[0] + " http.ResponseWriter, " + params[1] + " *http.Request")
                // Add http import
                cg.EmitImport("\"net/http\"")
        }</span> else<span class="cov0" title="0"> {
                // Generic parameters - types will need to be inferred or specified
                for i, param := range params </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                result.WriteString(", ")
                        }</span>
                        <span class="cov0" title="0">result.WriteString(param + " interface{}")</span>
                }
        }

        <span class="cov0" title="0">result.WriteString(") {\n")

        // Generate function body by processing each body element
        for _, bodyElement := range bodyElements </span><span class="cov0" title="0">{
                bodyCode := cg.processFunctionBodyElement(bodyElement, visitor)
                if bodyCode != "" </span><span class="cov0" title="0">{
                        result.WriteString("\t" + bodyCode + "\n")
                }</span>
        }

        <span class="cov0" title="0">result.WriteString("}")

        return result.String()</span>
}

// getStringSlice returns a pooled string slice
func getStringSlice() []string <span class="cov0" title="0">{
        slice := stringSlicePool.Get().([]string)
        return slice[:0] // Reset length but keep capacity
}</span>

// putStringSlice returns a string slice to the pool
func putStringSlice(slice []string) <span class="cov0" title="0">{
        if cap(slice) &gt; 64 </span><span class="cov0" title="0">{ // Avoid keeping very large slices in pool
                return
        }</span>
        <span class="cov0" title="0">stringSlicePool.Put(slice)</span>
}

// processFunctionBodyElement processes a single element in a function body
func (cg *CodeGenerator) processFunctionBodyElement(element antlr.Tree, visitor *ASTVisitor) string <span class="cov0" title="0">{
        switch ctx := element.(type) </span>{
        case *parser.ListContext:<span class="cov0" title="0">
                // Method calls, function calls, etc.
                children := ctx.GetChildren()
                if len(children) &lt; 3 </span><span class="cov0" title="0">{ // Need at least ( symbol )
                        return ""
                }</span>

                // Get the first element (function/method name)
                <span class="cov0" title="0">firstChild := children[1] // Skip opening parenthesis
                if terminalNode, ok := firstChild.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                        firstElement := terminalNode.GetText()

                        // Extract arguments (skip opening paren, function name, closing paren)
                        args := getStringSlice()
                        defer putStringSlice(args)
                        for i := 2; i &lt; len(children)-1; i++ </span><span class="cov0" title="0">{
                                argValue := visitor.evaluateExpression(children[i])
                                args = append(args, argValue)
                        }</span>

                        <span class="cov0" title="0">if strings.HasPrefix(firstElement, ".") </span><span class="cov0" title="0">{
                                // Method call: (.WriteString w "Hello!")
                                if len(args) &gt;= 1 </span><span class="cov0" title="0">{
                                        receiver := args[0]
                                        methodArgs := args[1:]
                                        argsStr := strings.Join(methodArgs, ", ")
                                        return receiver + "." + firstElement[1:] + "(" + argsStr + ")"
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Function call: (fmt.Println "Hello")
                                argsStr := strings.Join(args, ", ")
                                return firstElement + "(" + argsStr + ")"
                        }</span>
                }

        default:<span class="cov0" title="0">
                // Use the visitor's evaluateExpression for everything else
                return visitor.evaluateExpression(element)</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// convertOperator converts Vex operators to Go operators (with caching)
func (cg *CodeGenerator) convertOperator(vexOp string) string <span class="cov0" title="0">{
        // Check cache first
        if goOp, exists := cg.operatorCache[vexOp]; exists </span><span class="cov0" title="0">{
                return goOp
        }</span>

        // Compute and cache result
        <span class="cov0" title="0">var goOp string
        switch vexOp </span>{
        case "+":<span class="cov0" title="0">
                goOp = "+"</span>
        case "-":<span class="cov0" title="0">
                goOp = "-"</span>
        case "*":<span class="cov0" title="0">
                goOp = "*"</span>
        case "/":<span class="cov0" title="0">
                goOp = "/"</span>
        default:<span class="cov0" title="0">
                goOp = vexOp</span> // fallback
        }

        <span class="cov0" title="0">cg.operatorCache[vexOp] = goOp
        return goOp</span>
}

// IncreaseIndent increases the current indentation level
func (cg *CodeGenerator) IncreaseIndent() <span class="cov0" title="0">{
        cg.indentLevel++
}</span>

// DecreaseIndent decreases the current indentation level
func (cg *CodeGenerator) DecreaseIndent() <span class="cov0" title="0">{
        if cg.indentLevel &gt; 0 </span><span class="cov0" title="0">{
                cg.indentLevel--
        }</span>
}

// writeIndented writes a line with proper indentation
func (cg *CodeGenerator) writeIndented(line string) <span class="cov0" title="0">{
        indent := cg.getIndent()
        cg.buffer.WriteString(indent + line)
}</span>

// getIndent returns cached indentation string for current level
func (cg *CodeGenerator) getIndent() string <span class="cov0" title="0">{
        // Extend cache if needed
        for len(cg.indentCache) &lt;= cg.indentLevel </span><span class="cov0" title="0">{
                level := len(cg.indentCache)
                cg.indentCache = append(cg.indentCache, strings.Repeat("\t", level))
        }</span>
        <span class="cov0" title="0">return cg.indentCache[cg.indentLevel]</span>
}

// GetCode returns the generated code
func (cg *CodeGenerator) GetCode() string <span class="cov0" title="0">{
        return cg.buffer.String()
}</span>

// GetImports returns all collected imports
func (cg *CodeGenerator) GetImports() []string <span class="cov0" title="0">{
        imports := getStringSlice()
        for importPath := range cg.imports </span><span class="cov0" title="0">{
                imports = append(imports, importPath)
        }</span>
        // Don't defer putStringSlice since we're returning the slice
        <span class="cov0" title="0">return imports</span>
}

// Reset clears the code generator state
func (cg *CodeGenerator) Reset() <span class="cov0" title="0">{
        cg.buffer.Reset()
        cg.indentLevel = 0
        cg.imports = make(map[string]bool, 8) // Pre-allocate for common imports
        // Keep caches but clear them to avoid memory leaks
        cg.indentCache = cg.indentCache[:0]           // Keep capacity, reset length
        cg.operatorCache = make(map[string]string, 4) // Cache for +, -, *, /
}</span>

// Typed code generation methods for semantic visitor

// EmitTypedVariableDefinition generates Go code for typed variable definition
func (cg *CodeGenerator) EmitTypedVariableDefinition(name, value string, vexType VexType) <span class="cov0" title="0">{
        goType := vexType.GoType()
        if goType == "interface{}" </span><span class="cov0" title="0">{
                // Use type inference if type is unknown
                cg.writeIndented(name + " := " + value + "\n")
        }</span> else<span class="cov0" title="0"> {
                // Use explicit type declaration
                cg.writeIndented("var " + name + " " + goType + " = " + value + "\n")
        }</span>
        // Add a dummy usage to prevent "declared and not used" errors
        <span class="cov0" title="0">cg.writeIndented("_ = " + name + "\n")</span>
}

// EmitTypedFunction generates Go code for typed function definition
func (cg *CodeGenerator) EmitTypedFunction(name string, paramNames []string, paramTypes []VexType, returnType VexType) <span class="cov0" title="0">{
        cg.writeIndented("func " + name + "(")

        // Generate parameter list with types
        for i, paramName := range paramNames </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        cg.buffer.WriteString(", ")
                }</span>
                <span class="cov0" title="0">paramType := "interface{}"
                if i &lt; len(paramTypes) &amp;&amp; paramTypes[i].GoType() != "interface{}" </span><span class="cov0" title="0">{
                        paramType = paramTypes[i].GoType()
                }</span>
                <span class="cov0" title="0">cg.buffer.WriteString(paramName + " " + paramType)</span>
        }

        <span class="cov0" title="0">cg.buffer.WriteString(") ")

        // Add return type if not unknown
        if returnType.GoType() != "interface{}" </span><span class="cov0" title="0">{
                cg.buffer.WriteString(returnType.GoType() + " ")
        }</span>

        <span class="cov0" title="0">cg.buffer.WriteString("{\n")
        cg.IncreaseIndent()</span>
        // Function body will be added by subsequent calls
}

// EmitTypedFunctionLiteral generates Go code for typed function literal
func (cg *CodeGenerator) EmitTypedFunctionLiteral(paramNames []string, paramTypes []VexType, returnType VexType) <span class="cov0" title="0">{
        cg.writeIndented("func(")

        // Generate parameter list with types
        for i, paramName := range paramNames </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        cg.buffer.WriteString(", ")
                }</span>
                <span class="cov0" title="0">paramType := "interface{}"
                if i &lt; len(paramTypes) &amp;&amp; paramTypes[i].GoType() != "interface{}" </span><span class="cov0" title="0">{
                        paramType = paramTypes[i].GoType()
                }</span>
                <span class="cov0" title="0">cg.buffer.WriteString(paramName + " " + paramType)</span>
        }

        <span class="cov0" title="0">cg.buffer.WriteString(") ")

        // Add return type if not unknown
        if returnType.GoType() != "interface{}" </span><span class="cov0" title="0">{
                cg.buffer.WriteString(returnType.GoType() + " ")
        }</span>

        <span class="cov0" title="0">cg.buffer.WriteString("{\n")</span>
        // Function body will be handled separately
}

// EmitTypedArithmeticExpression generates Go code for typed arithmetic
func (cg *CodeGenerator) EmitTypedArithmeticExpression(operator string, operands []string, resultType VexType) <span class="cov0" title="0">{
        if len(operands) &lt; 2 </span><span class="cov0" title="0">{
                cg.writeIndented("// Invalid arithmetic expression\n")
                return
        }</span>

        // Build expression with proper type casting if needed
        <span class="cov0" title="0">var expr string
        if resultType.Equals(FloatType) </span><span class="cov0" title="0">{
                // Ensure float operations
                expr = cg.buildFloatArithmetic(operator, operands)
        }</span> else<span class="cov0" title="0"> {
                // Regular integer arithmetic
                expr = cg.buildIntArithmetic(operator, operands)
        }</span>

        <span class="cov0" title="0">cg.writeIndented("_ = " + expr + "\n")</span>
}

// EmitTypedConditional generates Go code for typed conditional expression
func (cg *CodeGenerator) EmitTypedConditional(condition, thenBranch, elseBranch string, resultType VexType) <span class="cov0" title="0">{
        cg.writeIndented("func() " + resultType.GoType() + " {\n")
        cg.IncreaseIndent()
        cg.writeIndented("if " + condition + " {\n")
        cg.IncreaseIndent()
        cg.writeIndented("return " + thenBranch + "\n")
        cg.DecreaseIndent()
        cg.writeIndented("} else {\n")
        cg.IncreaseIndent()
        cg.writeIndented("return " + elseBranch + "\n")
        cg.DecreaseIndent()
        cg.writeIndented("}\n")
        cg.DecreaseIndent()
        cg.writeIndented("}()\n")
}</span>

// EmitTypedMethodCall generates Go code for typed method call
func (cg *CodeGenerator) EmitTypedMethodCall(receiver, method string, args []string, receiverType VexType, argTypes []VexType) <span class="cov0" title="0">{
        // Add type assertions if needed
        typedReceiver := receiver
        if receiverType.GoType() != "interface{}" </span><span class="cov0" title="0">{
                // Could add type assertion here if needed
                typedReceiver = receiver
        }</span>

        <span class="cov0" title="0">cg.writeIndented("_ = " + typedReceiver + "." + method + "(")
        for i, arg := range args </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        cg.buffer.WriteString(", ")
                }</span>
                <span class="cov0" title="0">cg.buffer.WriteString(arg)</span>
        }
        <span class="cov0" title="0">cg.buffer.WriteString(")\n")</span>
}

// EmitTypedSlashNotationCall generates Go code for typed package function call
func (cg *CodeGenerator) EmitTypedSlashNotationCall(packageName, funcName string, args []string, argTypes []VexType) <span class="cov0" title="0">{
        cg.EmitImport("\"" + packageName + "\"")

        // Don't assign function calls to _ - just execute them as statements
        cg.writeIndented(packageName + "." + funcName + "(")
        for i, arg := range args </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        cg.buffer.WriteString(", ")
                }</span>
                <span class="cov0" title="0">cg.buffer.WriteString(arg)</span>
        }
        <span class="cov0" title="0">cg.buffer.WriteString(")\n")</span>
}

// EmitTypedFunctionCall generates Go code for typed function call
func (cg *CodeGenerator) EmitTypedFunctionCall(functionName string, args []string, returnType VexType) <span class="cov0" title="0">{
        var expr string
        if returnType.GoType() == "interface{}" </span><span class="cov0" title="0">{
                expr = functionName + "("
        }</span> else<span class="cov0" title="0"> {
                expr = functionName + "("
        }</span>

        <span class="cov0" title="0">for i, arg := range args </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        expr += ", "
                }</span>
                <span class="cov0" title="0">expr += arg</span>
        }
        <span class="cov0" title="0">expr += ")"

        cg.writeIndented("_ = " + expr + "\n")</span>
}

// EmitTypedArray generates Go code for typed array literal
func (cg *CodeGenerator) EmitTypedArray(listType *ListType) <span class="cov0" title="0">{
        elementType := listType.ElementType.GoType()
        if elementType == "interface{}" </span><span class="cov0" title="0">{
                cg.writeIndented("_ = []interface{}{}\n")
        }</span> else<span class="cov0" title="0"> {
                cg.writeIndented("_ = []" + elementType + "{}\n")
        }</span>
}

// EmitArray generates Go code for generic array literal (fallback)
func (cg *CodeGenerator) EmitArray() <span class="cov0" title="0">{
        cg.writeIndented("_ = []interface{}{}\n")
}</span>

// Helper methods for typed arithmetic

// buildFloatArithmetic builds float arithmetic expressions
func (cg *CodeGenerator) buildFloatArithmetic(operator string, operands []string) string <span class="cov0" title="0">{
        goOperator := cg.convertOperator(operator)

        // Ensure all operands are float64
        floatOperands := make([]string, len(operands))
        for i, operand := range operands </span><span class="cov0" title="0">{
                if strings.Contains(operand, ".") </span><span class="cov0" title="0">{
                        floatOperands[i] = operand
                }</span> else<span class="cov0" title="0"> {
                        floatOperands[i] = "float64(" + operand + ")"
                }</span>
        }

        // Build left-associative expression
        <span class="cov0" title="0">result := floatOperands[0]
        for i := 1; i &lt; len(floatOperands); i++ </span><span class="cov0" title="0">{
                result = "(" + result + " " + goOperator + " " + floatOperands[i] + ")"
        }</span>

        <span class="cov0" title="0">return result</span>
}

// buildIntArithmetic builds integer arithmetic expressions
func (cg *CodeGenerator) buildIntArithmetic(operator string, operands []string) string <span class="cov0" title="0">{
        goOperator := cg.convertOperator(operator)

        // Build left-associative expression
        result := operands[0]
        for i := 1; i &lt; len(operands); i++ </span><span class="cov0" title="0">{
                result = "(" + result + " " + goOperator + " " + operands[i] + ")"
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package transpiler provides macro collection for user-defined macros
package transpiler

import (
        "fmt"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// MacroCollector finds and registers user-defined macros before macro expansion
type MacroCollector struct {
        expander *MacroExpander
}

// NewMacroCollector creates a new macro collector
func NewMacroCollector(expander *MacroExpander) *MacroCollector <span class="cov0" title="0">{
        return &amp;MacroCollector{
                expander: expander,
        }
}</span>

// CollectMacros walks the AST to find and register macro definitions
func (mc *MacroCollector) CollectMacros(programCtx *parser.ProgramContext) error <span class="cov0" title="0">{
        for _, child := range programCtx.GetChildren() </span><span class="cov0" title="0">{
                if listCtx, ok := child.(*parser.ListContext); ok </span><span class="cov0" title="0">{
                        err := mc.collectFromList(listCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// collectFromList processes a list expression looking for macro definitions
func (mc *MacroCollector) collectFromList(listCtx *parser.ListContext) error <span class="cov0" title="0">{
        children := listCtx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{ // '(' ... ')'
                return nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        if len(content) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check if this is a macro definition
        <span class="cov0" title="0">firstChild := content[0]
        var firstElement string
        if symbolCtx, ok := firstChild.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                firstElement = symbolCtx.GetText()
        }</span>

        <span class="cov0" title="0">if firstElement == "macro" </span><span class="cov0" title="0">{
                return mc.processMacroDefinition(content[1:]) // Skip "macro" keyword
        }</span>

        // Recursively process nested lists
        <span class="cov0" title="0">for _, child := range content </span><span class="cov0" title="0">{
                if nestedList, ok := child.(*parser.ListContext); ok </span><span class="cov0" title="0">{
                        err := mc.collectFromList(nestedList)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// processMacroDefinition processes a macro definition and registers it with the expander
func (mc *MacroCollector) processMacroDefinition(content []antlr.Tree) error <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                // Invalid macro definition, but don't fail - let the semantic analyzer handle the error
                return nil
        }</span>

        // Get macro name
        <span class="cov0" title="0">var macroName string
        if symbolCtx, ok := content[0].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                macroName = symbolCtx.GetText()
        }</span> else<span class="cov0" title="0"> {
                return nil // Invalid, but continue processing
        }</span>

        // Get parameters from array
        <span class="cov0" title="0">paramList := content[1]
        var params []string
        if arrayCtx, ok := paramList.(*parser.ArrayContext); ok </span><span class="cov0" title="0">{
                children := arrayCtx.GetChildren()
                // Skip [ and ] brackets
                for i := 1; i &lt; len(children)-1; i++ </span><span class="cov0" title="0">{
                        if terminalNode, ok := children[i].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                                params = append(params, terminalNode.GetText())
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return nil // Invalid parameters, continue processing
        }</span>

        // Get macro body template
        <span class="cov0" title="0">if len(content) &gt; 2 </span><span class="cov0" title="0">{
                template := content[2]
                templateStr := mc.reconstructTemplate(template)

                // Debug: print macro registration
                fmt.Printf("DEBUG: Registering macro '%s' with params %v and template: %s\n", macroName, params, templateStr)

                // Register the macro with the expander using a string-based expansion function
                mc.expander.RegisterStringMacro(macroName, params, templateStr)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// reconstructTemplate converts an AST node back to its string representation
func (mc *MacroCollector) reconstructTemplate(node antlr.Tree) string <span class="cov0" title="0">{
        return reconstructSource(node) // Reuse the existing function from macro_registry.go
}</span>

// RegisterStringMacro is a method we need to add to MacroExpander for string-based macros
// This will be added to the MacroExpander struct
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package transpiler provides macro expansion capabilities
package transpiler

import (
        "fmt"
        "regexp"
        "strings"
)

// MacroExpander handles macro expansion for Vex source code
type MacroExpander struct {
        macros     map[string]MacroExpanderFunc
        regexCache map[string]*regexp.Regexp
}

// MacroExpanderFunc represents a macro that transforms source code
type MacroExpanderFunc func(match string, args []string) (string, error)

// NewMacroExpander creates a new macro expander with built-in macros
func NewMacroExpander() *MacroExpander <span class="cov0" title="0">{
        expander := &amp;MacroExpander{
                macros:     make(map[string]MacroExpanderFunc, 4), // Pre-allocate for common built-ins
                regexCache: make(map[string]*regexp.Regexp, 4),    // Pre-allocate for common macros
        }

        // Register built-in macros
        expander.registerBuiltinMacros()

        return expander
}</span>

// registerBuiltinMacros registers the built-in macros
func (me *MacroExpander) registerBuiltinMacros() <span class="cov0" title="0">{
        me.macros["http-server"] = me.expandHttpServer
}</span>

// RegisterStringMacro registers a user-defined macro with string template
func (me *MacroExpander) RegisterStringMacro(name string, params []string, template string) <span class="cov0" title="0">{
        me.macros[name] = func(match string, args []string) (string, error) </span><span class="cov0" title="0">{
                return me.expandStringMacro(name, params, template, args)
        }</span>
}

// expandStringMacro expands a string-based user-defined macro
func (me *MacroExpander) expandStringMacro(name string, params []string, template string, args []string) (string, error) <span class="cov0" title="0">{
        // Debug output
        // Create substitution map
        substitutions := make(map[string]string, len(params))

        // Map arguments to parameters
        for i, param := range params </span><span class="cov0" title="0">{
                if i &lt; len(args) </span><span class="cov0" title="0">{
                        substitutions[param] = args[i]
                }</span>
        }

        // Apply substitutions to template
        <span class="cov0" title="0">expanded := template
        for param, value := range substitutions </span><span class="cov0" title="0">{
                // Handle template syntax: ~param becomes the value
                expanded = strings.ReplaceAll(expanded, "~"+param, value)
        }</span>

        // Macro expansion completed successfully
        <span class="cov0" title="0">return expanded, nil</span>
}

// ExpandMacros expands macros in Vex source code using multi-pass expansion
func (me *MacroExpander) ExpandMacros(source string) (string, error) <span class="cov0" title="0">{
        expanded := source
        maxPasses := 10 // Prevent infinite loops

        // Start multi-pass expansion
        for pass := 1; pass &lt;= maxPasses; pass++ </span><span class="cov0" title="0">{
                // Look for new macro definitions in the current expanded text
                newMacros := me.collectNewMacroDefinitions(expanded)

                if len(newMacros) &gt; 0 </span><span class="cov0" title="0">{
                        // Register new macros found in this pass
                        for name, macroDef := range newMacros </span><span class="cov0" title="0">{
                                me.RegisterStringMacro(name, macroDef.Params, macroDef.Template)
                        }</span>
                }

                // Remove all macro definitions before expansion
                <span class="cov0" title="0">beforeRemoval := expanded
                expanded = me.removeMacroDefinitions(expanded)

                // Expand all registered macros
                hadExpansion := false
                for macroName, macroFunc := range me.macros </span><span class="cov0" title="0">{
                        before := expanded
                        var err error
                        expanded, err = me.expandMacroInSource(expanded, macroName, macroFunc)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("error expanding macro %s in pass %d: %w", macroName, pass, err)
                        }</span>
                        <span class="cov0" title="0">if expanded != before </span><span class="cov0" title="0">{
                                hadExpansion = true
                        }</span>
                }

                // If we found no new macros and had no expansions, we're done
                <span class="cov0" title="0">if len(newMacros) == 0 &amp;&amp; !hadExpansion &amp;&amp; beforeRemoval == expanded </span><span class="cov0" title="0">{
                        break</span>
                }

                // Safety check for infinite loops
                <span class="cov0" title="0">if pass == maxPasses </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("macro expansion exceeded maximum passes (%d), possible infinite recursion", maxPasses)
                }</span>
        }

        // Multi-pass expansion completed
        <span class="cov0" title="0">return expanded, nil</span>
}

// removeMacroDefinitions removes all (macro ...) definitions from source
func (me *MacroExpander) removeMacroDefinitions(source string) string <span class="cov0" title="0">{
        // Use a simple but effective approach: find (macro and match balanced parentheses
        result := source

        for </span><span class="cov0" title="0">{
                start := strings.Index(result, "(macro ")
                if start == -1 </span><span class="cov0" title="0">{
                        break</span> // No more macro definitions found
                }

                // Find the matching closing parenthesis
                <span class="cov0" title="0">depth := 0
                end := start
                for i := start; i &lt; len(result); i++ </span><span class="cov0" title="0">{
                        if result[i] == '(' </span><span class="cov0" title="0">{
                                depth++
                        }</span> else<span class="cov0" title="0"> if result[i] == ')' </span><span class="cov0" title="0">{
                                depth--
                                if depth == 0 </span><span class="cov0" title="0">{
                                        end = i + 1
                                        break</span>
                                }
                        }
                }

                // Remove the macro definition
                <span class="cov0" title="0">result = result[:start] + result[end:]</span>
        }

        // Clean up multiple newlines
        <span class="cov0" title="0">result = regexp.MustCompile(`\n\s*\n\s*\n`).ReplaceAllString(result, "\n\n")

        // Macro definitions removed successfully
        return result</span>
}

// collectNewMacroDefinitions finds and extracts new macro definitions from expanded text
func (me *MacroExpander) collectNewMacroDefinitions(source string) map[string]*ParsedMacroDefinition <span class="cov0" title="0">{
        newMacros := make(map[string]*ParsedMacroDefinition)

        for </span><span class="cov0" title="0">{
                start := strings.Index(source, "(macro ")
                if start == -1 </span><span class="cov0" title="0">{
                        break</span> // No more macro definitions found
                }

                // Find the matching closing parenthesis
                <span class="cov0" title="0">depth := 0
                end := start
                for i := start; i &lt; len(source); i++ </span><span class="cov0" title="0">{
                        if source[i] == '(' </span><span class="cov0" title="0">{
                                depth++
                        }</span> else<span class="cov0" title="0"> if source[i] == ')' </span><span class="cov0" title="0">{
                                depth--
                                if depth == 0 </span><span class="cov0" title="0">{
                                        end = i + 1
                                        break</span>
                                }
                        }
                }

                // Extract and parse the macro definition
                <span class="cov0" title="0">macroDefText := source[start:end]
                if macroDef := me.parseMacroDefinition(macroDefText); macroDef != nil </span><span class="cov0" title="0">{
                        newMacros[macroDef.Name] = macroDef
                }</span>

                // Move past this macro definition
                <span class="cov0" title="0">source = source[end:]</span>
        }

        <span class="cov0" title="0">return newMacros</span>
}

// ParsedMacroDefinition represents a parsed macro definition from text
type ParsedMacroDefinition struct {
        Name     string
        Params   []string
        Template string
}

// parseMacroDefinition parses a single macro definition from text
func (me *MacroExpander) parseMacroDefinition(macroText string) *ParsedMacroDefinition <span class="cov0" title="0">{
        // Simple parsing: (macro name [params] template)
        // Remove outer parentheses
        if len(macroText) &lt; 8 || !strings.HasPrefix(macroText, "(macro ") </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">content := strings.TrimSpace(macroText[7 : len(macroText)-1]) // Remove "(macro " and ")"

        // Split into parts
        parts := strings.Fields(content)
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">name := parts[0]

        // Find parameter list [...]
        paramStart := strings.Index(content, "[")
        paramEnd := strings.Index(content, "]")
        if paramStart == -1 || paramEnd == -1 || paramEnd &lt;= paramStart </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">paramStr := content[paramStart+1 : paramEnd]
        params := []string{}
        if strings.TrimSpace(paramStr) != "" </span><span class="cov0" title="0">{
                params = strings.Fields(paramStr)
        }</span>

        // Template is everything after the parameter list
        <span class="cov0" title="0">template := strings.TrimSpace(content[paramEnd+1:])

        return &amp;ParsedMacroDefinition{
                Name:     name,
                Params:   params,
                Template: template,
        }</span>
}

// expandMacroInSource expands a specific macro in the source code
func (me *MacroExpander) expandMacroInSource(source, macroName string, macroFunc MacroExpanderFunc) (string, error) <span class="cov0" title="0">{
        // Check if we have a cached regex for this macro
        re, exists := me.regexCache[macroName]
        if !exists </span><span class="cov0" title="0">{
                // Compile and cache the regex pattern for this macro
                // Pattern to match: (macroName ... with balanced parentheses/brackets ...)
                pattern := `\(` + regexp.QuoteMeta(macroName) + `(?:[^()]|\([^()]*\)|\[[^\]]*\])*\)`
                re = regexp.MustCompile(pattern)
                me.regexCache[macroName] = re
        }</span>

        // Find all matches
        <span class="cov0" title="0">return re.ReplaceAllStringFunc(source, func(match string) string </span><span class="cov0" title="0">{
                // Extract arguments from the match
                args := me.extractArguments(match, macroName)

                // Expand the macro
                expanded, err := macroFunc(match, args)
                if err != nil </span><span class="cov0" title="0">{
                        // In a real implementation, we'd handle this error properly
                        return fmt.Sprintf("/* ERROR: %s */", err.Error())
                }</span>

                <span class="cov0" title="0">return expanded</span>
        }), nil
}

// extractArguments extracts arguments from a macro call
func (me *MacroExpander) extractArguments(match, macroName string) []string <span class="cov0" title="0">{
        // Remove the opening paren and macro name
        content := strings.TrimPrefix(match, "("+macroName)
        content = strings.TrimSuffix(content, ")")
        content = strings.TrimSpace(content)

        if content == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        // Parse arguments respecting nested parentheses and brackets
        <span class="cov0" title="0">return me.parseArguments(content)</span>
}

// parseArguments parses macro arguments respecting nested structures
func (me *MacroExpander) parseArguments(content string) []string <span class="cov0" title="0">{
        var args []string
        var current strings.Builder
        depth := 0
        inString := false

        for i, char := range content </span><span class="cov0" title="0">{
                switch char </span>{
                case '"':<span class="cov0" title="0">
                        // Toggle string state (ignoring escaped quotes for simplicity)
                        if i == 0 || content[i-1] != '\\' </span><span class="cov0" title="0">{
                                inString = !inString
                        }</span>
                        <span class="cov0" title="0">current.WriteRune(char)</span>

                case '(', '[':<span class="cov0" title="0">
                        if !inString </span><span class="cov0" title="0">{
                                depth++
                        }</span>
                        <span class="cov0" title="0">current.WriteRune(char)</span>

                case ')', ']':<span class="cov0" title="0">
                        if !inString </span><span class="cov0" title="0">{
                                depth--
                        }</span>
                        <span class="cov0" title="0">current.WriteRune(char)</span>

                case ' ', '\t', '\n':<span class="cov0" title="0">
                        if !inString &amp;&amp; depth == 0 </span><span class="cov0" title="0">{
                                // We're at the top level and hit whitespace - end current argument
                                if current.Len() &gt; 0 </span><span class="cov0" title="0">{
                                        args = append(args, strings.TrimSpace(current.String()))
                                        current.Reset()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                current.WriteRune(char)
                        }</span>

                default:<span class="cov0" title="0">
                        current.WriteRune(char)</span>
                }
        }

        // Add the last argument
        <span class="cov0" title="0">if current.Len() &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, strings.TrimSpace(current.String()))
        }</span>

        <span class="cov0" title="0">return args</span>
}

// expandHttpServer expands the http-server macro
func (me *MacroExpander) expandHttpServer(match string, args []string) (string, error) <span class="cov0" title="0">{
        // Generate simpler expanded Vex code
        expanded := `(import "net/http")
(import "github.com/gorilla/mux")
(def router (.NewRouter mux))
(.HandleFunc router "/hello" hello-handler)
(.ListenAndServe http ":8080" router)`

        return expanded, nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package transpiler provides dynamic macro registration
package transpiler

import (
        "fmt"
        "strings"

        "github.com/antlr4-go/antlr/v4"
)

// MacroDefinition represents a user-defined macro
type MacroDefinition struct {
        Name       string
        Parameters []string
        Template   antlr.Tree // The macro body template
}

// MacroRegistry stores dynamically registered macros
type MacroRegistry struct {
        macros map[string]*MacroDefinition
}

// NewMacroRegistry creates a new macro registry
func NewMacroRegistry() *MacroRegistry <span class="cov0" title="0">{
        return &amp;MacroRegistry{
                macros: make(map[string]*MacroDefinition, 8), // Pre-allocate for common user macros
        }
}</span>

// RegisterMacro adds a new macro to the registry
func (mr *MacroRegistry) RegisterMacro(name string, params []string, template antlr.Tree) <span class="cov0" title="0">{
        mr.macros[name] = &amp;MacroDefinition{
                Name:       name,
                Parameters: params,
                Template:   template,
        }
}</span>

// GetMacro retrieves a macro by name
func (mr *MacroRegistry) GetMacro(name string) (*MacroDefinition, bool) <span class="cov0" title="0">{
        macro, exists := mr.macros[name]
        return macro, exists
}</span>

// IsMacro checks if a name is a registered macro
func (mr *MacroRegistry) IsMacro(name string) bool <span class="cov0" title="0">{
        _, exists := mr.macros[name]
        return exists
}</span>

// ExpandMacro expands a macro call with given arguments
func (mr *MacroRegistry) ExpandMacro(name string, args []antlr.Tree) (string, error) <span class="cov0" title="0">{
        macro, exists := mr.macros[name]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("macro %s not found", name)
        }</span>

        // Create substitution map
        <span class="cov0" title="0">substitutions := make(map[string]string, len(macro.Parameters)) // Pre-allocate for exact parameter count

        // Map arguments to parameters
        for i, param := range macro.Parameters </span><span class="cov0" title="0">{
                if i &lt; len(args) </span><span class="cov0" title="0">{
                        // Convert argument to string representation
                        argStr := nodeToString(args[i])
                        substitutions[param] = argStr
                }</span>
        }

        // Expand the template with substitutions
        <span class="cov0" title="0">expanded := expandTemplate(macro.Template, substitutions)

        return expanded, nil</span>
}

// nodeToString converts an AST node to its string representation
func nodeToString(node antlr.Tree) string <span class="cov0" title="0">{
        if terminalNode, ok := node.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                return terminalNode.GetText()
        }</span>

        // For complex nodes, reconstruct the source
        <span class="cov0" title="0">return reconstructSource(node)</span>
}

// reconstructSource reconstructs source code from AST node
func reconstructSource(node antlr.Tree) string <span class="cov0" title="0">{
        switch ctx := node.(type) </span>{
        case *antlr.TerminalNodeImpl:<span class="cov0" title="0">
                return ctx.GetText()</span>
        default:<span class="cov0" title="0">
                // For lists and arrays, reconstruct with proper brackets
                children := ctx.GetChildren()
                if len(children) == 0 </span><span class="cov0" title="0">{
                        return ""
                }</span>

                <span class="cov0" title="0">var result strings.Builder
                lastWasBracket := false

                for i, child := range children </span><span class="cov0" title="0">{
                        // Check if child is a terminal node before calling GetText
                        childText := ""
                        if terminalChild, ok := child.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                                childText = terminalChild.GetText()
                        }</span>

                        // Add space before non-bracket tokens, but not if:
                        // - This is the first token
                        // - The previous token was an opening bracket
                        // - This token is a closing bracket
                        <span class="cov0" title="0">isBracket := childText == "(" || childText == ")" || childText == "[" || childText == "]"

                        if i &gt; 0 &amp;&amp; !lastWasBracket &amp;&amp; !isBracket </span><span class="cov0" title="0">{
                                result.WriteString(" ")
                        }</span>

                        <span class="cov0" title="0">result.WriteString(reconstructSource(child))
                        lastWasBracket = (childText == "(" || childText == "[")</span>
                }
                <span class="cov0" title="0">return result.String()</span>
        }
}

// expandTemplate expands a template with parameter substitutions
func expandTemplate(template antlr.Tree, substitutions map[string]string) string <span class="cov0" title="0">{
        // For now, simple string-based substitution
        // A full implementation would handle proper AST transformation
        templateStr := reconstructSource(template)

        // Apply substitutions
        for param, value := range substitutions </span><span class="cov0" title="0">{
                // Handle template syntax: ~param becomes the value
                templateStr = strings.ReplaceAll(templateStr, "~"+param, value)
        }</span>

        <span class="cov0" title="0">return templateStr</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated from Vex.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // Vex

import "github.com/antlr4-go/antlr/v4"

// BaseVexListener is a complete listener for a parse tree produced by VexParser.
type BaseVexListener struct{}

var _ VexListener = &amp;BaseVexListener{}

// VisitTerminal is called when a terminal node is visited.
func (s *BaseVexListener) VisitTerminal(node antlr.TerminalNode) {<span class="cov0" title="0">}</span>

// VisitErrorNode is called when an error node is visited.
func (s *BaseVexListener) VisitErrorNode(node antlr.ErrorNode) {<span class="cov0" title="0">}</span>

// EnterEveryRule is called when any rule is entered.
func (s *BaseVexListener) EnterEveryRule(ctx antlr.ParserRuleContext) {<span class="cov0" title="0">}</span>

// ExitEveryRule is called when any rule is exited.
func (s *BaseVexListener) ExitEveryRule(ctx antlr.ParserRuleContext) {<span class="cov0" title="0">}</span>

// EnterProgram is called when production program is entered.
func (s *BaseVexListener) EnterProgram(ctx *ProgramContext) {<span class="cov0" title="0">}</span>

// ExitProgram is called when production program is exited.
func (s *BaseVexListener) ExitProgram(ctx *ProgramContext) {<span class="cov0" title="0">}</span>

// EnterList is called when production list is entered.
func (s *BaseVexListener) EnterList(ctx *ListContext) {<span class="cov0" title="0">}</span>

// ExitList is called when production list is exited.
func (s *BaseVexListener) ExitList(ctx *ListContext) {<span class="cov0" title="0">}</span>

// EnterArray is called when production array is entered.
func (s *BaseVexListener) EnterArray(ctx *ArrayContext) {<span class="cov0" title="0">}</span>

// ExitArray is called when production array is exited.
func (s *BaseVexListener) ExitArray(ctx *ArrayContext) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated from Vex.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // Vex

import "github.com/antlr4-go/antlr/v4"

type BaseVexVisitor struct {
        *antlr.BaseParseTreeVisitor
}

func (v *BaseVexVisitor) VisitProgram(ctx *ProgramContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseVexVisitor) VisitList(ctx *ListContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseVexVisitor) VisitArray(ctx *ArrayContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated from Vex.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser

import (
        "fmt"
        "github.com/antlr4-go/antlr/v4"
        "sync"
        "unicode"
)

// Suppress unused import error
var _ = fmt.Printf
var _ = sync.Once{}
var _ = unicode.IsLetter

type VexLexer struct {
        *antlr.BaseLexer
        channelNames []string
        modeNames    []string
        // TODO: EOF string
}

var VexLexerLexerStaticData struct {
        once                   sync.Once
        serializedATN          []int32
        ChannelNames           []string
        ModeNames              []string
        LiteralNames           []string
        SymbolicNames          []string
        RuleNames              []string
        PredictionContextCache *antlr.PredictionContextCache
        atn                    *antlr.ATN
        decisionToDFA          []*antlr.DFA
}

func vexlexerLexerInit() <span class="cov0" title="0">{
        staticData := &amp;VexLexerLexerStaticData
        staticData.ChannelNames = []string{
                "DEFAULT_TOKEN_CHANNEL", "HIDDEN",
        }
        staticData.ModeNames = []string{
                "DEFAULT_MODE",
        }
        staticData.LiteralNames = []string{
                "", "'('", "')'", "'['", "']'",
        }
        staticData.SymbolicNames = []string{
                "", "", "", "", "", "SYMBOL", "STRING", "LETTER", "INTEGER", "TRASH",
        }
        staticData.RuleNames = []string{
                "T__0", "T__1", "T__2", "T__3", "SYMBOL", "STRING", "LETTER", "INTEGER",
                "SEPARATOR", "WS", "COMMENT", "TRASH",
        }
        staticData.PredictionContextCache = antlr.NewPredictionContextCache()
        staticData.serializedATN = []int32{
                4, 0, 9, 73, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2,
                4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2,
                10, 7, 10, 2, 11, 7, 11, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3,
                1, 4, 1, 4, 1, 4, 4, 4, 37, 8, 4, 11, 4, 12, 4, 38, 1, 5, 1, 5, 1, 5, 1,
                5, 5, 5, 45, 8, 5, 10, 5, 12, 5, 48, 9, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7,
                1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 10, 1, 10, 5, 10, 62, 8, 10, 10, 10, 12,
                10, 65, 9, 10, 1, 11, 1, 11, 1, 11, 3, 11, 70, 8, 11, 1, 11, 1, 11, 0,
                0, 12, 1, 1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8, 17, 0, 19, 0,
                21, 0, 23, 9, 1, 0, 7, 7, 0, 33, 33, 42, 43, 45, 47, 58, 58, 60, 63, 95,
                95, 126, 126, 1, 0, 34, 34, 2, 0, 65, 90, 97, 122, 1, 0, 48, 57, 2, 0,
                32, 32, 44, 44, 4, 0, 9, 10, 13, 13, 32, 32, 44, 44, 2, 0, 10, 10, 13,
                13, 77, 0, 1, 1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1,
                0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 13, 1, 0, 0, 0, 0, 15,
                1, 0, 0, 0, 0, 23, 1, 0, 0, 0, 1, 25, 1, 0, 0, 0, 3, 27, 1, 0, 0, 0, 5,
                29, 1, 0, 0, 0, 7, 31, 1, 0, 0, 0, 9, 36, 1, 0, 0, 0, 11, 40, 1, 0, 0,
                0, 13, 51, 1, 0, 0, 0, 15, 53, 1, 0, 0, 0, 17, 55, 1, 0, 0, 0, 19, 57,
                1, 0, 0, 0, 21, 59, 1, 0, 0, 0, 23, 69, 1, 0, 0, 0, 25, 26, 5, 40, 0, 0,
                26, 2, 1, 0, 0, 0, 27, 28, 5, 41, 0, 0, 28, 4, 1, 0, 0, 0, 29, 30, 5, 91,
                0, 0, 30, 6, 1, 0, 0, 0, 31, 32, 5, 93, 0, 0, 32, 8, 1, 0, 0, 0, 33, 37,
                3, 13, 6, 0, 34, 37, 3, 15, 7, 0, 35, 37, 7, 0, 0, 0, 36, 33, 1, 0, 0,
                0, 36, 34, 1, 0, 0, 0, 36, 35, 1, 0, 0, 0, 37, 38, 1, 0, 0, 0, 38, 36,
                1, 0, 0, 0, 38, 39, 1, 0, 0, 0, 39, 10, 1, 0, 0, 0, 40, 46, 5, 34, 0, 0,
                41, 45, 8, 1, 0, 0, 42, 43, 5, 92, 0, 0, 43, 45, 5, 34, 0, 0, 44, 41, 1,
                0, 0, 0, 44, 42, 1, 0, 0, 0, 45, 48, 1, 0, 0, 0, 46, 44, 1, 0, 0, 0, 46,
                47, 1, 0, 0, 0, 47, 49, 1, 0, 0, 0, 48, 46, 1, 0, 0, 0, 49, 50, 5, 34,
                0, 0, 50, 12, 1, 0, 0, 0, 51, 52, 7, 2, 0, 0, 52, 14, 1, 0, 0, 0, 53, 54,
                7, 3, 0, 0, 54, 16, 1, 0, 0, 0, 55, 56, 7, 4, 0, 0, 56, 18, 1, 0, 0, 0,
                57, 58, 7, 5, 0, 0, 58, 20, 1, 0, 0, 0, 59, 63, 5, 59, 0, 0, 60, 62, 8,
                6, 0, 0, 61, 60, 1, 0, 0, 0, 62, 65, 1, 0, 0, 0, 63, 61, 1, 0, 0, 0, 63,
                64, 1, 0, 0, 0, 64, 22, 1, 0, 0, 0, 65, 63, 1, 0, 0, 0, 66, 70, 3, 19,
                9, 0, 67, 70, 3, 21, 10, 0, 68, 70, 3, 17, 8, 0, 69, 66, 1, 0, 0, 0, 69,
                67, 1, 0, 0, 0, 69, 68, 1, 0, 0, 0, 70, 71, 1, 0, 0, 0, 71, 72, 6, 11,
                0, 0, 72, 24, 1, 0, 0, 0, 7, 0, 36, 38, 44, 46, 63, 69, 1, 0, 1, 0,
        }
        deserializer := antlr.NewATNDeserializer(nil)
        staticData.atn = deserializer.Deserialize(staticData.serializedATN)
        atn := staticData.atn
        staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
        decisionToDFA := staticData.decisionToDFA
        for index, state := range atn.DecisionToState </span><span class="cov0" title="0">{
                decisionToDFA[index] = antlr.NewDFA(state, index)
        }</span>
}

// VexLexerInit initializes any static state used to implement VexLexer. By default the
// static state used to implement the lexer is lazily initialized during the first call to
// NewVexLexer(). You can call this function if you wish to initialize the static state ahead
// of time.
func VexLexerInit() <span class="cov0" title="0">{
        staticData := &amp;VexLexerLexerStaticData
        staticData.once.Do(vexlexerLexerInit)
}</span>

// NewVexLexer produces a new lexer instance for the optional input antlr.CharStream.
func NewVexLexer(input antlr.CharStream) *VexLexer <span class="cov0" title="0">{
        VexLexerInit()
        l := new(VexLexer)
        l.BaseLexer = antlr.NewBaseLexer(input)
        staticData := &amp;VexLexerLexerStaticData
        l.Interpreter = antlr.NewLexerATNSimulator(l, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
        l.channelNames = staticData.ChannelNames
        l.modeNames = staticData.ModeNames
        l.RuleNames = staticData.RuleNames
        l.LiteralNames = staticData.LiteralNames
        l.SymbolicNames = staticData.SymbolicNames
        l.GrammarFileName = "Vex.g4"
        // TODO: l.EOF = antlr.TokenEOF

        return l
}</span>

// VexLexer tokens.
const (
        VexLexerT__0    = 1
        VexLexerT__1    = 2
        VexLexerT__2    = 3
        VexLexerT__3    = 4
        VexLexerSYMBOL  = 5
        VexLexerSTRING  = 6
        VexLexerLETTER  = 7
        VexLexerINTEGER = 8
        VexLexerTRASH   = 9
)
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated from Vex.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // Vex

import (
        "fmt"
        "strconv"
        "sync"

        "github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type VexParser struct {
        *antlr.BaseParser
}

var VexParserStaticData struct {
        once                   sync.Once
        serializedATN          []int32
        LiteralNames           []string
        SymbolicNames          []string
        RuleNames              []string
        PredictionContextCache *antlr.PredictionContextCache
        atn                    *antlr.ATN
        decisionToDFA          []*antlr.DFA
}

func vexParserInit() <span class="cov0" title="0">{
        staticData := &amp;VexParserStaticData
        staticData.LiteralNames = []string{
                "", "'('", "')'", "'['", "']'",
        }
        staticData.SymbolicNames = []string{
                "", "", "", "", "", "SYMBOL", "STRING", "LETTER", "INTEGER", "TRASH",
        }
        staticData.RuleNames = []string{
                "program", "list", "array",
        }
        staticData.PredictionContextCache = antlr.NewPredictionContextCache()
        staticData.serializedATN = []int32{
                4, 1, 9, 36, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 1, 0, 4, 0, 8, 8, 0, 11,
                0, 12, 0, 9, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 19, 8, 1,
                11, 1, 12, 1, 20, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 4, 2, 30, 8,
                2, 11, 2, 12, 2, 31, 1, 2, 1, 2, 1, 2, 0, 0, 3, 0, 2, 4, 0, 0, 41, 0, 7,
                1, 0, 0, 0, 2, 13, 1, 0, 0, 0, 4, 24, 1, 0, 0, 0, 6, 8, 3, 2, 1, 0, 7,
                6, 1, 0, 0, 0, 8, 9, 1, 0, 0, 0, 9, 7, 1, 0, 0, 0, 9, 10, 1, 0, 0, 0, 10,
                11, 1, 0, 0, 0, 11, 12, 5, 0, 0, 1, 12, 1, 1, 0, 0, 0, 13, 18, 5, 1, 0,
                0, 14, 19, 3, 4, 2, 0, 15, 19, 3, 2, 1, 0, 16, 19, 5, 5, 0, 0, 17, 19,
                5, 6, 0, 0, 18, 14, 1, 0, 0, 0, 18, 15, 1, 0, 0, 0, 18, 16, 1, 0, 0, 0,
                18, 17, 1, 0, 0, 0, 19, 20, 1, 0, 0, 0, 20, 18, 1, 0, 0, 0, 20, 21, 1,
                0, 0, 0, 21, 22, 1, 0, 0, 0, 22, 23, 5, 2, 0, 0, 23, 3, 1, 0, 0, 0, 24,
                29, 5, 3, 0, 0, 25, 30, 3, 4, 2, 0, 26, 30, 3, 2, 1, 0, 27, 30, 5, 5, 0,
                0, 28, 30, 5, 6, 0, 0, 29, 25, 1, 0, 0, 0, 29, 26, 1, 0, 0, 0, 29, 27,
                1, 0, 0, 0, 29, 28, 1, 0, 0, 0, 30, 31, 1, 0, 0, 0, 31, 29, 1, 0, 0, 0,
                31, 32, 1, 0, 0, 0, 32, 33, 1, 0, 0, 0, 33, 34, 5, 4, 0, 0, 34, 5, 1, 0,
                0, 0, 5, 9, 18, 20, 29, 31,
        }
        deserializer := antlr.NewATNDeserializer(nil)
        staticData.atn = deserializer.Deserialize(staticData.serializedATN)
        atn := staticData.atn
        staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
        decisionToDFA := staticData.decisionToDFA
        for index, state := range atn.DecisionToState </span><span class="cov0" title="0">{
                decisionToDFA[index] = antlr.NewDFA(state, index)
        }</span>
}

// VexParserInit initializes any static state used to implement VexParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewVexParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func VexParserInit() <span class="cov0" title="0">{
        staticData := &amp;VexParserStaticData
        staticData.once.Do(vexParserInit)
}</span>

// NewVexParser produces a new parser instance for the optional input antlr.TokenStream.
func NewVexParser(input antlr.TokenStream) *VexParser <span class="cov0" title="0">{
        VexParserInit()
        this := new(VexParser)
        this.BaseParser = antlr.NewBaseParser(input)
        staticData := &amp;VexParserStaticData
        this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
        this.RuleNames = staticData.RuleNames
        this.LiteralNames = staticData.LiteralNames
        this.SymbolicNames = staticData.SymbolicNames
        this.GrammarFileName = "Vex.g4"

        return this
}</span>

// VexParser tokens.
const (
        VexParserEOF     = antlr.TokenEOF
        VexParserT__0    = 1
        VexParserT__1    = 2
        VexParserT__2    = 3
        VexParserT__3    = 4
        VexParserSYMBOL  = 5
        VexParserSTRING  = 6
        VexParserLETTER  = 7
        VexParserINTEGER = 8
        VexParserTRASH   = 9
)

// VexParser rules.
const (
        VexParserRULE_program = 0
        VexParserRULE_list    = 1
        VexParserRULE_array   = 2
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        EOF() antlr.TerminalNode
        AllList() []IListContext
        List(i int) IListContext

        // IsProgramContext differentiates from other interfaces.
        IsProgramContext()
}

type ProgramContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext <span class="cov0" title="0">{
        var p = new(ProgramContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_program
        return p
}</span>

func InitEmptyProgramContext(p *ProgramContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_program
}</span>

func (*ProgramContext) IsProgramContext() {<span class="cov0" title="0">}</span>

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext <span class="cov0" title="0">{
        var p = new(ProgramContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = VexParserRULE_program

        return p
}</span>

func (s *ProgramContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ProgramContext) EOF() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserEOF, 0)
}</span>

func (s *ProgramContext) AllList() []IListContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IListContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IListContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ProgramContext) List(i int) IListContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IListContext)</span>
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterProgram(s)
        }</span>
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitProgram(s)
        }</span>
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case VexVisitor:<span class="cov0" title="0">
                return t.VisitProgram(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *VexParser) Program() (localctx IProgramContext) <span class="cov0" title="0">{
        localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 0, VexParserRULE_program)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(7)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

        for ok := true; ok; ok = _la == VexParserT__0 </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(6)
                        p.List()
                }</span>

                <span class="cov0" title="0">p.SetState(9)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov0" title="0">{
                p.SetState(11)
                p.Match(VexParserEOF)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov0" title="0">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov0" title="0">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IListContext is an interface to support dynamic dispatch.
type IListContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        AllArray() []IArrayContext
        Array(i int) IArrayContext
        AllList() []IListContext
        List(i int) IListContext
        AllSYMBOL() []antlr.TerminalNode
        SYMBOL(i int) antlr.TerminalNode
        AllSTRING() []antlr.TerminalNode
        STRING(i int) antlr.TerminalNode

        // IsListContext differentiates from other interfaces.
        IsListContext()
}

type ListContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyListContext() *ListContext <span class="cov0" title="0">{
        var p = new(ListContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_list
        return p
}</span>

func InitEmptyListContext(p *ListContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_list
}</span>

func (*ListContext) IsListContext() {<span class="cov0" title="0">}</span>

func NewListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListContext <span class="cov0" title="0">{
        var p = new(ListContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = VexParserRULE_list

        return p
}</span>

func (s *ListContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ListContext) AllArray() []IArrayContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IArrayContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IArrayContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ListContext) Array(i int) IArrayContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IArrayContext)</span>
}

func (s *ListContext) AllList() []IListContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IListContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IListContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ListContext) List(i int) IListContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IListContext)</span>
}

func (s *ListContext) AllSYMBOL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(VexParserSYMBOL)
}</span>

func (s *ListContext) SYMBOL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserSYMBOL, i)
}</span>

func (s *ListContext) AllSTRING() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(VexParserSTRING)
}</span>

func (s *ListContext) STRING(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserSTRING, i)
}</span>

func (s *ListContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ListContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterList(s)
        }</span>
}

func (s *ListContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitList(s)
        }</span>
}

func (s *ListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case VexVisitor:<span class="cov0" title="0">
                return t.VisitList(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *VexParser) List() (localctx IListContext) <span class="cov0" title="0">{
        localctx = NewListContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 2, VexParserRULE_list)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(13)
                p.Match(VexParserT__0)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov0" title="0">p.SetState(18)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

        for ok := true; ok; ok = ((int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;106) != 0) </span><span class="cov0" title="0">{
                p.SetState(18)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }

                <span class="cov0" title="0">switch p.GetTokenStream().LA(1) </span>{
                case VexParserT__2:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(14)
                                p.Array()
                        }</span>

                case VexParserT__0:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(15)
                                p.List()
                        }</span>

                case VexParserSYMBOL:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(16)
                                p.Match(VexParserSYMBOL)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                case VexParserSTRING:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(17)
                                p.Match(VexParserSTRING)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                default:<span class="cov0" title="0">
                        p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                        goto errorExit</span>
                }

                <span class="cov0" title="0">p.SetState(20)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov0" title="0">{
                p.SetState(22)
                p.Match(VexParserT__1)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov0" title="0">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov0" title="0">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IArrayContext is an interface to support dynamic dispatch.
type IArrayContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        AllArray() []IArrayContext
        Array(i int) IArrayContext
        AllList() []IListContext
        List(i int) IListContext
        AllSYMBOL() []antlr.TerminalNode
        SYMBOL(i int) antlr.TerminalNode
        AllSTRING() []antlr.TerminalNode
        STRING(i int) antlr.TerminalNode

        // IsArrayContext differentiates from other interfaces.
        IsArrayContext()
}

type ArrayContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyArrayContext() *ArrayContext <span class="cov0" title="0">{
        var p = new(ArrayContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_array
        return p
}</span>

func InitEmptyArrayContext(p *ArrayContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_array
}</span>

func (*ArrayContext) IsArrayContext() {<span class="cov0" title="0">}</span>

func NewArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayContext <span class="cov0" title="0">{
        var p = new(ArrayContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = VexParserRULE_array

        return p
}</span>

func (s *ArrayContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ArrayContext) AllArray() []IArrayContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IArrayContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IArrayContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ArrayContext) Array(i int) IArrayContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IArrayContext)</span>
}

func (s *ArrayContext) AllList() []IListContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IListContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IListContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ArrayContext) List(i int) IListContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IListContext)</span>
}

func (s *ArrayContext) AllSYMBOL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(VexParserSYMBOL)
}</span>

func (s *ArrayContext) SYMBOL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserSYMBOL, i)
}</span>

func (s *ArrayContext) AllSTRING() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(VexParserSTRING)
}</span>

func (s *ArrayContext) STRING(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserSTRING, i)
}</span>

func (s *ArrayContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ArrayContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterArray(s)
        }</span>
}

func (s *ArrayContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitArray(s)
        }</span>
}

func (s *ArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case VexVisitor:<span class="cov0" title="0">
                return t.VisitArray(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *VexParser) Array() (localctx IArrayContext) <span class="cov0" title="0">{
        localctx = NewArrayContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 4, VexParserRULE_array)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(24)
                p.Match(VexParserT__2)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov0" title="0">p.SetState(29)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

        for ok := true; ok; ok = ((int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;106) != 0) </span><span class="cov0" title="0">{
                p.SetState(29)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }

                <span class="cov0" title="0">switch p.GetTokenStream().LA(1) </span>{
                case VexParserT__2:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(25)
                                p.Array()
                        }</span>

                case VexParserT__0:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(26)
                                p.List()
                        }</span>

                case VexParserSYMBOL:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(27)
                                p.Match(VexParserSYMBOL)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                case VexParserSTRING:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(28)
                                p.Match(VexParserSTRING)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                default:<span class="cov0" title="0">
                        p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                        goto errorExit</span>
                }

                <span class="cov0" title="0">p.SetState(31)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov0" title="0">{
                p.SetState(33)
                p.Match(VexParserT__3)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov0" title="0">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov0" title="0">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package transpiler provides semantic analysis with type checking
package transpiler

import (
        "fmt"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// SemanticVisitor implements semantic analysis with type checking
type SemanticVisitor struct {
        parser.BaseVexVisitor
        codeGen          *CodeGenerator
        macroRegistry    *MacroRegistry
        namespaceManager *NamespaceManager
        typeChecker      *TypeChecker
        typeInference    *TypeInference
        typeUtils        *TypeUtils
        errors           []string
        currentNode      antlr.Tree // Track current node for error reporting
}

// NewSemanticVisitor creates a new semantic visitor with type system integration
func NewSemanticVisitor() *SemanticVisitor <span class="cov0" title="0">{
        namespaceManager := NewNamespaceManager()
        typeChecker := NewTypeChecker(namespaceManager)

        return &amp;SemanticVisitor{
                codeGen:          NewCodeGenerator(),
                macroRegistry:    NewMacroRegistry(),
                namespaceManager: namespaceManager,
                typeChecker:      typeChecker,
                typeInference:    NewTypeInference(namespaceManager),
                typeUtils:        &amp;TypeUtils{},
                errors:           make([]string, 0, 16),
        }
}</span>

// AnalyzeProgram performs complete semantic analysis on a program
func (sv *SemanticVisitor) AnalyzeProgram(programCtx *parser.ProgramContext) error <span class="cov0" title="0">{
        sv.errors = sv.errors[:0] // Reset errors

        // Step 1: Perform type checking
        typeErrors, err := sv.typeChecker.CheckProgram(programCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("type checking failed: %w", err)
        }</span>

        // Convert type errors to string errors
        <span class="cov0" title="0">for _, typeErr := range typeErrors </span><span class="cov0" title="0">{
                sv.errors = append(sv.errors, typeErr.String())
        }</span>

        // Step 2: If type checking passed, generate code with type information
        <span class="cov0" title="0">if len(typeErrors) == 0 </span><span class="cov0" title="0">{
                programCtx.Accept(sv)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetGeneratedCode returns the generated Go code
func (sv *SemanticVisitor) GetGeneratedCode() string <span class="cov0" title="0">{
        return sv.codeGen.GetCode()
}</span>

// GetCodeGenerator returns the code generator
func (sv *SemanticVisitor) GetCodeGenerator() *CodeGenerator <span class="cov0" title="0">{
        return sv.codeGen
}</span>

// GetErrors returns all semantic analysis errors
func (sv *SemanticVisitor) GetErrors() []string <span class="cov0" title="0">{
        return sv.errors
}</span>

// HasErrors returns true if there are semantic errors
func (sv *SemanticVisitor) HasErrors() bool <span class="cov0" title="0">{
        return len(sv.errors) &gt; 0
}</span>

// GetNamespaceManager returns the namespace manager
func (sv *SemanticVisitor) GetNamespaceManager() *NamespaceManager <span class="cov0" title="0">{
        return sv.namespaceManager
}</span>

// VisitProgram visits the root node with semantic analysis
func (sv *SemanticVisitor) VisitProgram(ctx *parser.ProgramContext) interface{} <span class="cov0" title="0">{
        // Visit all child lists with type information
        for _, listCtx := range ctx.AllList() </span><span class="cov0" title="0">{
                sv.visitWithTypeInfo(listCtx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// visitWithTypeInfo visits a node and infers its type
func (sv *SemanticVisitor) visitWithTypeInfo(node antlr.Tree) VexType <span class="cov0" title="0">{
        // Infer the type of the node
        inferredType, err := sv.typeInference.InferTypes(node)
        if err != nil </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Type inference failed: %s", err.Error()))
                inferredType = NewUnknownType(0)
        }</span>

        // Visit the node for code generation
        <span class="cov0" title="0">switch ctx := node.(type) </span>{
        case parser.IListContext:<span class="cov0" title="0">
                sv.VisitList(ctx.(*parser.ListContext))</span>
        case parser.IArrayContext:<span class="cov0" title="0">
                sv.VisitArray(ctx.(*parser.ArrayContext))</span>
        case *antlr.TerminalNodeImpl:<span class="cov0" title="0"></span>
                // Terminal nodes don't need visiting
        }

        <span class="cov0" title="0">return inferredType</span>
}

// VisitList visits a list expression with type-aware code generation
func (sv *SemanticVisitor) VisitList(ctx *parser.ListContext) interface{} <span class="cov0" title="0">{
        // Set current node for error reporting
        oldNode := sv.currentNode
        sv.currentNode = ctx
        defer func() </span><span class="cov0" title="0">{ sv.currentNode = oldNode }</span>()

        <span class="cov0" title="0">children := ctx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{ // '(' ... ')'
                return nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        if len(content) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the first element to determine the operation
        <span class="cov0" title="0">firstChild := content[0]
        var firstElement string
        if symbolCtx, ok := firstChild.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                firstElement = symbolCtx.GetText()
        }</span>

        <span class="cov0" title="0">switch firstElement </span>{
        case "def":<span class="cov0" title="0">
                sv.handleTypedDefinition(content)</span>
        case "import":<span class="cov0" title="0">
                sv.handleImport(content[1:])</span>
        case "macro":<span class="cov0" title="0">
                sv.handleMacroDefinition(content[1:])</span>
        case "fn":<span class="cov0" title="0">
                sv.handleTypedFunctionLiteral(content[1:])</span>
        case "+", "-", "*", "/":<span class="cov0" title="0">
                sv.handleTypedArithmetic(firstElement, content[1:])</span>
        case "if":<span class="cov0" title="0">
                sv.handleTypedConditional(content[1:])</span>
        default:<span class="cov0" title="0">
                // Check if it's a registered macro
                if sv.macroRegistry.IsMacro(firstElement) </span><span class="cov0" title="0">{
                        sv.handleMacroCall(firstElement, content[1:])
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(firstElement, ".") </span><span class="cov0" title="0">{
                        sv.handleTypedMethodCall(firstElement, content[1:])
                }</span> else<span class="cov0" title="0"> if strings.Contains(firstElement, "/") </span><span class="cov0" title="0">{
                        sv.handleTypedSlashNotationCall(firstElement, content[1:])
                }</span> else<span class="cov0" title="0"> {
                        sv.handleTypedFunctionCall(firstElement, content[1:])
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// VisitArray visits an array literal with type checking
func (sv *SemanticVisitor) VisitArray(ctx *parser.ArrayContext) interface{} <span class="cov0" title="0">{
        // Infer array type and validate homogeneity
        arrayType, err := sv.typeInference.InferTypes(ctx)
        if err != nil </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Array type inference failed: %s", err.Error()))
        }</span>

        // Generate Go slice code with proper type
        <span class="cov0" title="0">if listType, ok := arrayType.(*ListType); ok </span><span class="cov0" title="0">{
                sv.codeGen.EmitTypedArray(listType)
        }</span> else<span class="cov0" title="0"> {
                sv.codeGen.EmitArray() // Fallback to generic array
        }</span>

        <span class="cov0" title="0">return sv.VisitChildren(ctx)</span>
}

// handleTypedDefinition handles variable definitions with type information
func (sv *SemanticVisitor) handleTypedDefinition(content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                sv.addError("Invalid definition: expected (def name value)")
                return
        }</span>

        // Get variable name
        <span class="cov0" title="0">var varName string
        if symbolCtx, ok := content[1].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                varName = symbolCtx.GetText()
        }</span> else<span class="cov0" title="0"> {
                sv.addError("Variable name must be a symbol")
                return
        }</span>

        // Infer the type of the value
        <span class="cov0" title="0">valueType := sv.visitWithTypeInfo(content[2])

        // Generate typed Go code
        value := sv.evaluateExpressionWithType(content[2], valueType)
        sv.codeGen.EmitTypedVariableDefinition(varName, value, valueType)

        // Update namespace binding
        sv.namespaceManager.GetCurrentNamespace().Bind(varName, valueType, false)</span>
}

// handleTypedFunctionLiteral handles function literals with type inference
func (sv *SemanticVisitor) handleTypedFunctionLiteral(content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 2 </span><span class="cov0" title="0">{
                sv.addError("Invalid function literal: expected (fn [params] body)")
                return
        }</span>

        // Parse parameters with type inference
        <span class="cov0" title="0">paramTypes, paramNames, err := sv.parseTypedParameters(content[0])
        if err != nil </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Parameter parsing failed: %s", err.Error()))
                return
        }</span>

        // Infer return type from body
        <span class="cov0" title="0">returnType := sv.visitWithTypeInfo(content[1])

        // Generate Go function literal
        sv.codeGen.EmitTypedFunctionLiteral(paramNames, paramTypes, returnType)</span>
}

// handleTypedArithmetic handles arithmetic with type checking
func (sv *SemanticVisitor) handleTypedArithmetic(operator string, operands []antlr.Tree) <span class="cov0" title="0">{
        if len(operands) &lt; 2 </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Arithmetic operation %s requires at least 2 operands", operator))
                return
        }</span>

        // Infer types of all operands
        <span class="cov0" title="0">var operandTypes []VexType
        var operandValues []string

        for i, operand := range operands </span><span class="cov0" title="0">{
                operandType := sv.visitWithTypeInfo(operand)
                operandTypes = append(operandTypes, operandType)

                // Validate numeric type
                if !sv.isNumericType(operandType) </span><span class="cov0" title="0">{
                        sv.addError(fmt.Sprintf("Arithmetic operand %d must be numeric, got %s", i, operandType.String()))
                }</span>

                <span class="cov0" title="0">operandValues = append(operandValues, sv.evaluateExpressionWithType(operand, operandType))</span>
        }

        // Determine result type (promote int to float if needed)
        <span class="cov0" title="0">resultType := sv.determineArithmeticResultType(operandTypes)

        // Generate typed arithmetic expression
        sv.codeGen.EmitTypedArithmeticExpression(operator, operandValues, resultType)</span>
}

// handleTypedConditional handles if expressions with type checking
func (sv *SemanticVisitor) handleTypedConditional(content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                sv.addError("Conditional requires condition, then-branch, and else-branch")
                return
        }</span>

        // Check condition type
        <span class="cov0" title="0">conditionType := sv.visitWithTypeInfo(content[0])
        if !conditionType.Equals(BoolType) </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Condition must be boolean, got %s", conditionType.String()))
        }</span>

        // Check branch types
        <span class="cov0" title="0">thenType := sv.visitWithTypeInfo(content[1])
        elseType := sv.visitWithTypeInfo(content[2])

        if !thenType.IsAssignableFrom(elseType) </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Conditional branch type mismatch: then=%s, else=%s",
                        thenType.String(), elseType.String()))
        }</span>

        // Generate typed conditional
        <span class="cov0" title="0">condition := sv.evaluateExpressionWithType(content[0], conditionType)
        thenBranch := sv.evaluateExpressionWithType(content[1], thenType)
        elseBranch := sv.evaluateExpressionWithType(content[2], elseType)

        sv.codeGen.EmitTypedConditional(condition, thenBranch, elseBranch, thenType)</span>
}

// handleTypedMethodCall handles method calls with type checking
func (sv *SemanticVisitor) handleTypedMethodCall(methodName string, content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 1 </span><span class="cov0" title="0">{
                sv.addError("Invalid method call: expected receiver")
                return
        }</span>

        // Infer receiver type
        <span class="cov0" title="0">receiverType := sv.visitWithTypeInfo(content[0])
        receiver := sv.evaluateExpressionWithType(content[0], receiverType)

        // Infer argument types
        var args []string
        var argTypes []VexType
        for _, arg := range content[1:] </span><span class="cov0" title="0">{
                argType := sv.visitWithTypeInfo(arg)
                argTypes = append(argTypes, argType)
                args = append(args, sv.evaluateExpressionWithType(arg, argType))
        }</span>

        // Generate typed method call
        <span class="cov0" title="0">sv.codeGen.EmitTypedMethodCall(receiver, methodName[1:], args, receiverType, argTypes)</span>
}

// handleTypedSlashNotationCall handles package function calls with type checking
func (sv *SemanticVisitor) handleTypedSlashNotationCall(functionName string, content []antlr.Tree) <span class="cov0" title="0">{
        // Parse package/function
        parts := strings.SplitN(functionName, "/", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Invalid slash notation: %s", functionName))
                return
        }</span>

        <span class="cov0" title="0">packageName, funcName := parts[0], parts[1]

        // Infer argument types
        var args []string
        var argTypes []VexType
        for _, arg := range content </span><span class="cov0" title="0">{
                argType := sv.visitWithTypeInfo(arg)
                argTypes = append(argTypes, argType)
                args = append(args, sv.evaluateExpressionWithType(arg, argType))
        }</span>

        // Generate typed package function call
        <span class="cov0" title="0">sv.codeGen.EmitTypedSlashNotationCall(packageName, funcName, args, argTypes)</span>
}

// handleTypedFunctionCall handles regular function calls with type checking
func (sv *SemanticVisitor) handleTypedFunctionCall(functionName string, content []antlr.Tree) <span class="cov0" title="0">{
        // Resolve function binding
        binding, exists := sv.namespaceManager.GetCurrentNamespace().Resolve(functionName)
        if !exists </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Undefined function: %s", functionName))
                return
        }</span>

        <span class="cov0" title="0">if !binding.IsFunction </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Symbol %s is not a function", functionName))
                return
        }</span>

        <span class="cov0" title="0">funcType, ok := binding.Type.(*FunctionType)
        if !ok </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Invalid function type for %s", functionName))
                return
        }</span>

        // Check argument count
        <span class="cov0" title="0">if len(content) != len(funcType.Parameters) </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Function %s expects %d arguments, got %d",
                        functionName, len(funcType.Parameters), len(content)))
                return
        }</span>

        // Infer and validate argument types
        <span class="cov0" title="0">var args []string
        for i, arg := range content </span><span class="cov0" title="0">{
                argType := sv.visitWithTypeInfo(arg)
                expectedType := funcType.Parameters[i]

                if !expectedType.IsAssignableFrom(argType) </span><span class="cov0" title="0">{
                        sv.addError(fmt.Sprintf("Argument %d to %s: expected %s, got %s",
                                i, functionName, expectedType.String(), argType.String()))
                }</span>

                <span class="cov0" title="0">args = append(args, sv.evaluateExpressionWithType(arg, argType))</span>
        }

        // Generate typed function call
        <span class="cov0" title="0">sv.codeGen.EmitTypedFunctionCall(functionName, args, funcType.ReturnType)</span>
}

// Helper methods (reusing some from original AST visitor)

// handleImport handles import statements (unchanged)
func (sv *SemanticVisitor) handleImport(content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 1 </span><span class="cov0" title="0">{
                sv.addError("Invalid import: expected package path")
                return
        }</span>

        <span class="cov0" title="0">importPath := sv.evaluateExpression(content[0])
        sv.codeGen.EmitImport(importPath)</span>
}

// handleMacroDefinition handles macro definitions like (macro name [params] body)
func (sv *SemanticVisitor) handleMacroDefinition(content []antlr.Tree) <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                sv.addError("Invalid macro definition: expected (macro name [params] body)")
                return
        }</span>

        // Get macro name
        <span class="cov0" title="0">var macroName string
        if symbolCtx, ok := content[0].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                macroName = symbolCtx.GetText()
        }</span> else<span class="cov0" title="0"> {
                sv.addError("Macro name must be a symbol")
                return
        }</span>

        // Get parameters from array
        <span class="cov0" title="0">paramList := content[1]
        var params []string
        if arrayCtx, ok := paramList.(*parser.ArrayContext); ok </span><span class="cov0" title="0">{
                children := arrayCtx.GetChildren()
                // Skip [ and ] brackets
                for i := 1; i &lt; len(children)-1; i++ </span><span class="cov0" title="0">{
                        if terminalNode, ok := children[i].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                                params = append(params, terminalNode.GetText())
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                sv.addError("Macro parameters must be in an array")
                return
        }</span>

        // Macro body template (remaining content)
        <span class="cov0" title="0">if len(content) &gt; 2 </span><span class="cov0" title="0">{
                template := content[2] // For now, just take the first body element
                sv.macroRegistry.RegisterMacro(macroName, params, template)

                // Don't generate any Go code for macro definitions
                sv.codeGen.writeIndented("// Registered macro: " + macroName + "\n")
        }</span>
}

// handleMacroCall handles macro calls (unchanged)
func (sv *SemanticVisitor) handleMacroCall(macroName string, content []antlr.Tree) <span class="cov0" title="0">{
        expanded, err := sv.macroRegistry.ExpandMacro(macroName, content)
        if err != nil </span><span class="cov0" title="0">{
                sv.addError(fmt.Sprintf("Macro expansion failed: %s", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">sv.codeGen.writeIndented("// Macro expansion: " + macroName + "\n")
        sv.codeGen.writeIndented(expanded + "\n")</span>
}

// parseTypedParameters parses function parameters with type inference
func (sv *SemanticVisitor) parseTypedParameters(paramNode antlr.Tree) ([]VexType, []string, error) <span class="cov0" title="0">{
        arrayCtx, ok := paramNode.(*parser.ArrayContext)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("parameters must be an array")
        }</span>

        <span class="cov0" title="0">children := arrayCtx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{ // '[' ... ']'
                return []VexType{}, []string{}, nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        var paramTypes []VexType
        var paramNames []string

        for _, paramNode := range content </span><span class="cov0" title="0">{
                if symbolCtx, ok := paramNode.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                        paramName := symbolCtx.GetText()
                        paramNames = append(paramNames, paramName)
                        // For now, use unknown type (will be inferred from usage)
                        paramTypes = append(paramTypes, NewUnknownType(sv.typeInference.getNextUnknownID()))
                }</span>
        }

        <span class="cov0" title="0">return paramTypes, paramNames, nil</span>
}

// evaluateExpressionWithType evaluates an expression with type information
func (sv *SemanticVisitor) evaluateExpressionWithType(node antlr.Tree, expectedType VexType) string <span class="cov0" title="0">{
        // Use type information to generate more specific Go code
        switch ctx := node.(type) </span>{
        case *antlr.TerminalNodeImpl:<span class="cov0" title="0">
                text := ctx.GetText()
                return sv.formatLiteralWithType(text, expectedType)</span>
        default:<span class="cov0" title="0">
                // Fallback to basic evaluation
                return sv.evaluateExpression(node)</span>
        }
}

// formatLiteralWithType formats literals with type information
func (sv *SemanticVisitor) formatLiteralWithType(literal string, vexType VexType) string <span class="cov0" title="0">{
        // Add type-specific formatting
        if vexType.Equals(IntType) &amp;&amp; !strings.Contains(literal, ".") </span><span class="cov0" title="0">{
                return literal // Ensure integer literals stay as integers
        }</span>
        <span class="cov0" title="0">if vexType.Equals(FloatType) &amp;&amp; !strings.Contains(literal, ".") </span><span class="cov0" title="0">{
                return literal + ".0" // Convert integers to floats when needed
        }</span>
        <span class="cov0" title="0">return literal</span>
}

// evaluateExpression basic expression evaluation (fallback)
func (sv *SemanticVisitor) evaluateExpression(node antlr.Tree) string <span class="cov0" title="0">{
        switch ctx := node.(type) </span>{
        case *antlr.TerminalNodeImpl:<span class="cov0" title="0">
                return ctx.GetText()</span>
        default:<span class="cov0" title="0">
                return "/* unknown */"</span>
        }
}

// isNumericType checks if a type is numeric
func (sv *SemanticVisitor) isNumericType(vexType VexType) bool <span class="cov0" title="0">{
        return vexType.Equals(IntType) || vexType.Equals(FloatType)
}</span>

// determineArithmeticResultType determines the result type of arithmetic operations
func (sv *SemanticVisitor) determineArithmeticResultType(operandTypes []VexType) VexType <span class="cov0" title="0">{
        hasFloat := false
        for _, t := range operandTypes </span><span class="cov0" title="0">{
                if t.Equals(FloatType) </span><span class="cov0" title="0">{
                        hasFloat = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if hasFloat </span><span class="cov0" title="0">{
                return FloatType
        }</span>
        <span class="cov0" title="0">return IntType</span>
}

// addError adds an error to the error list
func (sv *SemanticVisitor) addError(message string) <span class="cov0" title="0">{
        sv.addErrorWithNode(message, sv.currentNode)
}</span>

// addErrorWithNode adds an error with specific node position information
func (sv *SemanticVisitor) addErrorWithNode(message string, node antlr.Tree) <span class="cov0" title="0">{
        line, column := sv.getNodePosition(node)
        if line &gt; 0 </span><span class="cov0" title="0">{
                formattedError := fmt.Sprintf("line %d:%d: %s", line, column, message)
                sv.errors = append(sv.errors, formattedError)
        }</span> else<span class="cov0" title="0"> {
                sv.errors = append(sv.errors, message)
        }</span>
}

// getNodePosition extracts line and column information from an AST node
func (sv *SemanticVisitor) getNodePosition(node antlr.Tree) (int, int) <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        <span class="cov0" title="0">switch ctx := node.(type) </span>{
        case *antlr.TerminalNodeImpl:<span class="cov0" title="0">
                token := ctx.GetSymbol()
                return token.GetLine(), token.GetColumn()</span>
        case *parser.ListContext:<span class="cov0" title="0">
                if ctx.GetStart() != nil </span><span class="cov0" title="0">{
                        return ctx.GetStart().GetLine(), ctx.GetStart().GetColumn()
                }</span>
        case *parser.ArrayContext:<span class="cov0" title="0">
                if ctx.GetStart() != nil </span><span class="cov0" title="0">{
                        return ctx.GetStart().GetLine(), ctx.GetStart().GetColumn()
                }</span>
        case *parser.ProgramContext:<span class="cov0" title="0">
                if ctx.GetStart() != nil </span><span class="cov0" title="0">{
                        return ctx.GetStart().GetLine(), ctx.GetStart().GetColumn()
                }</span>
        }
        <span class="cov0" title="0">return 0, 0</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package transpiler provides the symbol system for Vex
package transpiler

import (
        "fmt"
        "sync"
)

// Symbol represents an interned symbol in Vex
type Symbol struct {
        Name string
        ID   int
}

// String returns the string representation of the symbol
func (s *Symbol) String() string <span class="cov0" title="0">{
        return s.Name
}</span>

// Equals checks if two symbols are equal (by ID for interned symbols)
func (s *Symbol) Equals(other *Symbol) bool <span class="cov0" title="0">{
        return s.ID == other.ID
}</span>

// SymbolTable manages symbol interning and lookup
type SymbolTable struct {
        mu          sync.RWMutex
        symbols     map[string]*Symbol // name -&gt; symbol mapping
        symbolsByID map[int]*Symbol    // ID -&gt; symbol mapping
        nextID      int
}

// NewSymbolTable creates a new symbol table
func NewSymbolTable() *SymbolTable <span class="cov0" title="0">{
        return &amp;SymbolTable{
                symbols:     make(map[string]*Symbol, 256), // Pre-allocate for common symbols
                symbolsByID: make(map[int]*Symbol, 256),
                nextID:      1, // Start from 1, reserve 0 for special cases
        }
}</span>

// Intern interns a symbol name, returning an existing symbol if it exists
func (st *SymbolTable) Intern(name string) *Symbol <span class="cov0" title="0">{
        st.mu.RLock()
        if existing, exists := st.symbols[name]; exists </span><span class="cov0" title="0">{
                st.mu.RUnlock()
                return existing
        }</span>
        <span class="cov0" title="0">st.mu.RUnlock()

        st.mu.Lock()
        defer st.mu.Unlock()

        // Double-check after acquiring write lock
        if existing, exists := st.symbols[name]; exists </span><span class="cov0" title="0">{
                return existing
        }</span>

        // Create new symbol
        <span class="cov0" title="0">symbol := &amp;Symbol{
                Name: name,
                ID:   st.nextID,
        }
        st.nextID++

        st.symbols[name] = symbol
        st.symbolsByID[symbol.ID] = symbol

        return symbol</span>
}

// Lookup looks up a symbol by name without interning
func (st *SymbolTable) Lookup(name string) (*Symbol, bool) <span class="cov0" title="0">{
        st.mu.RLock()
        defer st.mu.RUnlock()

        symbol, exists := st.symbols[name]
        return symbol, exists
}</span>

// GetByID retrieves a symbol by its ID
func (st *SymbolTable) GetByID(id int) (*Symbol, bool) <span class="cov0" title="0">{
        st.mu.RLock()
        defer st.mu.RUnlock()

        symbol, exists := st.symbolsByID[id]
        return symbol, exists
}</span>

// Size returns the number of interned symbols
func (st *SymbolTable) Size() int <span class="cov0" title="0">{
        st.mu.RLock()
        defer st.mu.RUnlock()
        return len(st.symbols)
}</span>

// AllSymbols returns all interned symbols (for debugging/introspection)
func (st *SymbolTable) AllSymbols() []*Symbol <span class="cov0" title="0">{
        st.mu.RLock()
        defer st.mu.RUnlock()

        symbols := make([]*Symbol, 0, len(st.symbols))
        for _, symbol := range st.symbols </span><span class="cov0" title="0">{
                symbols = append(symbols, symbol)
        }</span>
        <span class="cov0" title="0">return symbols</span>
}

// Namespace represents a namespace for symbol resolution
type Namespace struct {
        Name        string
        Parent      *Namespace
        bindings    map[string]*Binding
        symbolTable *SymbolTable
        mu          sync.RWMutex
}

// Binding represents a binding of a symbol to a type and value information
type Binding struct {
        Symbol     *Symbol
        Type       VexType
        IsMutable  bool
        IsFunction bool
        Namespace  *Namespace
}

// NewNamespace creates a new namespace
func NewNamespace(name string, parent *Namespace, symbolTable *SymbolTable) *Namespace <span class="cov0" title="0">{
        return &amp;Namespace{
                Name:        name,
                Parent:      parent,
                bindings:    make(map[string]*Binding, 64), // Pre-allocate for common bindings
                symbolTable: symbolTable,
        }
}</span>

// Bind binds a symbol to a type in this namespace
func (ns *Namespace) Bind(name string, vexType VexType, isMutable bool) *Binding <span class="cov0" title="0">{
        ns.mu.Lock()
        defer ns.mu.Unlock()

        symbol := ns.symbolTable.Intern(name)
        binding := &amp;Binding{
                Symbol:    symbol,
                Type:      vexType,
                IsMutable: isMutable,
                Namespace: ns,
        }

        ns.bindings[name] = binding
        return binding
}</span>

// BindFunction binds a function symbol to a function type
func (ns *Namespace) BindFunction(name string, funcType *FunctionType) *Binding <span class="cov0" title="0">{
        ns.mu.Lock()
        defer ns.mu.Unlock()

        symbol := ns.symbolTable.Intern(name)
        binding := &amp;Binding{
                Symbol:     symbol,
                Type:       funcType,
                IsMutable:  false, // Functions are immutable
                IsFunction: true,
                Namespace:  ns,
        }

        ns.bindings[name] = binding
        return binding
}</span>

// Resolve resolves a symbol in this namespace, walking up the parent chain
func (ns *Namespace) Resolve(name string) (*Binding, bool) <span class="cov0" title="0">{
        current := ns
        for current != nil </span><span class="cov0" title="0">{
                current.mu.RLock()
                if binding, exists := current.bindings[name]; exists </span><span class="cov0" title="0">{
                        current.mu.RUnlock()
                        return binding, true
                }</span>
                <span class="cov0" title="0">current.mu.RUnlock()
                current = current.Parent</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// LocalResolve resolves a symbol only in this namespace (not parent)
func (ns *Namespace) LocalResolve(name string) (*Binding, bool) <span class="cov0" title="0">{
        ns.mu.RLock()
        defer ns.mu.RUnlock()

        binding, exists := ns.bindings[name]
        return binding, exists
}</span>

// IsBound checks if a symbol is bound in this namespace or parents
func (ns *Namespace) IsBound(name string) bool <span class="cov0" title="0">{
        _, exists := ns.Resolve(name)
        return exists
}</span>

// GetLocalBindings returns all bindings in this namespace (not parents)
func (ns *Namespace) GetLocalBindings() map[string]*Binding <span class="cov0" title="0">{
        ns.mu.RLock()
        defer ns.mu.RUnlock()

        // Return a copy to avoid concurrent access issues
        result := make(map[string]*Binding, len(ns.bindings))
        for name, binding := range ns.bindings </span><span class="cov0" title="0">{
                result[name] = binding
        }</span>
        <span class="cov0" title="0">return result</span>
}

// NamespaceManager manages multiple namespaces and provides namespace-qualified resolution
type NamespaceManager struct {
        globalSymbolTable *SymbolTable
        namespaces        map[string]*Namespace
        currentNamespace  *Namespace
        mu                sync.RWMutex
}

// NewNamespaceManager creates a new namespace manager with a global namespace
func NewNamespaceManager() *NamespaceManager <span class="cov0" title="0">{
        symbolTable := NewSymbolTable()
        globalNS := NewNamespace("global", nil, symbolTable)

        nm := &amp;NamespaceManager{
                globalSymbolTable: symbolTable,
                namespaces:        make(map[string]*Namespace, 16),
                currentNamespace:  globalNS,
        }

        nm.namespaces["global"] = globalNS

        // Bind built-in symbols and types
        nm.bindBuiltins(globalNS)

        return nm
}</span>

// bindBuiltins binds built-in symbols and functions to the global namespace
func (nm *NamespaceManager) bindBuiltins(globalNS *Namespace) <span class="cov0" title="0">{
        // Built-in type symbols
        globalNS.Bind("int", IntType, false)
        globalNS.Bind("float", FloatType, false)
        globalNS.Bind("string", StringType, false)
        globalNS.Bind("bool", BoolType, false)
        globalNS.Bind("symbol", SymbolType, false)

        // Built-in functions (arithmetic operators)
        globalNS.BindFunction("+", NewFunctionType([]VexType{IntType, IntType}, IntType))
        globalNS.BindFunction("-", NewFunctionType([]VexType{IntType, IntType}, IntType))
        globalNS.BindFunction("*", NewFunctionType([]VexType{IntType, IntType}, IntType))
        globalNS.BindFunction("/", NewFunctionType([]VexType{IntType, IntType}, IntType))

        // Built-in boolean values
        globalNS.Bind("true", BoolType, false)
        globalNS.Bind("false", BoolType, false)
}</span>

// CreateNamespace creates a new namespace
func (nm *NamespaceManager) CreateNamespace(name string, parent *Namespace) *Namespace <span class="cov0" title="0">{
        nm.mu.Lock()
        defer nm.mu.Unlock()

        if parent == nil </span><span class="cov0" title="0">{
                parent = nm.namespaces["global"]
        }</span>

        <span class="cov0" title="0">ns := NewNamespace(name, parent, nm.globalSymbolTable)
        nm.namespaces[name] = ns
        return ns</span>
}

// GetNamespace retrieves a namespace by name
func (nm *NamespaceManager) GetNamespace(name string) (*Namespace, bool) <span class="cov0" title="0">{
        nm.mu.RLock()
        defer nm.mu.RUnlock()

        ns, exists := nm.namespaces[name]
        return ns, exists
}</span>

// SetCurrentNamespace sets the current working namespace
func (nm *NamespaceManager) SetCurrentNamespace(name string) error <span class="cov0" title="0">{
        nm.mu.RLock()
        defer nm.mu.RUnlock()

        ns, exists := nm.namespaces[name]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("namespace %s not found", name)
        }</span>

        <span class="cov0" title="0">nm.currentNamespace = ns
        return nil</span>
}

// GetCurrentNamespace returns the current working namespace
func (nm *NamespaceManager) GetCurrentNamespace() *Namespace <span class="cov0" title="0">{
        nm.mu.RLock()
        defer nm.mu.RUnlock()
        return nm.currentNamespace
}</span>

// ResolveQualified resolves a qualified symbol (namespace/symbol)
func (nm *NamespaceManager) ResolveQualified(qualifiedName string) (*Binding, error) <span class="cov0" title="0">{
        nm.mu.RLock()
        defer nm.mu.RUnlock()

        // Parse qualified name (e.g., "http/Server" -&gt; namespace="http", name="Server")
        parts := parseQualifiedName(qualifiedName)
        if len(parts) == 1 </span><span class="cov0" title="0">{
                // Unqualified name, resolve in current namespace
                binding, exists := nm.currentNamespace.Resolve(parts[0])
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("symbol %s not found", parts[0])
                }</span>
                <span class="cov0" title="0">return binding, nil</span>
        }

        <span class="cov0" title="0">if len(parts) == 2 </span><span class="cov0" title="0">{
                // Qualified name
                nsName, symbolName := parts[0], parts[1]
                ns, exists := nm.namespaces[nsName]
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("namespace %s not found", nsName)
                }</span>

                <span class="cov0" title="0">binding, exists := ns.Resolve(symbolName)
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("symbol %s not found in namespace %s", symbolName, nsName)
                }</span>
                <span class="cov0" title="0">return binding, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid qualified name: %s", qualifiedName)</span>
}

// parseQualifiedName parses a qualified name into its components
func parseQualifiedName(qualified string) []string <span class="cov0" title="0">{
        // Simple implementation: split on '/'
        // Could be enhanced for more complex namespace resolution
        result := make([]string, 0, 2)
        slashIndex := -1

        for i, r := range qualified </span><span class="cov0" title="0">{
                if r == '/' </span><span class="cov0" title="0">{
                        slashIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if slashIndex == -1 </span><span class="cov0" title="0">{
                result = append(result, qualified)
        }</span> else<span class="cov0" title="0"> {
                result = append(result, qualified[:slashIndex])
                result = append(result, qualified[slashIndex+1:])
        }</span>

        <span class="cov0" title="0">return result</span>
}

// GetGlobalSymbolTable returns the global symbol table
func (nm *NamespaceManager) GetGlobalSymbolTable() *SymbolTable <span class="cov0" title="0">{
        return nm.globalSymbolTable
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package tests provides test utilities and helpers for the transpiler
package tests

import (
        "strings"
        "testing"

        "github.com/thsfranca/vex/internal/transpiler"
)

// TestCase represents a test case for transpiler testing
type TestCase struct {
        Name     string
        Input    string
        Expected string
        Error    bool
}

// AssertTranspileSuccess tests that input transpiles to expected output
func AssertTranspileSuccess(t *testing.T, input, expected string) <span class="cov0" title="0">{
        t.Helper()
        
        tr := transpiler.New()
        result, err := tr.TranspileFromInput(input)
        
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Expected successful transpilation, got error: %v", err)
        }</span>
        
        <span class="cov0" title="0">if !strings.Contains(result, expected) </span><span class="cov0" title="0">{
                t.Errorf("Expected output to contain:\n%s\n\nActual output:\n%s", expected, result)
        }</span>
}

// AssertTranspileError tests that input produces an error during transpilation
func AssertTranspileError(t *testing.T, input string) <span class="cov0" title="0">{
        t.Helper()
        
        tr := transpiler.New()
        _, err := tr.TranspileFromInput(input)
        
        if err == nil </span><span class="cov0" title="0">{
                t.Error("Expected transpilation error, but got success")
        }</span>
}

// AssertContainsAll checks that result contains all expected strings
func AssertContainsAll(t *testing.T, result string, expected ...string) <span class="cov6" title="11">{
        t.Helper()
        
        for _, exp := range expected </span><span class="cov8" title="25">{
                if !strings.Contains(result, exp) </span><span class="cov0" title="0">{
                        t.Errorf("Expected result to contain: %s\nActual result:\n%s", exp, result)
                }</span>
        }
}

// AssertNotContains checks that result does not contain any of the strings
func AssertNotContains(t *testing.T, result string, unexpected ...string) <span class="cov0" title="0">{
        t.Helper()
        
        for _, unexp := range unexpected </span><span class="cov0" title="0">{
                if strings.Contains(result, unexp) </span><span class="cov0" title="0">{
                        t.Errorf("Expected result NOT to contain: %s\nActual result:\n%s", unexp, result)
                }</span>
        }
}

// NormalizeWhitespace normalizes whitespace for comparison
func NormalizeWhitespace(s string) string <span class="cov0" title="0">{
        lines := strings.Split(s, "\n")
        var normalized []string
        
        for _, line := range lines </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(line)
                if trimmed != "" </span><span class="cov0" title="0">{
                        normalized = append(normalized, trimmed)
                }</span>
        }
        
        <span class="cov0" title="0">return strings.Join(normalized, "\n")</span>
}

// RunTestCases runs a slice of test cases
func RunTestCases(t *testing.T, cases []TestCase) <span class="cov7" title="17">{
        t.Helper()
        
        for _, tc := range cases </span><span class="cov10" title="45">{
                t.Run(tc.Name, func(t *testing.T) </span><span class="cov10" title="45">{
                        tr := transpiler.New()
                        result, err := tr.TranspileFromInput(tc.Input)
                        
                        if tc.Error </span><span class="cov7" title="19">{
                                if err == nil </span><span class="cov0" title="0">{
                                        t.Error("Expected error, but got success")
                                }</span>
                                <span class="cov7" title="19">return</span>
                        }
                        
                        <span class="cov8" title="26">if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("Unexpected error: %v", err)
                        }</span>
                        
                        <span class="cov8" title="26">if tc.Expected != "" &amp;&amp; !strings.Contains(result, tc.Expected) </span><span class="cov0" title="0">{
                                t.Errorf("Expected output to contain:\n%s\n\nActual output:\n%s", tc.Expected, result)
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package transpiler provides the core Vex to Go transpiler functionality
package transpiler

import (
        "fmt"
        "os"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// Transpiler handles the conversion from Vex AST to Go code
type Transpiler struct {
}

// New creates a new transpiler instance
func New() *Transpiler <span class="cov0" title="0">{
        return &amp;Transpiler{}
}</span>

// TranspileFromInput transpiles Vex source code to Go code
func (t *Transpiler) TranspileFromInput(input string) (string, error) <span class="cov0" title="0">{
        // Phase 1: Pre-process to find and register user-defined macros
        expander := NewMacroExpander()
        err := t.registerUserDefinedMacros(input, expander)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("macro registration failed: %w", err)
        }</span>

        // Phase 2: Macro expansion (now includes user-defined macros)
        <span class="cov0" title="0">expandedInput, err := expander.ExpandMacros(input)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("macro expansion failed: %w", err)
        }</span>

        // Debug output removed - macro system is working

        // Create input stream from the expanded source code
        <span class="cov0" title="0">inputStream := antlr.NewInputStream(expandedInput)

        // Create lexer
        lexer := parser.NewVexLexer(inputStream)

        // Create token stream
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)

        // Create parser
        vexParser := parser.NewVexParser(tokenStream)

        // Add error listener to catch syntax errors
        errorListener := &amp;ErrorListener{}
        vexParser.RemoveErrorListeners()
        vexParser.AddErrorListener(errorListener)

        // Parse starting from the 'program' rule (root rule)
        tree := vexParser.Program()

        // Check for parse errors
        if errorListener.hasError </span><span class="cov0" title="0">{
                return "", fmt.Errorf("syntax error: %s", errorListener.errorMsg)
        }</span>

        // Create semantic visitor with type system integration
        <span class="cov0" title="0">semanticVisitor := NewSemanticVisitor()

        // Perform semantic analysis and type checking
        programCtx, ok := tree.(*parser.ProgramContext)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("expected ProgramContext, got %T", tree)
        }</span>

        <span class="cov0" title="0">err = semanticVisitor.AnalyzeProgram(programCtx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("semantic analysis failed: %w", err)
        }</span>

        // Check for semantic errors
        <span class="cov0" title="0">if semanticVisitor.HasErrors() </span><span class="cov0" title="0">{
                errorMsg := strings.Join(semanticVisitor.GetErrors(), "; ")
                return "", fmt.Errorf("semantic errors: %s", errorMsg)
        }</span>

        // Generate final Go code with type information
        <span class="cov0" title="0">return t.generateGoCodeWithSemanticVisitor(semanticVisitor), nil</span>
}

// TranspileFromFile transpiles a .vex file to Go code
func (t *Transpiler) TranspileFromFile(filename string) (string, error) <span class="cov0" title="0">{
        // Read the file content
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read file %s: %w", filename, err)
        }</span>

        // Transpile the content
        <span class="cov0" title="0">return t.TranspileFromInput(string(content))</span>
}

// generateGoCodeWithVisitor generates Go code using visitor data (imports + content)
func (t *Transpiler) generateGoCodeWithVisitor(visitor *ASTVisitor) string <span class="cov0" title="0">{
        var result strings.Builder

        // Package declaration
        result.WriteString("package main\n\n")

        // Add imports at the top
        codeGen := visitor.GetCodeGenerator()
        imports := codeGen.GetImports()
        if len(imports) &gt; 0 </span><span class="cov0" title="0">{
                for _, imp := range imports </span><span class="cov0" title="0">{
                        result.WriteString("import " + imp + "\n")
                }</span>
                <span class="cov0" title="0">result.WriteString("\n")</span>
        }

        // Main function with the generated code
        <span class="cov0" title="0">result.WriteString("func main() {\n")
        content := visitor.GetGeneratedCode()
        if content != "" </span><span class="cov0" title="0">{
                // Add indentation to the content
                lines := strings.Split(content, "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        if strings.TrimSpace(line) != "" </span><span class="cov0" title="0">{
                                result.WriteString("\t" + line + "\n")
                        }</span>
                }
        }
        <span class="cov0" title="0">result.WriteString("}\n")

        return result.String()</span>
}

// Reset clears the transpiler state for reuse
func (t *Transpiler) Reset() {<span class="cov0" title="0">
        // No state to reset in current implementation
}</span>

// registerUserDefinedMacros pre-processes source to find and register user-defined macros
func (t *Transpiler) registerUserDefinedMacros(input string, expander *MacroExpander) error <span class="cov0" title="0">{
        fmt.Printf("DEBUG: Starting macro registration for input: %s\n", input)

        // Create a temporary parse to find macro definitions
        inputStream := antlr.NewInputStream(input)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)

        // Add error listener but allow parsing to continue for macro collection
        errorListener := &amp;ErrorListener{}
        vexParser.RemoveErrorListeners()
        vexParser.AddErrorListener(errorListener)

        // Parse the program
        tree := vexParser.Program()

        // If there are syntax errors, we can't register macros safely
        if errorListener.hasError </span><span class="cov0" title="0">{
                return fmt.Errorf("syntax error prevents macro registration: %s", errorListener.errorMsg)
        }</span>

        <span class="cov0" title="0">fmt.Printf("DEBUG: Successfully parsed for macro collection\n")

        // Create a macro registry collector
        macroCollector := NewMacroCollector(expander)

        // Walk the tree to find macro definitions
        programCtx, ok := tree.(*parser.ProgramContext)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ProgramContext for macro collection, got %T", tree)
        }</span>

        <span class="cov0" title="0">err := macroCollector.CollectMacros(programCtx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("DEBUG: Macro collection completed\n")
        return nil</span>
}

// generateGoCodeWithSemanticVisitor generates Go code using semantic visitor with type information
func (t *Transpiler) generateGoCodeWithSemanticVisitor(semanticVisitor *SemanticVisitor) string <span class="cov0" title="0">{
        var result strings.Builder

        // Package declaration
        result.WriteString("package main\n\n")

        // Add imports at the top
        codeGen := semanticVisitor.GetCodeGenerator()
        imports := codeGen.GetImports()
        if len(imports) &gt; 0 </span><span class="cov0" title="0">{
                for _, imp := range imports </span><span class="cov0" title="0">{
                        result.WriteString("import " + imp + "\n")
                }</span>
                <span class="cov0" title="0">result.WriteString("\n")</span>
        }

        // Main function with the generated code
        <span class="cov0" title="0">result.WriteString("func main() {\n")
        content := semanticVisitor.GetGeneratedCode()
        if content != "" </span><span class="cov0" title="0">{
                // Add indentation to the content
                lines := strings.Split(content, "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        if strings.TrimSpace(line) != "" </span><span class="cov0" title="0">{
                                result.WriteString("\t" + line + "\n")
                        }</span>
                }
        }
        <span class="cov0" title="0">result.WriteString("}\n")

        return result.String()</span>
}

// ErrorListener captures syntax errors during parsing
type ErrorListener struct {
        *antlr.DefaultErrorListener
        hasError bool
        errorMsg string
}

func (el *ErrorListener) SyntaxError(recognizer antlr.Recognizer, offendingSymbol interface{}, line, column int, msg string, e antlr.RecognitionException) <span class="cov0" title="0">{
        el.hasError = true
        el.errorMsg = fmt.Sprintf("line %d:%d - %s", line, column, msg)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package transpiler provides type checking for the Vex language
package transpiler

import (
        "fmt"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// TypeChecker performs multi-pass type checking and validation
type TypeChecker struct {
        namespaceManager *NamespaceManager
        typeInference    *TypeInference
        typeUtils        *TypeUtils
        errors           []TypeError
        currentPass      int
}

// TypeError represents a type checking error
type TypeError struct {
        Message  string
        Location string
        Line     int
        Column   int
        Pass     int
}

// String returns the string representation of a type error
func (te *TypeError) String() string <span class="cov0" title="0">{
        if te.Line &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("Type error (pass %d) at line %d:%d (%s): %s", te.Pass, te.Line, te.Column, te.Location, te.Message)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Type error (pass %d) at %s: %s", te.Pass, te.Location, te.Message)</span>
}

// NewTypeChecker creates a new type checker
func NewTypeChecker(namespaceManager *NamespaceManager) *TypeChecker <span class="cov0" title="0">{
        return &amp;TypeChecker{
                namespaceManager: namespaceManager,
                typeInference:    NewTypeInference(namespaceManager),
                typeUtils:        &amp;TypeUtils{},
                errors:           make([]TypeError, 0, 16),
                currentPass:      0,
        }
}</span>

// CheckProgram performs comprehensive type checking on a program
func (tc *TypeChecker) CheckProgram(programCtx *parser.ProgramContext) ([]TypeError, error) <span class="cov0" title="0">{
        tc.errors = tc.errors[:0] // Reset errors

        // Pass 1: Symbol collection and basic binding
        tc.currentPass = 1
        err := tc.collectSymbols(programCtx)
        if err != nil </span><span class="cov0" title="0">{
                return tc.errors, err
        }</span>

        // Pass 2: Type inference and constraint generation
        <span class="cov0" title="0">tc.currentPass = 2
        err = tc.performTypeInference(programCtx)
        if err != nil </span><span class="cov0" title="0">{
                return tc.errors, err
        }</span>

        // Pass 3: Type compatibility validation
        <span class="cov0" title="0">tc.currentPass = 3
        err = tc.validateTypeCompatibility(programCtx)
        if err != nil </span><span class="cov0" title="0">{
                return tc.errors, err
        }</span>

        // Pass 4: Semantic validation (immutability, etc.)
        <span class="cov0" title="0">tc.currentPass = 4
        err = tc.validateSemantics(programCtx)
        if err != nil </span><span class="cov0" title="0">{
                return tc.errors, err
        }</span>

        <span class="cov0" title="0">return tc.errors, nil</span>
}

// collectSymbols (Pass 1) collects all symbol definitions before type inference
func (tc *TypeChecker) collectSymbols(programCtx *parser.ProgramContext) error <span class="cov0" title="0">{
        for _, child := range programCtx.GetChildren() </span><span class="cov0" title="0">{
                if listCtx, ok := child.(*parser.ListContext); ok </span><span class="cov0" title="0">{
                        err := tc.collectSymbolsFromList(listCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// collectSymbolsFromList collects symbols from a list expression
func (tc *TypeChecker) collectSymbolsFromList(listCtx *parser.ListContext) error <span class="cov0" title="0">{
        children := listCtx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        if len(content) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the first element
        <span class="cov0" title="0">firstChild := content[0]
        var firstElement string
        if symbolCtx, ok := firstChild.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                firstElement = symbolCtx.GetText()
        }</span>

        <span class="cov0" title="0">switch firstElement </span>{
        case "def":<span class="cov0" title="0">
                return tc.collectVariableDefinition(content)</span>
        case "deftype":<span class="cov0" title="0">
                return tc.collectTypeDefinition(content)</span>
        default:<span class="cov0" title="0">
                // Recursively process nested lists
                for _, child := range content </span><span class="cov0" title="0">{
                        if nestedList, ok := child.(*parser.ListContext); ok </span><span class="cov0" title="0">{
                                err := tc.collectSymbolsFromList(nestedList)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// collectVariableDefinition collects variable definitions for symbol table
func (tc *TypeChecker) collectVariableDefinition(content []antlr.Tree) error <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                tc.addError("Invalid variable definition: expected (def name value)", "unknown")
                return nil
        }</span>

        // Get variable name
        <span class="cov0" title="0">var varName string
        if symbolCtx, ok := content[1].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                varName = symbolCtx.GetText()
        }</span> else<span class="cov0" title="0"> {
                tc.addError("Variable name must be a symbol", "unknown")
                return nil
        }</span>

        // Pre-bind with unknown type (will be inferred later)
        <span class="cov0" title="0">currentNS := tc.namespaceManager.GetCurrentNamespace()
        currentNS.Bind(varName, NewUnknownType(tc.typeInference.getNextUnknownID()), false)

        return nil</span>
}

// collectTypeDefinition collects type definitions for symbol table
func (tc *TypeChecker) collectTypeDefinition(content []antlr.Tree) error <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                tc.addError("Invalid type definition: expected (deftype name definition)", "unknown")
                return nil
        }</span>

        // Get type name
        <span class="cov0" title="0">var typeName string
        if symbolCtx, ok := content[1].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                typeName = symbolCtx.GetText()
        }</span> else<span class="cov0" title="0"> {
                tc.addError("Type name must be a symbol", "unknown")
                return nil
        }</span>

        // TODO: Implement custom type definitions
        // For now, just register as a symbol type
        <span class="cov0" title="0">currentNS := tc.namespaceManager.GetCurrentNamespace()
        currentNS.Bind(typeName, SymbolType, false)

        return nil</span>
}

// performTypeInference (Pass 2) performs type inference on all expressions
func (tc *TypeChecker) performTypeInference(programCtx *parser.ProgramContext) error <span class="cov0" title="0">{
        for _, child := range programCtx.GetChildren() </span><span class="cov0" title="0">{
                _, err := tc.typeInference.InferTypes(child)
                if err != nil </span><span class="cov0" title="0">{
                        tc.addError(fmt.Sprintf("Type inference failed: %s", err.Error()), "unknown")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateTypeCompatibility (Pass 3) validates type compatibility in expressions
func (tc *TypeChecker) validateTypeCompatibility(programCtx *parser.ProgramContext) error <span class="cov0" title="0">{
        for _, child := range programCtx.GetChildren() </span><span class="cov0" title="0">{
                err := tc.validateExpressionTypes(child)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateExpressionTypes validates types in expressions
func (tc *TypeChecker) validateExpressionTypes(node antlr.Tree) error <span class="cov0" title="0">{
        switch ctx := node.(type) </span>{
        case *parser.ListContext:<span class="cov0" title="0">
                return tc.validateListTypes(ctx)</span>
        case *parser.ArrayContext:<span class="cov0" title="0">
                return tc.validateArrayTypes(ctx)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// validateListTypes validates types in list expressions
func (tc *TypeChecker) validateListTypes(listCtx *parser.ListContext) error <span class="cov0" title="0">{
        children := listCtx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        if len(content) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the first element
        <span class="cov0" title="0">firstChild := content[0]
        var firstElement string
        if symbolCtx, ok := firstChild.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                firstElement = symbolCtx.GetText()
        }</span>

        <span class="cov0" title="0">switch firstElement </span>{
        case "def":<span class="cov0" title="0">
                return tc.validateDefinitionTypes(content)</span>
        case "+", "-", "*", "/":<span class="cov0" title="0">
                return tc.validateArithmeticTypes(firstElement, content[1:])</span>
        case "if":<span class="cov0" title="0">
                return tc.validateConditionalTypes(content[1:])</span>
        default:<span class="cov0" title="0">
                // Check if it's a function call
                if binding, exists := tc.namespaceManager.GetCurrentNamespace().Resolve(firstElement); exists </span><span class="cov0" title="0">{
                        if binding.IsFunction </span><span class="cov0" title="0">{
                                return tc.validateFunctionCallTypes(binding, content[1:])
                        }</span>
                }

                // Recursively validate nested expressions
                <span class="cov0" title="0">for _, child := range content </span><span class="cov0" title="0">{
                        err := tc.validateExpressionTypes(child)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateArrayTypes validates types in array literals
func (tc *TypeChecker) validateArrayTypes(arrayCtx *parser.ArrayContext) error <span class="cov0" title="0">{
        children := arrayCtx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        if len(content) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the type of the first element
        <span class="cov0" title="0">firstType, err := tc.typeInference.InferTypes(content[0])
        if err != nil </span><span class="cov0" title="0">{
                tc.addError(fmt.Sprintf("Cannot infer type of array element: %s", err.Error()), "array")
                return nil
        }</span>

        // Validate that all elements have compatible types
        <span class="cov0" title="0">for i := 1; i &lt; len(content); i++ </span><span class="cov0" title="0">{
                elementType, err := tc.typeInference.InferTypes(content[i])
                if err != nil </span><span class="cov0" title="0">{
                        tc.addError(fmt.Sprintf("Cannot infer type of array element %d: %s", i, err.Error()), "array")
                        continue</span>
                }

                <span class="cov0" title="0">if !firstType.IsAssignableFrom(elementType) </span><span class="cov0" title="0">{
                        tc.addError(fmt.Sprintf("Array element type mismatch: expected %s, got %s",
                                firstType.String(), elementType.String()), "array")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateDefinitionTypes validates variable definition types
func (tc *TypeChecker) validateDefinitionTypes(content []antlr.Tree) error <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                tc.addError("Invalid definition: expected (def name value)", "definition")
                return nil
        }</span>

        // Get variable name
        <span class="cov0" title="0">var varName string
        if symbolCtx, ok := content[1].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                varName = symbolCtx.GetText()
        }</span> else<span class="cov0" title="0"> {
                tc.addErrorWithNode("Variable name must be a symbol", "definition", content[1])
                return nil
        }</span>

        // Infer the value type
        <span class="cov0" title="0">valueType, err := tc.typeInference.InferTypes(content[2])
        if err != nil </span><span class="cov0" title="0">{
                tc.addErrorWithNode(fmt.Sprintf("Cannot infer type of variable %s: %s", varName, err.Error()), "definition", content[2])
                return nil
        }</span>

        // Update the binding with the inferred type
        <span class="cov0" title="0">currentNS := tc.namespaceManager.GetCurrentNamespace()
        currentNS.Bind(varName, valueType, false)

        return nil</span>
}

// validateArithmeticTypes validates arithmetic expression types
func (tc *TypeChecker) validateArithmeticTypes(operator string, operands []antlr.Tree) error <span class="cov0" title="0">{
        if len(operands) &lt; 2 </span><span class="cov0" title="0">{
                tc.addError(fmt.Sprintf("Arithmetic operation %s requires at least 2 operands", operator), "arithmetic")
                return nil
        }</span>

        <span class="cov0" title="0">for i, operand := range operands </span><span class="cov0" title="0">{
                operandType, err := tc.typeInference.InferTypes(operand)
                if err != nil </span><span class="cov0" title="0">{
                        tc.addError(fmt.Sprintf("Cannot infer type of operand %d in %s: %s", i, operator, err.Error()), "arithmetic")
                        continue</span>
                }

                // Check if operand is numeric
                <span class="cov0" title="0">if !tc.isNumericType(operandType) </span><span class="cov0" title="0">{
                        tc.addError(fmt.Sprintf("Arithmetic operation %s requires numeric operands, got %s",
                                operator, operandType.String()), "arithmetic")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateConditionalTypes validates conditional expression types
func (tc *TypeChecker) validateConditionalTypes(content []antlr.Tree) error <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                tc.addError("Conditional requires condition, then-branch, and else-branch", "conditional")
                return nil
        }</span>

        // Validate condition type
        <span class="cov0" title="0">conditionType, err := tc.typeInference.InferTypes(content[0])
        if err != nil </span><span class="cov0" title="0">{
                tc.addError(fmt.Sprintf("Cannot infer condition type: %s", err.Error()), "conditional")
        }</span> else<span class="cov0" title="0"> if !conditionType.Equals(BoolType) </span><span class="cov0" title="0">{
                tc.addError(fmt.Sprintf("Condition must be boolean, got %s", conditionType.String()), "conditional")
        }</span>

        // Validate branch types
        <span class="cov0" title="0">thenType, err := tc.typeInference.InferTypes(content[1])
        if err != nil </span><span class="cov0" title="0">{
                tc.addError(fmt.Sprintf("Cannot infer then-branch type: %s", err.Error()), "conditional")
                return nil
        }</span>

        <span class="cov0" title="0">elseType, err := tc.typeInference.InferTypes(content[2])
        if err != nil </span><span class="cov0" title="0">{
                tc.addError(fmt.Sprintf("Cannot infer else-branch type: %s", err.Error()), "conditional")
                return nil
        }</span>

        <span class="cov0" title="0">if !thenType.IsAssignableFrom(elseType) </span><span class="cov0" title="0">{
                tc.addError(fmt.Sprintf("Conditional branch type mismatch: then-branch is %s, else-branch is %s",
                        thenType.String(), elseType.String()), "conditional")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateFunctionCallTypes validates function call types
func (tc *TypeChecker) validateFunctionCallTypes(funcBinding *Binding, args []antlr.Tree) error <span class="cov0" title="0">{
        funcType, ok := funcBinding.Type.(*FunctionType)
        if !ok </span><span class="cov0" title="0">{
                tc.addError(fmt.Sprintf("Symbol %s is not a function", funcBinding.Symbol.Name), "function-call")
                return nil
        }</span>

        <span class="cov0" title="0">if len(args) != len(funcType.Parameters) </span><span class="cov0" title="0">{
                tc.addError(fmt.Sprintf("Function %s expects %d arguments, got %d",
                        funcBinding.Symbol.Name, len(funcType.Parameters), len(args)), "function-call")
                return nil
        }</span>

        // Validate each argument type
        <span class="cov0" title="0">for i, arg := range args </span><span class="cov0" title="0">{
                argType, err := tc.typeInference.InferTypes(arg)
                if err != nil </span><span class="cov0" title="0">{
                        tc.addError(fmt.Sprintf("Cannot infer type of argument %d to function %s: %s",
                                i, funcBinding.Symbol.Name, err.Error()), "function-call")
                        continue</span>
                }

                <span class="cov0" title="0">expectedType := funcType.Parameters[i]
                if !expectedType.IsAssignableFrom(argType) </span><span class="cov0" title="0">{
                        tc.addError(fmt.Sprintf("Argument %d to function %s: expected %s, got %s",
                                i, funcBinding.Symbol.Name, expectedType.String(), argType.String()), "function-call")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateSemantics (Pass 4) validates semantic constraints like immutability
func (tc *TypeChecker) validateSemantics(programCtx *parser.ProgramContext) error <span class="cov0" title="0">{
        for _, child := range programCtx.GetChildren() </span><span class="cov0" title="0">{
                err := tc.validateSemanticConstraints(child)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateSemanticConstraints validates semantic constraints
func (tc *TypeChecker) validateSemanticConstraints(node antlr.Tree) error <span class="cov0" title="0">{
        switch ctx := node.(type) </span>{
        case *parser.ListContext:<span class="cov0" title="0">
                return tc.validateListSemantics(ctx)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// validateListSemantics validates semantic constraints in lists
func (tc *TypeChecker) validateListSemantics(listCtx *parser.ListContext) error <span class="cov0" title="0">{
        children := listCtx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        if len(content) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the first element
        <span class="cov0" title="0">firstChild := content[0]
        var firstElement string
        if symbolCtx, ok := firstChild.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                firstElement = symbolCtx.GetText()
        }</span>

        <span class="cov0" title="0">switch firstElement </span>{
        case "set!":<span class="cov0" title="0">
                return tc.validateMutationSemantics(content[1:])</span>
        default:<span class="cov0" title="0">
                // Recursively validate nested expressions
                for _, child := range content </span><span class="cov0" title="0">{
                        err := tc.validateSemanticConstraints(child)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateMutationSemantics validates mutation operations (should be restricted)
func (tc *TypeChecker) validateMutationSemantics(content []antlr.Tree) error <span class="cov0" title="0">{
        if len(content) &lt; 2 </span><span class="cov0" title="0">{
                tc.addError("Invalid mutation: expected (set! var value)", "mutation")
                return nil
        }</span>

        // Get variable name
        <span class="cov0" title="0">var varName string
        if symbolCtx, ok := content[0].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                varName = symbolCtx.GetText()
        }</span> else<span class="cov0" title="0"> {
                tc.addError("Mutation target must be a symbol", "mutation")
                return nil
        }</span>

        // Check if variable is mutable
        <span class="cov0" title="0">currentNS := tc.namespaceManager.GetCurrentNamespace()
        if binding, exists := currentNS.Resolve(varName); exists </span><span class="cov0" title="0">{
                if !binding.IsMutable </span><span class="cov0" title="0">{
                        tc.addError(fmt.Sprintf("Cannot mutate immutable variable %s", varName), "mutation")
                }</span>
        } else<span class="cov0" title="0"> {
                tc.addError(fmt.Sprintf("Undefined variable %s in mutation", varName), "mutation")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper methods

// isNumericType checks if a type is numeric (int or float)
func (tc *TypeChecker) isNumericType(vexType VexType) bool <span class="cov0" title="0">{
        return vexType.Equals(IntType) || vexType.Equals(FloatType)
}</span>

// addError adds a type error to the error list
func (tc *TypeChecker) addError(message, location string) <span class="cov0" title="0">{
        tc.addErrorWithNode(message, location, nil)
}</span>

// addErrorWithNode adds a type error with position information from an AST node
func (tc *TypeChecker) addErrorWithNode(message, location string, node antlr.Tree) <span class="cov0" title="0">{
        line, column := tc.getNodePosition(node)
        error := TypeError{
                Message:  message,
                Location: location,
                Line:     line,
                Column:   column,
                Pass:     tc.currentPass,
        }
        tc.errors = append(tc.errors, error)
}</span>

// getNodePosition extracts line and column information from an AST node
func (tc *TypeChecker) getNodePosition(node antlr.Tree) (int, int) <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        <span class="cov0" title="0">switch ctx := node.(type) </span>{
        case *antlr.TerminalNodeImpl:<span class="cov0" title="0">
                token := ctx.GetSymbol()
                return token.GetLine(), token.GetColumn()</span>
        case *parser.ListContext:<span class="cov0" title="0">
                // Get position from the first token (opening parenthesis)
                if ctx.GetStart() != nil </span><span class="cov0" title="0">{
                        return ctx.GetStart().GetLine(), ctx.GetStart().GetColumn()
                }</span>
        case *parser.ArrayContext:<span class="cov0" title="0">
                // Get position from the first token (opening bracket)
                if ctx.GetStart() != nil </span><span class="cov0" title="0">{
                        return ctx.GetStart().GetLine(), ctx.GetStart().GetColumn()
                }</span>
        case *parser.ProgramContext:<span class="cov0" title="0">
                // Get position from the first token
                if ctx.GetStart() != nil </span><span class="cov0" title="0">{
                        return ctx.GetStart().GetLine(), ctx.GetStart().GetColumn()
                }</span>
        }
        <span class="cov0" title="0">return 0, 0</span>
}

// GetErrors returns all collected type errors
func (tc *TypeChecker) GetErrors() []TypeError <span class="cov0" title="0">{
        return tc.errors
}</span>

// HasErrors returns true if there are any type errors
func (tc *TypeChecker) HasErrors() bool <span class="cov0" title="0">{
        return len(tc.errors) &gt; 0
}</span>

// GetErrorsByPass returns errors from a specific pass
func (tc *TypeChecker) GetErrorsByPass(pass int) []TypeError <span class="cov0" title="0">{
        var result []TypeError
        for _, err := range tc.errors </span><span class="cov0" title="0">{
                if err.Pass == pass </span><span class="cov0" title="0">{
                        result = append(result, err)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// FormatErrors returns a formatted string of all errors
func (tc *TypeChecker) FormatErrors() string <span class="cov0" title="0">{
        if len(tc.errors) == 0 </span><span class="cov0" title="0">{
                return "No type errors"
        }</span>

        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString(fmt.Sprintf("Found %d type error(s):\n", len(tc.errors)))

        for i, err := range tc.errors </span><span class="cov0" title="0">{
                builder.WriteString(fmt.Sprintf("  %d. %s\n", i+1, err.String()))
        }</span>

        <span class="cov0" title="0">return builder.String()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package transpiler provides type inference for the Vex language
package transpiler

import (
        "fmt"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// TypeInference implements Hindley-Milner style type inference
type TypeInference struct {
        namespaceManager *NamespaceManager
        typeUtils        *TypeUtils
        substitutions    map[int]VexType // Unknown type ID -&gt; concrete type mappings
        nextUnknownID    int
        constraints      []*TypeConstraint
}

// TypeConstraint represents a constraint between two types that must be unified
type TypeConstraint struct {
        Left    VexType
        Right   VexType
        Context string // For error reporting
}

// NewTypeInference creates a new type inference engine
func NewTypeInference(namespaceManager *NamespaceManager) *TypeInference <span class="cov0" title="0">{
        return &amp;TypeInference{
                namespaceManager: namespaceManager,
                typeUtils:        &amp;TypeUtils{},
                substitutions:    make(map[int]VexType, 64),
                nextUnknownID:    1,
                constraints:      make([]*TypeConstraint, 0, 32),
        }
}</span>

// InferTypes performs type inference on an AST node
func (ti *TypeInference) InferTypes(node antlr.Tree) (VexType, error) <span class="cov0" title="0">{
        // Reset state for new inference
        ti.constraints = ti.constraints[:0]

        // Generate constraints from the AST
        inferredType, err := ti.generateConstraints(node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Solve constraints through unification
        <span class="cov0" title="0">err = ti.solveConstraints()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Apply substitutions to get final type
        <span class="cov0" title="0">finalType := ti.applySubstitutions(inferredType)
        return finalType, nil</span>
}

// generateConstraints traverses the AST and generates type constraints
func (ti *TypeInference) generateConstraints(node antlr.Tree) (VexType, error) <span class="cov0" title="0">{
        switch ctx := node.(type) </span>{
        case *antlr.TerminalNodeImpl:<span class="cov0" title="0">
                return ti.inferLiteralType(ctx.GetText())</span>

        case *parser.ListContext:<span class="cov0" title="0">
                return ti.inferListType(ctx)</span>

        case *parser.ArrayContext:<span class="cov0" title="0">
                return ti.inferArrayType(ctx)</span>

        case *parser.ProgramContext:<span class="cov0" title="0">
                // For programs, infer the type of the last expression
                children := ctx.GetChildren()
                if len(children) &gt; 0 </span><span class="cov0" title="0">{
                        return ti.generateConstraints(children[len(children)-1])
                }</span>
                <span class="cov0" title="0">return NewUnknownType(ti.nextUnknownID), nil</span>

        default:<span class="cov0" title="0">
                return NewUnknownType(ti.nextUnknownID), fmt.Errorf("unsupported node type for inference: %T", ctx)</span>
        }
}

// inferLiteralType infers the type of a literal value
func (ti *TypeInference) inferLiteralType(value string) (VexType, error) <span class="cov0" title="0">{
        return ti.typeUtils.InferLiteralType(value), nil
}</span>

// inferListType infers the type of a list (S-expression)
func (ti *TypeInference) inferListType(ctx *parser.ListContext) (VexType, error) <span class="cov0" title="0">{
        children := ctx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{ // '(' ... ')'
                return NewUnknownType(ti.getNextUnknownID()), nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        if len(content) == 0 </span><span class="cov0" title="0">{
                return NewUnknownType(ti.getNextUnknownID()), nil
        }</span>

        // Get the first element to determine the operation
        <span class="cov0" title="0">firstChild := content[0]
        var firstElement string
        if symbolCtx, ok := firstChild.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                firstElement = symbolCtx.GetText()
        }</span>

        <span class="cov0" title="0">switch firstElement </span>{
        case "def":<span class="cov0" title="0">
                return ti.inferDefinitionType(content)</span>
        case "fn":<span class="cov0" title="0">
                return ti.inferFunctionType(content[1:])</span> // Skip "fn"
        case "+", "-", "*", "/":<span class="cov0" title="0">
                return ti.inferArithmeticType(firstElement, content[1:])</span>
        case "if":<span class="cov0" title="0">
                return ti.inferConditionalType(content[1:])</span>
        default:<span class="cov0" title="0">
                // Check if it's a function call
                if binding, exists := ti.namespaceManager.GetCurrentNamespace().Resolve(firstElement); exists </span><span class="cov0" title="0">{
                        if binding.IsFunction </span><span class="cov0" title="0">{
                                return ti.inferFunctionCallType(binding, content[1:])
                        }</span>
                }
                // Default to unknown type
                <span class="cov0" title="0">return NewUnknownType(ti.getNextUnknownID()), nil</span>
        }
}

// inferArrayType infers the type of an array literal
func (ti *TypeInference) inferArrayType(ctx *parser.ArrayContext) (VexType, error) <span class="cov0" title="0">{
        children := ctx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{ // '[' ... ']'
                return NewListType(NewUnknownType(ti.getNextUnknownID())), nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        if len(content) == 0 </span><span class="cov0" title="0">{
                return NewListType(NewUnknownType(ti.getNextUnknownID())), nil
        }</span>

        // Infer the type of the first element
        <span class="cov0" title="0">elementType, err := ti.generateConstraints(content[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add constraints that all elements must have the same type
        <span class="cov0" title="0">for i := 1; i &lt; len(content); i++ </span><span class="cov0" title="0">{
                otherElementType, err := ti.generateConstraints(content[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ti.addConstraint(elementType, otherElementType, fmt.Sprintf("array element %d", i))</span>
        }

        <span class="cov0" title="0">return NewListType(elementType), nil</span>
}

// inferDefinitionType infers the type of a variable definition
func (ti *TypeInference) inferDefinitionType(content []antlr.Tree) (VexType, error) <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid definition: expected (def name value)")
        }</span>

        // Get variable name
        <span class="cov0" title="0">var varName string
        if symbolCtx, ok := content[1].(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                varName = symbolCtx.GetText()
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("invalid definition: name must be a symbol")
        }</span>

        // Infer the type of the value
        <span class="cov0" title="0">valueType, err := ti.generateConstraints(content[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Bind the variable in the current namespace
        <span class="cov0" title="0">ti.namespaceManager.GetCurrentNamespace().Bind(varName, valueType, false)

        // Definition expressions don't have a return value (void)
        return NewUnknownType(ti.getNextUnknownID()), nil</span>
}

// inferFunctionType infers the type of a function literal
func (ti *TypeInference) inferFunctionType(content []antlr.Tree) (VexType, error) <span class="cov0" title="0">{
        if len(content) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid function: expected (fn [params] body)")
        }</span>

        // Parse parameters
        <span class="cov0" title="0">paramTypes, err := ti.inferParameterTypes(content[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create a new scope for the function
        <span class="cov0" title="0">_ = ti.namespaceManager.CreateNamespace("func", ti.namespaceManager.GetCurrentNamespace())
        oldNamespace := ti.namespaceManager.GetCurrentNamespace()
        ti.namespaceManager.SetCurrentNamespace("func")

        // Infer the return type from the body
        returnType, err := ti.generateConstraints(content[1])
        if err != nil </span><span class="cov0" title="0">{
                ti.namespaceManager.SetCurrentNamespace(oldNamespace.Name)
                return nil, err
        }</span>

        // Restore the previous namespace
        <span class="cov0" title="0">ti.namespaceManager.SetCurrentNamespace(oldNamespace.Name)

        return NewFunctionType(paramTypes, returnType), nil</span>
}

// inferParameterTypes infers the types of function parameters
func (ti *TypeInference) inferParameterTypes(paramNode antlr.Tree) ([]VexType, error) <span class="cov0" title="0">{
        arrayCtx, ok := paramNode.(*parser.ArrayContext)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function parameters must be an array")
        }</span>

        <span class="cov0" title="0">children := arrayCtx.GetChildren()
        if len(children) &lt; 3 </span><span class="cov0" title="0">{ // '[' ... ']'
                return []VexType{}, nil
        }</span>

        <span class="cov0" title="0">content := children[1 : len(children)-1]
        paramTypes := make([]VexType, len(content))

        for i, paramNode := range content </span><span class="cov0" title="0">{
                // For now, parameters have unknown types (will be inferred from usage)
                paramTypes[i] = NewUnknownType(ti.getNextUnknownID())

                // If it's a terminal node (parameter name), bind it in the function scope
                if symbolCtx, ok := paramNode.(*antlr.TerminalNodeImpl); ok </span><span class="cov0" title="0">{
                        paramName := symbolCtx.GetText()
                        ti.namespaceManager.GetCurrentNamespace().Bind(paramName, paramTypes[i], false)
                }</span>
        }

        <span class="cov0" title="0">return paramTypes, nil</span>
}

// inferArithmeticType infers the type of arithmetic expressions
func (ti *TypeInference) inferArithmeticType(operator string, operands []antlr.Tree) (VexType, error) <span class="cov0" title="0">{
        if len(operands) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("arithmetic operation %s requires at least 2 operands", operator)
        }</span>

        // For arithmetic operations, all operands should be numbers
        // Start with the first operand
        <span class="cov0" title="0">firstType, err := ti.generateConstraints(operands[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add constraints that all operands must be the same numeric type
        <span class="cov0" title="0">for i := 1; i &lt; len(operands); i++ </span><span class="cov0" title="0">{
                operandType, err := ti.generateConstraints(operands[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ti.addConstraint(firstType, operandType, fmt.Sprintf("arithmetic operand %d", i))</span>
        }

        // Result type is the same as operand types for basic arithmetic
        <span class="cov0" title="0">return firstType, nil</span>
}

// inferConditionalType infers the type of conditional expressions
func (ti *TypeInference) inferConditionalType(content []antlr.Tree) (VexType, error) <span class="cov0" title="0">{
        if len(content) &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("conditional requires condition, then-branch, and else-branch")
        }</span>

        // Infer condition type (should be boolean)
        <span class="cov0" title="0">conditionType, err := ti.generateConstraints(content[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ti.addConstraint(conditionType, BoolType, "conditional condition")

        // Infer then-branch type
        thenType, err := ti.generateConstraints(content[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Infer else-branch type
        <span class="cov0" title="0">elseType, err := ti.generateConstraints(content[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Then and else branches must have the same type
        <span class="cov0" title="0">ti.addConstraint(thenType, elseType, "conditional branches")

        return thenType, nil</span>
}

// inferFunctionCallType infers the type of a function call
func (ti *TypeInference) inferFunctionCallType(funcBinding *Binding, args []antlr.Tree) (VexType, error) <span class="cov0" title="0">{
        funcType, ok := funcBinding.Type.(*FunctionType)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("symbol %s is not a function", funcBinding.Symbol.Name)
        }</span>

        <span class="cov0" title="0">if len(args) != len(funcType.Parameters) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function %s expects %d arguments, got %d",
                        funcBinding.Symbol.Name, len(funcType.Parameters), len(args))
        }</span>

        // Add constraints for each argument
        <span class="cov0" title="0">for i, arg := range args </span><span class="cov0" title="0">{
                argType, err := ti.generateConstraints(arg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ti.addConstraint(argType, funcType.Parameters[i],
                        fmt.Sprintf("function %s argument %d", funcBinding.Symbol.Name, i))</span>
        }

        <span class="cov0" title="0">return funcType.ReturnType, nil</span>
}

// addConstraint adds a type constraint to be solved later
func (ti *TypeInference) addConstraint(left, right VexType, context string) <span class="cov0" title="0">{
        constraint := &amp;TypeConstraint{
                Left:    left,
                Right:   right,
                Context: context,
        }
        ti.constraints = append(ti.constraints, constraint)
}</span>

// solveConstraints solves all accumulated constraints through unification
func (ti *TypeInference) solveConstraints() error <span class="cov0" title="0">{
        for _, constraint := range ti.constraints </span><span class="cov0" title="0">{
                err := ti.unifyConstraint(constraint)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("type error in %s: %w", constraint.Context, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// unifyConstraint unifies a single constraint
func (ti *TypeInference) unifyConstraint(constraint *TypeConstraint) error <span class="cov0" title="0">{
        left := ti.applySubstitutions(constraint.Left)
        right := ti.applySubstitutions(constraint.Right)

        return ti.unify(left, right)
}</span>

// unify attempts to unify two types, adding substitutions as needed
func (ti *TypeInference) unify(type1, type2 VexType) error <span class="cov0" title="0">{
        // Apply existing substitutions
        type1 = ti.applySubstitutions(type1)
        type2 = ti.applySubstitutions(type2)

        // If types are already equal, no unification needed
        if type1.Equals(type2) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Handle unknown types
        <span class="cov0" title="0">if unknown1, ok := type1.(*UnknownType); ok </span><span class="cov0" title="0">{
                ti.substitutions[unknown1.ID] = type2
                return nil
        }</span>

        <span class="cov0" title="0">if unknown2, ok := type2.(*UnknownType); ok </span><span class="cov0" title="0">{
                ti.substitutions[unknown2.ID] = type1
                return nil
        }</span>

        // Handle structured types
        <span class="cov0" title="0">unified, err := ti.typeUtils.UnifyTypes(type1, type2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If unification succeeded but types weren't equal, update substitutions
        <span class="cov0" title="0">if !type1.Equals(unified) </span><span class="cov0" title="0">{
                if unknown1, ok := type1.(*UnknownType); ok </span><span class="cov0" title="0">{
                        ti.substitutions[unknown1.ID] = unified
                }</span>
        }

        <span class="cov0" title="0">if !type2.Equals(unified) </span><span class="cov0" title="0">{
                if unknown2, ok := type2.(*UnknownType); ok </span><span class="cov0" title="0">{
                        ti.substitutions[unknown2.ID] = unified
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// applySubstitutions applies all current substitutions to a type
func (ti *TypeInference) applySubstitutions(vexType VexType) VexType <span class="cov0" title="0">{
        switch t := vexType.(type) </span>{
        case *UnknownType:<span class="cov0" title="0">
                if substitution, exists := ti.substitutions[t.ID]; exists </span><span class="cov0" title="0">{
                        // Recursively apply substitutions to avoid chains
                        return ti.applySubstitutions(substitution)
                }</span>
                <span class="cov0" title="0">return t</span>

        case *ListType:<span class="cov0" title="0">
                elementType := ti.applySubstitutions(t.ElementType)
                if !elementType.Equals(t.ElementType) </span><span class="cov0" title="0">{
                        return NewListType(elementType)
                }</span>
                <span class="cov0" title="0">return t</span>

        case *MapType:<span class="cov0" title="0">
                keyType := ti.applySubstitutions(t.KeyType)
                valueType := ti.applySubstitutions(t.ValueType)
                if !keyType.Equals(t.KeyType) || !valueType.Equals(t.ValueType) </span><span class="cov0" title="0">{
                        return NewMapType(keyType, valueType)
                }</span>
                <span class="cov0" title="0">return t</span>

        case *FunctionType:<span class="cov0" title="0">
                paramTypes := make([]VexType, len(t.Parameters))
                changed := false

                for i, param := range t.Parameters </span><span class="cov0" title="0">{
                        paramTypes[i] = ti.applySubstitutions(param)
                        if !paramTypes[i].Equals(param) </span><span class="cov0" title="0">{
                                changed = true
                        }</span>
                }

                <span class="cov0" title="0">returnType := ti.applySubstitutions(t.ReturnType)
                if !returnType.Equals(t.ReturnType) </span><span class="cov0" title="0">{
                        changed = true
                }</span>

                <span class="cov0" title="0">if changed </span><span class="cov0" title="0">{
                        return NewFunctionType(paramTypes, returnType)
                }</span>
                <span class="cov0" title="0">return t</span>

        default:<span class="cov0" title="0">
                return vexType</span>
        }
}

// getNextUnknownID returns the next unique ID for unknown types
func (ti *TypeInference) getNextUnknownID() int <span class="cov0" title="0">{
        id := ti.nextUnknownID
        ti.nextUnknownID++
        return id
}</span>

// GetSubstitutions returns a copy of current substitutions (for debugging)
func (ti *TypeInference) GetSubstitutions() map[int]VexType <span class="cov0" title="0">{
        result := make(map[int]VexType, len(ti.substitutions))
        for id, vexType := range ti.substitutions </span><span class="cov0" title="0">{
                result[id] = vexType
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetConstraints returns a copy of current constraints (for debugging)
func (ti *TypeInference) GetConstraints() []*TypeConstraint <span class="cov0" title="0">{
        result := make([]*TypeConstraint, len(ti.constraints))
        copy(result, ti.constraints)
        return result
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package transpiler provides the Vex type system implementation
package transpiler

import (
        "fmt"
        "reflect"
        "strings"
)

// VexType represents a type in the Vex type system
type VexType interface {
        // String returns the string representation of the type
        String() string
        // GoType returns the corresponding Go type string for transpilation
        GoType() string
        // IsAssignableFrom checks if this type can accept values of another type
        IsAssignableFrom(other VexType) bool
        // Equals checks if two types are equivalent
        Equals(other VexType) bool
}

// TypeKind represents the kind of a Vex type
type TypeKind int

const (
        TypeKindPrimitive TypeKind = iota
        TypeKindList
        TypeKindMap
        TypeKindFunction
        TypeKindSymbol
        TypeKindUnknown
        TypeKindGeneric
)

// PrimitiveType represents primitive types in Vex
type PrimitiveType struct {
        Kind   string // "int", "float", "string", "bool"
        goType string
}

// Built-in primitive types
var (
        IntType    = &amp;PrimitiveType{Kind: "int", goType: "int64"}
        FloatType  = &amp;PrimitiveType{Kind: "float", goType: "float64"}
        StringType = &amp;PrimitiveType{Kind: "string", goType: "string"}
        BoolType   = &amp;PrimitiveType{Kind: "bool", goType: "bool"}
        SymbolType = &amp;PrimitiveType{Kind: "symbol", goType: "Symbol"}
)

// String returns the string representation of the primitive type
func (pt *PrimitiveType) String() string <span class="cov0" title="0">{
        return pt.Kind
}</span>

// GoType returns the corresponding Go type
func (pt *PrimitiveType) GoType() string <span class="cov0" title="0">{
        return pt.goType
}</span>

// IsAssignableFrom checks if this primitive type can accept values of another type
func (pt *PrimitiveType) IsAssignableFrom(other VexType) bool <span class="cov0" title="0">{
        if otherPrim, ok := other.(*PrimitiveType); ok </span><span class="cov0" title="0">{
                return pt.Kind == otherPrim.Kind
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Equals checks if two primitive types are equal
func (pt *PrimitiveType) Equals(other VexType) bool <span class="cov0" title="0">{
        if otherPrim, ok := other.(*PrimitiveType); ok </span><span class="cov0" title="0">{
                return pt.Kind == otherPrim.Kind
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ListType represents homogeneous list types [T]
type ListType struct {
        ElementType VexType
}

// NewListType creates a new list type with the specified element type
func NewListType(elementType VexType) *ListType <span class="cov0" title="0">{
        return &amp;ListType{ElementType: elementType}
}</span>

// String returns the string representation of the list type
func (lt *ListType) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[%s]", lt.ElementType.String())
}</span>

// GoType returns the corresponding Go type (slice)
func (lt *ListType) GoType() string <span class="cov0" title="0">{
        return fmt.Sprintf("[]%s", lt.ElementType.GoType())
}</span>

// IsAssignableFrom checks if this list type can accept values of another type
func (lt *ListType) IsAssignableFrom(other VexType) bool <span class="cov0" title="0">{
        if otherList, ok := other.(*ListType); ok </span><span class="cov0" title="0">{
                return lt.ElementType.IsAssignableFrom(otherList.ElementType)
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Equals checks if two list types are equal
func (lt *ListType) Equals(other VexType) bool <span class="cov0" title="0">{
        if otherList, ok := other.(*ListType); ok </span><span class="cov0" title="0">{
                return lt.ElementType.Equals(otherList.ElementType)
        }</span>
        <span class="cov0" title="0">return false</span>
}

// MapType represents immutable map types {K: V}
type MapType struct {
        KeyType   VexType
        ValueType VexType
}

// NewMapType creates a new map type with the specified key and value types
func NewMapType(keyType, valueType VexType) *MapType <span class="cov0" title="0">{
        return &amp;MapType{KeyType: keyType, ValueType: valueType}
}</span>

// String returns the string representation of the map type
func (mt *MapType) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("{%s: %s}", mt.KeyType.String(), mt.ValueType.String())
}</span>

// GoType returns the corresponding Go type (map)
func (mt *MapType) GoType() string <span class="cov0" title="0">{
        return fmt.Sprintf("map[%s]%s", mt.KeyType.GoType(), mt.ValueType.GoType())
}</span>

// IsAssignableFrom checks if this map type can accept values of another type
func (mt *MapType) IsAssignableFrom(other VexType) bool <span class="cov0" title="0">{
        if otherMap, ok := other.(*MapType); ok </span><span class="cov0" title="0">{
                return mt.KeyType.IsAssignableFrom(otherMap.KeyType) &amp;&amp;
                        mt.ValueType.IsAssignableFrom(otherMap.ValueType)
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Equals checks if two map types are equal
func (mt *MapType) Equals(other VexType) bool <span class="cov0" title="0">{
        if otherMap, ok := other.(*MapType); ok </span><span class="cov0" title="0">{
                return mt.KeyType.Equals(otherMap.KeyType) &amp;&amp;
                        mt.ValueType.Equals(otherMap.ValueType)
        }</span>
        <span class="cov0" title="0">return false</span>
}

// FunctionType represents function types with parameters and return type
type FunctionType struct {
        Parameters []VexType
        ReturnType VexType
}

// NewFunctionType creates a new function type
func NewFunctionType(parameters []VexType, returnType VexType) *FunctionType <span class="cov0" title="0">{
        return &amp;FunctionType{Parameters: parameters, ReturnType: returnType}
}</span>

// String returns the string representation of the function type
func (ft *FunctionType) String() string <span class="cov0" title="0">{
        var params []string
        for _, param := range ft.Parameters </span><span class="cov0" title="0">{
                params = append(params, param.String())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%s) -&gt; %s", strings.Join(params, ", "), ft.ReturnType.String())</span>
}

// GoType returns the corresponding Go function type
func (ft *FunctionType) GoType() string <span class="cov0" title="0">{
        var params []string
        for _, param := range ft.Parameters </span><span class="cov0" title="0">{
                params = append(params, param.GoType())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("func(%s) %s", strings.Join(params, ", "), ft.ReturnType.GoType())</span>
}

// IsAssignableFrom checks if this function type can accept values of another type
func (ft *FunctionType) IsAssignableFrom(other VexType) bool <span class="cov0" title="0">{
        if otherFunc, ok := other.(*FunctionType); ok </span><span class="cov0" title="0">{
                if len(ft.Parameters) != len(otherFunc.Parameters) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for i, param := range ft.Parameters </span><span class="cov0" title="0">{
                        if !param.IsAssignableFrom(otherFunc.Parameters[i]) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return ft.ReturnType.IsAssignableFrom(otherFunc.ReturnType)</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Equals checks if two function types are equal
func (ft *FunctionType) Equals(other VexType) bool <span class="cov0" title="0">{
        if otherFunc, ok := other.(*FunctionType); ok </span><span class="cov0" title="0">{
                if len(ft.Parameters) != len(otherFunc.Parameters) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for i, param := range ft.Parameters </span><span class="cov0" title="0">{
                        if !param.Equals(otherFunc.Parameters[i]) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return ft.ReturnType.Equals(otherFunc.ReturnType)</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GenericType represents generic type parameters (e.g., T in List[T])
type GenericType struct {
        Name string
}

// NewGenericType creates a new generic type parameter
func NewGenericType(name string) *GenericType <span class="cov0" title="0">{
        return &amp;GenericType{Name: name}
}</span>

// String returns the string representation of the generic type
func (gt *GenericType) String() string <span class="cov0" title="0">{
        return gt.Name
}</span>

// GoType returns the interface{} type for Go (will be refined during inference)
func (gt *GenericType) GoType() string <span class="cov0" title="0">{
        return "interface{}"
}</span>

// IsAssignableFrom checks if this generic type can accept values of another type
func (gt *GenericType) IsAssignableFrom(other VexType) bool <span class="cov0" title="0">{
        // Generic types are assignable from any type during inference
        return true
}</span>

// Equals checks if two generic types are equal
func (gt *GenericType) Equals(other VexType) bool <span class="cov0" title="0">{
        if otherGeneric, ok := other.(*GenericType); ok </span><span class="cov0" title="0">{
                return gt.Name == otherGeneric.Name
        }</span>
        <span class="cov0" title="0">return false</span>
}

// UnknownType represents types that haven't been inferred yet
type UnknownType struct {
        ID int // Unique identifier for this unknown type
}

// NewUnknownType creates a new unknown type with a unique ID
func NewUnknownType(id int) *UnknownType <span class="cov0" title="0">{
        return &amp;UnknownType{ID: id}
}</span>

// String returns the string representation of the unknown type
func (ut *UnknownType) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("?%d", ut.ID)
}</span>

// GoType returns interface{} for unknown types
func (ut *UnknownType) GoType() string <span class="cov0" title="0">{
        return "interface{}"
}</span>

// IsAssignableFrom checks if this unknown type can accept values of another type
func (ut *UnknownType) IsAssignableFrom(other VexType) bool <span class="cov0" title="0">{
        // Unknown types can be unified with any type
        return true
}</span>

// Equals checks if two unknown types are equal
func (ut *UnknownType) Equals(other VexType) bool <span class="cov0" title="0">{
        if otherUnknown, ok := other.(*UnknownType); ok </span><span class="cov0" title="0">{
                return ut.ID == otherUnknown.ID
        }</span>
        <span class="cov0" title="0">return false</span>
}

// TypeUtils provides utility functions for type operations
type TypeUtils struct{}

// InferLiteralType infers the type of a literal value
func (tu *TypeUtils) InferLiteralType(value string) VexType <span class="cov0" title="0">{
        // Remove quotes from strings
        if strings.HasPrefix(value, "\"") &amp;&amp; strings.HasSuffix(value, "\"") </span><span class="cov0" title="0">{
                return StringType
        }</span>

        // Check if it's a number
        <span class="cov0" title="0">if isInteger(value) </span><span class="cov0" title="0">{
                return IntType
        }</span>

        <span class="cov0" title="0">if isFloat(value) </span><span class="cov0" title="0">{
                return FloatType
        }</span>

        // Check boolean
        <span class="cov0" title="0">if value == "true" || value == "false" </span><span class="cov0" title="0">{
                return BoolType
        }</span>

        // Default to symbol type for identifiers
        <span class="cov0" title="0">return SymbolType</span>
}

// isInteger checks if a string represents an integer
func isInteger(s string) bool <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Handle negative numbers
        <span class="cov0" title="0">start := 0
        if s[0] == '-' || s[0] == '+' </span><span class="cov0" title="0">{
                start = 1
                if len(s) == 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">for i := start; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                if s[i] &lt; '0' || s[i] &gt; '9' </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// isFloat checks if a string represents a floating-point number
func isFloat(s string) bool <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">dotCount := 0
        start := 0

        // Handle negative numbers
        if s[0] == '-' || s[0] == '+' </span><span class="cov0" title="0">{
                start = 1
                if len(s) == 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">for i := start; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                if s[i] == '.' </span><span class="cov0" title="0">{
                        dotCount++
                        if dotCount &gt; 1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                } else<span class="cov0" title="0"> if s[i] &lt; '0' || s[i] &gt; '9' </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return dotCount == 1</span> // Must have exactly one dot to be a float
}

// GetTypeKind returns the kind of a given type
func (tu *TypeUtils) GetTypeKind(vexType VexType) TypeKind <span class="cov0" title="0">{
        switch vexType.(type) </span>{
        case *PrimitiveType:<span class="cov0" title="0">
                return TypeKindPrimitive</span>
        case *ListType:<span class="cov0" title="0">
                return TypeKindList</span>
        case *MapType:<span class="cov0" title="0">
                return TypeKindMap</span>
        case *FunctionType:<span class="cov0" title="0">
                return TypeKindFunction</span>
        case *GenericType:<span class="cov0" title="0">
                return TypeKindGeneric</span>
        case *UnknownType:<span class="cov0" title="0">
                return TypeKindUnknown</span>
        default:<span class="cov0" title="0">
                return TypeKindUnknown</span>
        }
}

// UnifyTypes attempts to unify two types, returning the most specific common type
func (tu *TypeUtils) UnifyTypes(type1, type2 VexType) (VexType, error) <span class="cov0" title="0">{
        // If either type is unknown, return the other
        if _, ok := type1.(*UnknownType); ok </span><span class="cov0" title="0">{
                return type2, nil
        }</span>
        <span class="cov0" title="0">if _, ok := type2.(*UnknownType); ok </span><span class="cov0" title="0">{
                return type1, nil
        }</span>

        // If types are equal, return either one
        <span class="cov0" title="0">if type1.Equals(type2) </span><span class="cov0" title="0">{
                return type1, nil
        }</span>

        // Handle specific unification cases
        <span class="cov0" title="0">if reflect.TypeOf(type1) == reflect.TypeOf(type2) </span><span class="cov0" title="0">{
                switch t1 := type1.(type) </span>{
                case *ListType:<span class="cov0" title="0">
                        t2 := type2.(*ListType)
                        unifiedElement, err := tu.UnifyTypes(t1.ElementType, t2.ElementType)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return NewListType(unifiedElement), nil</span>

                case *MapType:<span class="cov0" title="0">
                        t2 := type2.(*MapType)
                        unifiedKey, err := tu.UnifyTypes(t1.KeyType, t2.KeyType)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">unifiedValue, err := tu.UnifyTypes(t1.ValueType, t2.ValueType)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return NewMapType(unifiedKey, unifiedValue), nil</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("cannot unify types %s and %s", type1.String(), type2.String())</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated from Vex.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // Vex

import "github.com/antlr4-go/antlr/v4"

// BaseVexListener is a complete listener for a parse tree produced by VexParser.
type BaseVexListener struct{}

var _ VexListener = &amp;BaseVexListener{}

// VisitTerminal is called when a terminal node is visited.
func (s *BaseVexListener) VisitTerminal(node antlr.TerminalNode) {<span class="cov0" title="0">}</span>

// VisitErrorNode is called when an error node is visited.
func (s *BaseVexListener) VisitErrorNode(node antlr.ErrorNode) {<span class="cov0" title="0">}</span>

// EnterEveryRule is called when any rule is entered.
func (s *BaseVexListener) EnterEveryRule(ctx antlr.ParserRuleContext) {<span class="cov0" title="0">}</span>

// ExitEveryRule is called when any rule is exited.
func (s *BaseVexListener) ExitEveryRule(ctx antlr.ParserRuleContext) {<span class="cov0" title="0">}</span>

// EnterProgram is called when production program is entered.
func (s *BaseVexListener) EnterProgram(ctx *ProgramContext) {<span class="cov0" title="0">}</span>

// ExitProgram is called when production program is exited.
func (s *BaseVexListener) ExitProgram(ctx *ProgramContext) {<span class="cov0" title="0">}</span>

// EnterList is called when production list is entered.
func (s *BaseVexListener) EnterList(ctx *ListContext) {<span class="cov0" title="0">}</span>

// ExitList is called when production list is exited.
func (s *BaseVexListener) ExitList(ctx *ListContext) {<span class="cov0" title="0">}</span>

// EnterArray is called when production array is entered.
func (s *BaseVexListener) EnterArray(ctx *ArrayContext) {<span class="cov0" title="0">}</span>

// ExitArray is called when production array is exited.
func (s *BaseVexListener) ExitArray(ctx *ArrayContext) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated from Vex.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // Vex

import "github.com/antlr4-go/antlr/v4"

type BaseVexVisitor struct {
        *antlr.BaseParseTreeVisitor
}

func (v *BaseVexVisitor) VisitProgram(ctx *ProgramContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseVexVisitor) VisitList(ctx *ListContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseVexVisitor) VisitArray(ctx *ArrayContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated from Vex.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser

import (
        "fmt"
        "github.com/antlr4-go/antlr/v4"
        "sync"
        "unicode"
)

// Suppress unused import error
var _ = fmt.Printf
var _ = sync.Once{}
var _ = unicode.IsLetter

type VexLexer struct {
        *antlr.BaseLexer
        channelNames []string
        modeNames    []string
        // TODO: EOF string
}

var VexLexerLexerStaticData struct {
        once                   sync.Once
        serializedATN          []int32
        ChannelNames           []string
        ModeNames              []string
        LiteralNames           []string
        SymbolicNames          []string
        RuleNames              []string
        PredictionContextCache *antlr.PredictionContextCache
        atn                    *antlr.ATN
        decisionToDFA          []*antlr.DFA
}

func vexlexerLexerInit() <span class="cov0" title="0">{
        staticData := &amp;VexLexerLexerStaticData
        staticData.ChannelNames = []string{
                "DEFAULT_TOKEN_CHANNEL", "HIDDEN",
        }
        staticData.ModeNames = []string{
                "DEFAULT_MODE",
        }
        staticData.LiteralNames = []string{
                "", "'('", "')'", "'['", "']'",
        }
        staticData.SymbolicNames = []string{
                "", "", "", "", "", "SYMBOL", "STRING", "LETTER", "INTEGER", "TRASH",
        }
        staticData.RuleNames = []string{
                "T__0", "T__1", "T__2", "T__3", "SYMBOL", "STRING", "LETTER", "INTEGER",
                "SEPARATOR", "WS", "COMMENT", "TRASH",
        }
        staticData.PredictionContextCache = antlr.NewPredictionContextCache()
        staticData.serializedATN = []int32{
                4, 0, 9, 73, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2,
                4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2,
                10, 7, 10, 2, 11, 7, 11, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3,
                1, 4, 1, 4, 1, 4, 4, 4, 37, 8, 4, 11, 4, 12, 4, 38, 1, 5, 1, 5, 1, 5, 1,
                5, 5, 5, 45, 8, 5, 10, 5, 12, 5, 48, 9, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7,
                1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 10, 1, 10, 5, 10, 62, 8, 10, 10, 10, 12,
                10, 65, 9, 10, 1, 11, 1, 11, 1, 11, 3, 11, 70, 8, 11, 1, 11, 1, 11, 0,
                0, 12, 1, 1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8, 17, 0, 19, 0,
                21, 0, 23, 9, 1, 0, 7, 7, 0, 33, 33, 42, 43, 45, 47, 58, 58, 60, 63, 95,
                95, 126, 126, 1, 0, 34, 34, 2, 0, 65, 90, 97, 122, 1, 0, 48, 57, 2, 0,
                32, 32, 44, 44, 4, 0, 9, 10, 13, 13, 32, 32, 44, 44, 2, 0, 10, 10, 13,
                13, 77, 0, 1, 1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1,
                0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 13, 1, 0, 0, 0, 0, 15,
                1, 0, 0, 0, 0, 23, 1, 0, 0, 0, 1, 25, 1, 0, 0, 0, 3, 27, 1, 0, 0, 0, 5,
                29, 1, 0, 0, 0, 7, 31, 1, 0, 0, 0, 9, 36, 1, 0, 0, 0, 11, 40, 1, 0, 0,
                0, 13, 51, 1, 0, 0, 0, 15, 53, 1, 0, 0, 0, 17, 55, 1, 0, 0, 0, 19, 57,
                1, 0, 0, 0, 21, 59, 1, 0, 0, 0, 23, 69, 1, 0, 0, 0, 25, 26, 5, 40, 0, 0,
                26, 2, 1, 0, 0, 0, 27, 28, 5, 41, 0, 0, 28, 4, 1, 0, 0, 0, 29, 30, 5, 91,
                0, 0, 30, 6, 1, 0, 0, 0, 31, 32, 5, 93, 0, 0, 32, 8, 1, 0, 0, 0, 33, 37,
                3, 13, 6, 0, 34, 37, 3, 15, 7, 0, 35, 37, 7, 0, 0, 0, 36, 33, 1, 0, 0,
                0, 36, 34, 1, 0, 0, 0, 36, 35, 1, 0, 0, 0, 37, 38, 1, 0, 0, 0, 38, 36,
                1, 0, 0, 0, 38, 39, 1, 0, 0, 0, 39, 10, 1, 0, 0, 0, 40, 46, 5, 34, 0, 0,
                41, 45, 8, 1, 0, 0, 42, 43, 5, 92, 0, 0, 43, 45, 5, 34, 0, 0, 44, 41, 1,
                0, 0, 0, 44, 42, 1, 0, 0, 0, 45, 48, 1, 0, 0, 0, 46, 44, 1, 0, 0, 0, 46,
                47, 1, 0, 0, 0, 47, 49, 1, 0, 0, 0, 48, 46, 1, 0, 0, 0, 49, 50, 5, 34,
                0, 0, 50, 12, 1, 0, 0, 0, 51, 52, 7, 2, 0, 0, 52, 14, 1, 0, 0, 0, 53, 54,
                7, 3, 0, 0, 54, 16, 1, 0, 0, 0, 55, 56, 7, 4, 0, 0, 56, 18, 1, 0, 0, 0,
                57, 58, 7, 5, 0, 0, 58, 20, 1, 0, 0, 0, 59, 63, 5, 59, 0, 0, 60, 62, 8,
                6, 0, 0, 61, 60, 1, 0, 0, 0, 62, 65, 1, 0, 0, 0, 63, 61, 1, 0, 0, 0, 63,
                64, 1, 0, 0, 0, 64, 22, 1, 0, 0, 0, 65, 63, 1, 0, 0, 0, 66, 70, 3, 19,
                9, 0, 67, 70, 3, 21, 10, 0, 68, 70, 3, 17, 8, 0, 69, 66, 1, 0, 0, 0, 69,
                67, 1, 0, 0, 0, 69, 68, 1, 0, 0, 0, 70, 71, 1, 0, 0, 0, 71, 72, 6, 11,
                0, 0, 72, 24, 1, 0, 0, 0, 7, 0, 36, 38, 44, 46, 63, 69, 1, 0, 1, 0,
        }
        deserializer := antlr.NewATNDeserializer(nil)
        staticData.atn = deserializer.Deserialize(staticData.serializedATN)
        atn := staticData.atn
        staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
        decisionToDFA := staticData.decisionToDFA
        for index, state := range atn.DecisionToState </span><span class="cov0" title="0">{
                decisionToDFA[index] = antlr.NewDFA(state, index)
        }</span>
}

// VexLexerInit initializes any static state used to implement VexLexer. By default the
// static state used to implement the lexer is lazily initialized during the first call to
// NewVexLexer(). You can call this function if you wish to initialize the static state ahead
// of time.
func VexLexerInit() <span class="cov0" title="0">{
        staticData := &amp;VexLexerLexerStaticData
        staticData.once.Do(vexlexerLexerInit)
}</span>

// NewVexLexer produces a new lexer instance for the optional input antlr.CharStream.
func NewVexLexer(input antlr.CharStream) *VexLexer <span class="cov0" title="0">{
        VexLexerInit()
        l := new(VexLexer)
        l.BaseLexer = antlr.NewBaseLexer(input)
        staticData := &amp;VexLexerLexerStaticData
        l.Interpreter = antlr.NewLexerATNSimulator(l, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
        l.channelNames = staticData.ChannelNames
        l.modeNames = staticData.ModeNames
        l.RuleNames = staticData.RuleNames
        l.LiteralNames = staticData.LiteralNames
        l.SymbolicNames = staticData.SymbolicNames
        l.GrammarFileName = "Vex.g4"
        // TODO: l.EOF = antlr.TokenEOF

        return l
}</span>

// VexLexer tokens.
const (
        VexLexerT__0    = 1
        VexLexerT__1    = 2
        VexLexerT__2    = 3
        VexLexerT__3    = 4
        VexLexerSYMBOL  = 5
        VexLexerSTRING  = 6
        VexLexerLETTER  = 7
        VexLexerINTEGER = 8
        VexLexerTRASH   = 9
)
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated from Vex.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // Vex

import (
        "fmt"
        "strconv"
        "sync"

        "github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type VexParser struct {
        *antlr.BaseParser
}

var VexParserStaticData struct {
        once                   sync.Once
        serializedATN          []int32
        LiteralNames           []string
        SymbolicNames          []string
        RuleNames              []string
        PredictionContextCache *antlr.PredictionContextCache
        atn                    *antlr.ATN
        decisionToDFA          []*antlr.DFA
}

func vexParserInit() <span class="cov0" title="0">{
        staticData := &amp;VexParserStaticData
        staticData.LiteralNames = []string{
                "", "'('", "')'", "'['", "']'",
        }
        staticData.SymbolicNames = []string{
                "", "", "", "", "", "SYMBOL", "STRING", "LETTER", "INTEGER", "TRASH",
        }
        staticData.RuleNames = []string{
                "program", "list", "array",
        }
        staticData.PredictionContextCache = antlr.NewPredictionContextCache()
        staticData.serializedATN = []int32{
                4, 1, 9, 36, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 1, 0, 4, 0, 8, 8, 0, 11,
                0, 12, 0, 9, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 19, 8, 1,
                11, 1, 12, 1, 20, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 4, 2, 30, 8,
                2, 11, 2, 12, 2, 31, 1, 2, 1, 2, 1, 2, 0, 0, 3, 0, 2, 4, 0, 0, 41, 0, 7,
                1, 0, 0, 0, 2, 13, 1, 0, 0, 0, 4, 24, 1, 0, 0, 0, 6, 8, 3, 2, 1, 0, 7,
                6, 1, 0, 0, 0, 8, 9, 1, 0, 0, 0, 9, 7, 1, 0, 0, 0, 9, 10, 1, 0, 0, 0, 10,
                11, 1, 0, 0, 0, 11, 12, 5, 0, 0, 1, 12, 1, 1, 0, 0, 0, 13, 18, 5, 1, 0,
                0, 14, 19, 3, 4, 2, 0, 15, 19, 3, 2, 1, 0, 16, 19, 5, 5, 0, 0, 17, 19,
                5, 6, 0, 0, 18, 14, 1, 0, 0, 0, 18, 15, 1, 0, 0, 0, 18, 16, 1, 0, 0, 0,
                18, 17, 1, 0, 0, 0, 19, 20, 1, 0, 0, 0, 20, 18, 1, 0, 0, 0, 20, 21, 1,
                0, 0, 0, 21, 22, 1, 0, 0, 0, 22, 23, 5, 2, 0, 0, 23, 3, 1, 0, 0, 0, 24,
                29, 5, 3, 0, 0, 25, 30, 3, 4, 2, 0, 26, 30, 3, 2, 1, 0, 27, 30, 5, 5, 0,
                0, 28, 30, 5, 6, 0, 0, 29, 25, 1, 0, 0, 0, 29, 26, 1, 0, 0, 0, 29, 27,
                1, 0, 0, 0, 29, 28, 1, 0, 0, 0, 30, 31, 1, 0, 0, 0, 31, 29, 1, 0, 0, 0,
                31, 32, 1, 0, 0, 0, 32, 33, 1, 0, 0, 0, 33, 34, 5, 4, 0, 0, 34, 5, 1, 0,
                0, 0, 5, 9, 18, 20, 29, 31,
        }
        deserializer := antlr.NewATNDeserializer(nil)
        staticData.atn = deserializer.Deserialize(staticData.serializedATN)
        atn := staticData.atn
        staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
        decisionToDFA := staticData.decisionToDFA
        for index, state := range atn.DecisionToState </span><span class="cov0" title="0">{
                decisionToDFA[index] = antlr.NewDFA(state, index)
        }</span>
}

// VexParserInit initializes any static state used to implement VexParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewVexParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func VexParserInit() <span class="cov0" title="0">{
        staticData := &amp;VexParserStaticData
        staticData.once.Do(vexParserInit)
}</span>

// NewVexParser produces a new parser instance for the optional input antlr.TokenStream.
func NewVexParser(input antlr.TokenStream) *VexParser <span class="cov0" title="0">{
        VexParserInit()
        this := new(VexParser)
        this.BaseParser = antlr.NewBaseParser(input)
        staticData := &amp;VexParserStaticData
        this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
        this.RuleNames = staticData.RuleNames
        this.LiteralNames = staticData.LiteralNames
        this.SymbolicNames = staticData.SymbolicNames
        this.GrammarFileName = "Vex.g4"

        return this
}</span>

// VexParser tokens.
const (
        VexParserEOF     = antlr.TokenEOF
        VexParserT__0    = 1
        VexParserT__1    = 2
        VexParserT__2    = 3
        VexParserT__3    = 4
        VexParserSYMBOL  = 5
        VexParserSTRING  = 6
        VexParserLETTER  = 7
        VexParserINTEGER = 8
        VexParserTRASH   = 9
)

// VexParser rules.
const (
        VexParserRULE_program = 0
        VexParserRULE_list    = 1
        VexParserRULE_array   = 2
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        EOF() antlr.TerminalNode
        AllList() []IListContext
        List(i int) IListContext

        // IsProgramContext differentiates from other interfaces.
        IsProgramContext()
}

type ProgramContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext <span class="cov0" title="0">{
        var p = new(ProgramContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_program
        return p
}</span>

func InitEmptyProgramContext(p *ProgramContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_program
}</span>

func (*ProgramContext) IsProgramContext() {<span class="cov0" title="0">}</span>

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext <span class="cov0" title="0">{
        var p = new(ProgramContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = VexParserRULE_program

        return p
}</span>

func (s *ProgramContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ProgramContext) EOF() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserEOF, 0)
}</span>

func (s *ProgramContext) AllList() []IListContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IListContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IListContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ProgramContext) List(i int) IListContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IListContext)</span>
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterProgram(s)
        }</span>
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitProgram(s)
        }</span>
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case VexVisitor:<span class="cov0" title="0">
                return t.VisitProgram(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *VexParser) Program() (localctx IProgramContext) <span class="cov0" title="0">{
        localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 0, VexParserRULE_program)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(7)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

        for ok := true; ok; ok = _la == VexParserT__0 </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(6)
                        p.List()
                }</span>

                <span class="cov0" title="0">p.SetState(9)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov0" title="0">{
                p.SetState(11)
                p.Match(VexParserEOF)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov0" title="0">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov0" title="0">p.ExitRule()
        return localctx</span>
}

// IListContext is an interface to support dynamic dispatch.
type IListContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        AllArray() []IArrayContext
        Array(i int) IArrayContext
        AllList() []IListContext
        List(i int) IListContext
        AllSYMBOL() []antlr.TerminalNode
        SYMBOL(i int) antlr.TerminalNode
        AllSTRING() []antlr.TerminalNode
        STRING(i int) antlr.TerminalNode

        // IsListContext differentiates from other interfaces.
        IsListContext()
}

type ListContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyListContext() *ListContext <span class="cov0" title="0">{
        var p = new(ListContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_list
        return p
}</span>

func InitEmptyListContext(p *ListContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_list
}</span>

func (*ListContext) IsListContext() {<span class="cov0" title="0">}</span>

func NewListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListContext <span class="cov0" title="0">{
        var p = new(ListContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = VexParserRULE_list

        return p
}</span>

func (s *ListContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ListContext) AllArray() []IArrayContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IArrayContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IArrayContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ListContext) Array(i int) IArrayContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IArrayContext)</span>
}

func (s *ListContext) AllList() []IListContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IListContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IListContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ListContext) List(i int) IListContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IListContext)</span>
}

func (s *ListContext) AllSYMBOL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(VexParserSYMBOL)
}</span>

func (s *ListContext) SYMBOL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserSYMBOL, i)
}</span>

func (s *ListContext) AllSTRING() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(VexParserSTRING)
}</span>

func (s *ListContext) STRING(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserSTRING, i)
}</span>

func (s *ListContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ListContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterList(s)
        }</span>
}

func (s *ListContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitList(s)
        }</span>
}

func (s *ListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case VexVisitor:<span class="cov0" title="0">
                return t.VisitList(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *VexParser) List() (localctx IListContext) <span class="cov0" title="0">{
        localctx = NewListContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 2, VexParserRULE_list)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(13)
                p.Match(VexParserT__0)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov0" title="0">p.SetState(18)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

        for ok := true; ok; ok = ((int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;106) != 0) </span><span class="cov0" title="0">{
                p.SetState(18)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }

                <span class="cov0" title="0">switch p.GetTokenStream().LA(1) </span>{
                case VexParserT__2:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(14)
                                p.Array()
                        }</span>

                case VexParserT__0:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(15)
                                p.List()
                        }</span>

                case VexParserSYMBOL:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(16)
                                p.Match(VexParserSYMBOL)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                case VexParserSTRING:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(17)
                                p.Match(VexParserSTRING)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                default:<span class="cov0" title="0">
                        p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                        goto errorExit</span>
                }

                <span class="cov0" title="0">p.SetState(20)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov0" title="0">{
                p.SetState(22)
                p.Match(VexParserT__1)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov0" title="0">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov0" title="0">p.ExitRule()
        return localctx</span>
}

// IArrayContext is an interface to support dynamic dispatch.
type IArrayContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        AllArray() []IArrayContext
        Array(i int) IArrayContext
        AllList() []IListContext
        List(i int) IListContext
        AllSYMBOL() []antlr.TerminalNode
        SYMBOL(i int) antlr.TerminalNode
        AllSTRING() []antlr.TerminalNode
        STRING(i int) antlr.TerminalNode

        // IsArrayContext differentiates from other interfaces.
        IsArrayContext()
}

type ArrayContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyArrayContext() *ArrayContext <span class="cov0" title="0">{
        var p = new(ArrayContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_array
        return p
}</span>

func InitEmptyArrayContext(p *ArrayContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = VexParserRULE_array
}</span>

func (*ArrayContext) IsArrayContext() {<span class="cov0" title="0">}</span>

func NewArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayContext <span class="cov0" title="0">{
        var p = new(ArrayContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = VexParserRULE_array

        return p
}</span>

func (s *ArrayContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ArrayContext) AllArray() []IArrayContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IArrayContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IArrayContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ArrayContext) Array(i int) IArrayContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArrayContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IArrayContext)</span>
}

func (s *ArrayContext) AllList() []IListContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IListContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IListContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ArrayContext) List(i int) IListContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IListContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IListContext)</span>
}

func (s *ArrayContext) AllSYMBOL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(VexParserSYMBOL)
}</span>

func (s *ArrayContext) SYMBOL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserSYMBOL, i)
}</span>

func (s *ArrayContext) AllSTRING() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(VexParserSTRING)
}</span>

func (s *ArrayContext) STRING(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(VexParserSTRING, i)
}</span>

func (s *ArrayContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ArrayContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterArray(s)
        }</span>
}

func (s *ArrayContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(VexListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitArray(s)
        }</span>
}

func (s *ArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case VexVisitor:<span class="cov0" title="0">
                return t.VisitArray(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *VexParser) Array() (localctx IArrayContext) <span class="cov0" title="0">{
        localctx = NewArrayContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 4, VexParserRULE_array)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(24)
                p.Match(VexParserT__2)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov0" title="0">p.SetState(29)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

        for ok := true; ok; ok = ((int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;106) != 0) </span><span class="cov0" title="0">{
                p.SetState(29)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }

                <span class="cov0" title="0">switch p.GetTokenStream().LA(1) </span>{
                case VexParserT__2:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(25)
                                p.Array()
                        }</span>

                case VexParserT__0:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(26)
                                p.List()
                        }</span>

                case VexParserSYMBOL:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(27)
                                p.Match(VexParserSYMBOL)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                case VexParserSTRING:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(28)
                                p.Match(VexParserSTRING)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                default:<span class="cov0" title="0">
                        p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                        goto errorExit</span>
                }

                <span class="cov0" title="0">p.SetState(31)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov0" title="0">{
                p.SetState(33)
                p.Match(VexParserT__3)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov0" title="0">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov0" title="0">p.ExitRule()
        return localctx</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
