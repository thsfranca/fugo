
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>vex-transpiler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/thsfranca/vex/cmd/vex-transpiler/main.go (23.9%)</option>
				
				<option value="file1">github.com/thsfranca/vex/internal/transpiler/transpiler.go (77.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "flag"
        "fmt"
        "io/ioutil"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "github.com/thsfranca/vex/internal/transpiler"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">command := os.Args[1]
        switch command </span>{
        case "transpile":<span class="cov0" title="0">
                transpileCommand(os.Args[2:])</span>
        case "run":<span class="cov0" title="0">
                runCommand(os.Args[2:])</span>
        case "exec":<span class="cov0" title="0">
                execCommand(os.Args[2:])</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown command: %s\n\n", command)
                printUsage()
                os.Exit(1)</span>
        }
}

func printUsage() <span class="cov1" title="1">{
        fmt.Fprintf(os.Stderr, "Vex - A statically-typed functional programming language\n\n")
        fmt.Fprintf(os.Stderr, "Usage:\n")
        fmt.Fprintf(os.Stderr, "  vex transpile -input &lt;file.vex&gt; [-output &lt;file.go&gt;] [-verbose]\n")
        fmt.Fprintf(os.Stderr, "  vex run -input &lt;file.vex&gt; [-verbose]\n")
        fmt.Fprintf(os.Stderr, "  vex exec &lt;file.vex&gt; [-verbose]\n\n")
        fmt.Fprintf(os.Stderr, "Commands:\n")
        fmt.Fprintf(os.Stderr, "  transpile  Transpile Vex source code to Go\n")
        fmt.Fprintf(os.Stderr, "  run        Transpile and run Vex source code\n")
        fmt.Fprintf(os.Stderr, "  exec       Execute Vex file directly (includes core.vx)\n\n")
        fmt.Fprintf(os.Stderr, "Examples:\n")
        fmt.Fprintf(os.Stderr, "  vex transpile -input example.vex -output example.go\n")
        fmt.Fprintf(os.Stderr, "  vex run -input example.vex\n")
        fmt.Fprintf(os.Stderr, "  vex exec example.vex\n")
}</span>

func transpileCommand(args []string) <span class="cov0" title="0">{
        transpileFlags := flag.NewFlagSet("transpile", flag.ExitOnError)
        var (
                inputFile  = transpileFlags.String("input", "", "Input .vex file to transpile")
                outputFile = transpileFlags.String("output", "", "Output .go file (optional, defaults to stdout)")
                verbose    = transpileFlags.Bool("verbose", false, "Enable verbose output")
        )
        transpileFlags.Parse(args)

        if *inputFile == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: -input flag is required\n\n")
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "üîÑ Transpiling: %s\n", *inputFile)
        }</span>

        // Read input file
        <span class="cov0" title="0">content, err := ioutil.ReadFile(*inputFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error reading file %s: %v\n", *inputFile, err)
                os.Exit(1)
        }</span>

        // Create transpiler
        <span class="cov0" title="0">t := transpiler.New()

        // Transpile
        goCode, err := t.TranspileFromInput(string(content))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Transpilation error: %v\n", err)
                os.Exit(1)
        }</span>

        // Output result
        <span class="cov0" title="0">if *outputFile != "" </span><span class="cov0" title="0">{
                err = ioutil.WriteFile(*outputFile, []byte(goCode), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Error writing output file %s: %v\n", *outputFile, err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚úÖ Transpilation complete: %s\n", *outputFile)
                }</span>
        } else<span class="cov0" title="0"> {
                // Output to stdout
                fmt.Print(goCode)
        }</span>
}

func runCommand(args []string) <span class="cov0" title="0">{
        runFlags := flag.NewFlagSet("run", flag.ExitOnError)
        var (
                inputFile = runFlags.String("input", "", "Input .vex file to run")
                verbose   = runFlags.Bool("verbose", false, "Enable verbose output")
        )
        runFlags.Parse(args)

        if *inputFile == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: -input flag is required\n\n")
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "üöÄ Running Vex file: %s\n", *inputFile)
        }</span>

        // Read input file
        <span class="cov0" title="0">content, err := ioutil.ReadFile(*inputFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error reading file %s: %v\n", *inputFile, err)
                os.Exit(1)
        }</span>

        // Create transpiler
        <span class="cov0" title="0">t := transpiler.New()

        // Transpile
        goCode, err := t.TranspileFromInput(string(content))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Transpilation error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "üîÑ Transpilation complete, executing...\n")
        }</span>

        // Create temporary file for Go code
        <span class="cov0" title="0">tmpDir := os.TempDir()
        baseName := strings.TrimSuffix(filepath.Base(*inputFile), filepath.Ext(*inputFile))
        tmpGoFile := filepath.Join(tmpDir, baseName+"_temp.go")

        // Write Go code to temporary file
        err = ioutil.WriteFile(tmpGoFile, []byte(goCode), 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error writing temporary Go file: %v\n", err)
                os.Exit(1)
        }</span>

        // Clean up temporary file when done
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := os.Remove(tmpGoFile); err != nil &amp;&amp; *verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ö†Ô∏è  Warning: could not remove temporary file %s: %v\n", tmpGoFile, err)
                }</span>
        }()

        // Run the Go code
        // Note: Go will complain about unused variables, but the code will compile if syntax is correct
        <span class="cov0" title="0">cmd := exec.Command("go", "build", "-o", strings.TrimSuffix(tmpGoFile, ".go"), tmpGoFile)
        var buildErr error
        buildOutput, buildErr := cmd.CombinedOutput()

        if buildErr != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Build error: %v\n%s", buildErr, string(buildOutput))
                os.Exit(1)
        }</span>

        // If build succeeded, run the executable
        <span class="cov0" title="0">executable := strings.TrimSuffix(tmpGoFile, ".go")
        defer os.Remove(executable) // Clean up executable

        runCmd := exec.Command(executable)
        runCmd.Stdout = os.Stdout
        runCmd.Stderr = os.Stderr

        err = runCmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Execution error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚úÖ Execution complete\n")
        }</span>
}

func execCommand(args []string) <span class="cov0" title="0">{
        execFlags := flag.NewFlagSet("exec", flag.ExitOnError)
        var (
                verbose = execFlags.Bool("verbose", false, "Enable verbose output")
        )
        execFlags.Parse(args)

        // Get input file from remaining args
        remainingArgs := execFlags.Args()
        if len(remainingArgs) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: input file is required\n\n")
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">inputFile := remainingArgs[0]

        if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "üöÄ Executing Vex file: %s\n", inputFile)
        }</span>

        // Load core.vx if it exists
        <span class="cov0" title="0">coreContent := loadCoreVex(*verbose)

        // Read user input file
        userContent, err := ioutil.ReadFile(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error reading file %s: %v\n", inputFile, err)
                os.Exit(1)
        }</span>

        // Combine core + user code
        <span class="cov0" title="0">fullProgram := coreContent + "\n" + string(userContent)

        // Create transpiler
        t := transpiler.New()

        // Transpile combined program
        goCode, err := t.TranspileFromInput(fullProgram)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Transpilation error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "üîÑ Transpilation complete, executing...\n")
                fmt.Fprintf(os.Stderr, "Generated Go code:\n%s\n", goCode)
        }</span>

        // Create .vex directory structure
        <span class="cov0" title="0">vexDir := ".vex"
        genDir := filepath.Join(vexDir, "gen")
        binDir := filepath.Join(vexDir, "bin")
        
        if err := os.MkdirAll(genDir, 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error creating .vex directory: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(binDir, 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error creating .vex/bin directory: %v\n", err)
                os.Exit(1)
        }</span>

        // Generate go.mod with detected dependencies
        <span class="cov0" title="0">detectedModules := t.GetDetectedModules()
        if err := generateGoMod(vexDir, detectedModules, *verbose); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error generating go.mod: %v\n", err)
                os.Exit(1)
        }</span>

        // Write Go code to .vex/gen/main.go
        <span class="cov0" title="0">mainGoFile := filepath.Join(genDir, "main.go")
        if err := ioutil.WriteFile(mainGoFile, []byte(goCode), 0644); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error writing Go file: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "üìÅ Generated Go module in %s/\n", vexDir)
        }</span>

        // Download dependencies
        <span class="cov0" title="0">if len(detectedModules) &gt; 0 </span><span class="cov0" title="0">{
                if *verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "üì¶ Downloading dependencies...\n")
                }</span>
                <span class="cov0" title="0">if err := downloadDependencies(vexDir, *verbose); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Error downloading dependencies: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        // Build binary
        <span class="cov0" title="0">binaryPath := filepath.Join(binDir, "app")
        if err := buildBinary(vexDir, genDir, binaryPath, *verbose); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Build error: %v\n", err)
                os.Exit(1)
        }</span>

        // Execute binary (use absolute path)
        <span class="cov0" title="0">absBinaryPath, err := filepath.Abs(binaryPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå Error getting absolute path: %v\n", err)
                os.Exit(1)
        }</span>
        
        <span class="cov0" title="0">cmd := exec.Command(absBinaryPath)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                if *verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Execution error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚úÖ Execution complete\n")
        }</span>
}

func loadCoreVex(verbose bool) string <span class="cov8" title="5">{
        // Try to load core.vx from current directory
        coreContent, err := ioutil.ReadFile("core.vx")
        if err != nil </span><span class="cov1" title="1">{
                if verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ÑπÔ∏è  core.vx not found, using minimal bootstrap\n")
                }</span>
                // Return minimal bootstrap if core.vx doesn't exist
                <span class="cov1" title="1">return `; Minimal Vex bootstrap`</span>
        }

        <span class="cov7" title="4">if verbose </span><span class="cov4" title="2">{
                fmt.Fprintf(os.Stderr, "üìö Loaded core.vx standard library\n")
        }</span>
        <span class="cov7" title="4">return string(coreContent)</span>
}

func generateGoMod(vexDir string, modules map[string]string, verbose bool) error <span class="cov7" title="4">{
        goModPath := filepath.Join(vexDir, "go.mod")
        
        // Create basic go.mod
        content := fmt.Sprintf("module vex-project-%d\n\ngo 1.21\n", time.Now().Unix())
        
        // Add detected dependencies
        if len(modules) &gt; 0 </span><span class="cov6" title="3">{
                content += "\nrequire (\n"
                for module, version := range modules </span><span class="cov10" title="7">{
                        // For "latest", let go mod tidy resolve the version
                        content += fmt.Sprintf("\t%s %s\n", module, version)
                }</span>
                <span class="cov6" title="3">content += ")\n"
                
                if verbose </span><span class="cov1" title="1">{
                        fmt.Fprintf(os.Stderr, "üì¶ Added dependencies: %v\n", modules)
                }</span>
        }
        
        <span class="cov7" title="4">return ioutil.WriteFile(goModPath, []byte(content), 0644)</span>
}

func downloadDependencies(vexDir string, verbose bool) error <span class="cov4" title="2">{
        cmd := exec.Command("go", "mod", "tidy")
        cmd.Dir = vexDir
        
        if verbose </span><span class="cov1" title="1">{
                cmd.Stdout = os.Stderr
                cmd.Stderr = os.Stderr
        }</span>
        
        <span class="cov4" title="2">return cmd.Run()</span>
}

func buildBinary(vexDir, genDir, binaryPath string, verbose bool) error <span class="cov4" title="2">{
        // Build from the module directory using the relative path to main.go
        relativeMainPath := "./gen/main.go"
        relativeBinaryPath := "./bin/app" // Use relative path for output too
        
        cmd := exec.Command("go", "build", "-o", relativeBinaryPath, relativeMainPath)
        cmd.Dir = vexDir
        
        if verbose </span><span class="cov1" title="1">{
                cmd.Stdout = os.Stderr
                cmd.Stderr = os.Stderr
                fmt.Fprintf(os.Stderr, "üî® Building binary: go build -o %s %s (in %s)\n", relativeBinaryPath, relativeMainPath, vexDir)
        }</span>
        
        // Always capture stderr for error reporting
        <span class="cov4" title="2">var stderr bytes.Buffer
        if !verbose </span><span class="cov1" title="1">{
                cmd.Stderr = &amp;stderr
        }</span>
        
        <span class="cov4" title="2">if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        return fmt.Errorf("build failed: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("build failed: %v\n%s", err, stderr.String())
                }</span>
        }
        
        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package transpiler provides a minimal Vex to Go transpiler
package transpiler

import (
        "fmt"
        "os"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// Transpiler converts Vex code to Go code
type Transpiler struct {
        output     strings.Builder
        imports    map[string]bool
        goModules  map[string]string // Track third-party modules for go.mod
}

// New creates a new transpiler instance
func New() *Transpiler <span class="cov7" title="39">{
        return &amp;Transpiler{
                imports:   make(map[string]bool),
                goModules: make(map[string]string),
        }
}</span>

// TranspileFromInput transpiles Vex source code to Go
func (t *Transpiler) TranspileFromInput(input string) (string, error) <span class="cov7" title="36">{
        // Parse the input
        inputStream := antlr.NewInputStream(input)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)

        // Parse the program
        tree := vexParser.Program()

        // Reset output, imports, and modules
        t.output.Reset()
        t.imports = make(map[string]bool)
        t.goModules = make(map[string]string)
        
        // Generate Go code
        if programCtx, ok := tree.(*parser.ProgramContext); ok </span><span class="cov7" title="36">{
                t.visitProgram(programCtx)
        }</span>
        
        <span class="cov7" title="36">return t.generateGoCode(), nil</span>
}

// TranspileFromFile transpiles a Vex file to Go
func (t *Transpiler) TranspileFromFile(filename string) (string, error) <span class="cov2" title="2">{
        // Read the file content
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("error reading file %s: %v", filename, err)
        }</span>
        
        // Use the existing TranspileFromInput method
        <span class="cov1" title="1">return t.TranspileFromInput(string(content))</span>
}

// visitProgram processes the top-level program
func (t *Transpiler) visitProgram(ctx *parser.ProgramContext) <span class="cov7" title="36">{
        lists := ctx.AllList()
        
        // Visit all lists in the program
        for i, listCtx := range lists </span><span class="cov8" title="57">{
                if concreteList, ok := listCtx.(*parser.ListContext); ok </span><span class="cov8" title="57">{
                        // For the last expression, make it the return value
                        if i == len(lists)-1 </span><span class="cov7" title="36">{
                                t.handleLastExpression(concreteList)
                        }</span> else<span class="cov6" title="21"> {
                                t.visitList(concreteList)
                        }</span>
                }
        }
}

// visitList handles list expressions (function calls, special forms)
func (t *Transpiler) visitList(ctx *parser.ListContext) <span class="cov6" title="21">{
        childCount := ctx.GetChildCount()
        if childCount &lt;= 2 </span><span class="cov0" title="0">{ // Just parentheses
                return
        }</span>

        // Get the first element (function name)
        <span class="cov6" title="21">firstChild := ctx.GetChild(1)
        if firstChild == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="21">var funcName string
        if parseTree, ok := firstChild.(antlr.ParseTree); ok </span><span class="cov6" title="21">{
                funcName = parseTree.GetText()
        }</span> else<span class="cov0" title="0"> {
                return
        }</span>

        // Extract arguments
        <span class="cov6" title="21">args := make([]string, 0)
        for i := 2; i &lt; childCount-1; i++ </span><span class="cov6" title="29">{ // Skip '(' and ')'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov6" title="29">{
                        args = append(args, t.visitNode(child))
                }</span>
        }

        // Handle special forms
        <span class="cov6" title="21">switch funcName </span>{
        case "def":<span class="cov4" title="8">
                t.handleDefinition(args)</span>
        case "import":<span class="cov5" title="13">
                t.handleImport(args)</span>
        case "if":<span class="cov0" title="0">
                t.handleIf(args)</span>
        case "do":<span class="cov0" title="0">
                t.handleDo(args)</span>
        case "first", "rest", "cons", "count", "empty?":<span class="cov0" title="0">
                t.handleCollectionOp(funcName, args)</span>
        case "+", "-", "*", "/":<span class="cov0" title="0">
                t.handleArithmetic(funcName, args)</span>
        default:<span class="cov0" title="0">
                t.handleFunctionCall(funcName, args)</span>
        }
}

// visitNode handles any AST node and returns its value
func (t *Transpiler) visitNode(node antlr.Tree) string <span class="cov9" title="140">{
        switch n := node.(type) </span>{
        case *parser.ListContext:<span class="cov5" title="15">
                // For nested lists, evaluate them and return the expression
                return t.evaluateExpression(n)</span>
        case *parser.ArrayContext:<span class="cov5" title="12">
                return t.visitArray(n)</span>
        case antlr.TerminalNode:<span class="cov9" title="113">
                return n.GetText()</span>
        default:<span class="cov0" title="0">
                if parseTree, ok := node.(antlr.ParseTree); ok </span><span class="cov0" title="0">{
                        return parseTree.GetText()
                }</span>
                <span class="cov0" title="0">return "/* unknown */"</span>
        }
}

// evaluateExpression evaluates a list as an expression and returns the result
func (t *Transpiler) evaluateExpression(ctx *parser.ListContext) string <span class="cov5" title="15">{
        childCount := ctx.GetChildCount()
        if childCount &lt;= 2 </span><span class="cov0" title="0">{ // Just parentheses
                return "nil"
        }</span>

        // Get the first element (function name)
        <span class="cov5" title="15">firstChild := ctx.GetChild(1)
        if firstChild == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>

        <span class="cov5" title="15">var funcName string
        if parseTree, ok := firstChild.(antlr.ParseTree); ok </span><span class="cov5" title="15">{
                funcName = parseTree.GetText()
        }</span> else<span class="cov0" title="0"> {
                return "nil"
        }</span>

        // Extract arguments
        <span class="cov5" title="15">args := make([]string, 0)
        for i := 2; i &lt; childCount-1; i++ </span><span class="cov6" title="19">{ // Skip '(' and ')'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov6" title="19">{
                        args = append(args, t.visitNode(child))
                }</span>
        }

        // Handle special expressions
        <span class="cov5" title="15">switch funcName </span>{
        case "if":<span class="cov1" title="1">
                return t.evaluateIf(args)</span>
        case "do":<span class="cov1" title="1">
                return t.evaluateDo(args)</span>
        case "first", "rest", "cons", "count", "empty?":<span class="cov3" title="5">
                return t.evaluateCollectionOp(funcName, args)</span>
        case "+", "-", "*", "/":<span class="cov1" title="1">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return "0"
                }</span>
                // Left-associative chaining for multiple operands
                <span class="cov1" title="1">result := "(" + args[0] + " " + funcName + " " + args[1] + ")"
                for i := 2; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        result = "(" + result + " " + funcName + " " + args[i] + ")"
                }</span>
                <span class="cov1" title="1">return result</span>
        default:<span class="cov4" title="7">
                // Handle function calls
                if strings.Contains(funcName, "/") </span><span class="cov2" title="3">{
                        funcName = strings.ReplaceAll(funcName, "/", ".")
                }</span>
                <span class="cov4" title="7">argStr := strings.Join(args, ", ")
                return fmt.Sprintf("%s(%s)", funcName, argStr)</span>
        }
}

// visitArray handles array literals
func (t *Transpiler) visitArray(ctx *parser.ArrayContext) string <span class="cov5" title="12">{
        childCount := ctx.GetChildCount()
        if childCount &lt;= 2 </span><span class="cov2" title="2">{ // Just brackets
                return "[]interface{}{}"
        }</span>

        <span class="cov5" title="10">elements := make([]string, 0)
        for i := 1; i &lt; childCount-1; i++ </span><span class="cov6" title="27">{ // Skip '[' and ']'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov6" title="27">{
                        elements = append(elements, t.visitNode(child))
                }</span>
        }

        <span class="cov5" title="10">return "[]interface{}{" + strings.Join(elements, ", ") + "}"</span>
}

// handleDefinition processes variable definitions
func (t *Transpiler) handleDefinition(args []string) <span class="cov6" title="23">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                t.output.WriteString("// Error: def requires name and value\n")
                return
        }</span>

        <span class="cov6" title="23">varName := args[0]
        varValue := args[1]

        // Generate variable definition and use it immediately (functional style)
        t.output.WriteString(fmt.Sprintf("var %s = %s\n", varName, varValue))
        t.output.WriteString(fmt.Sprintf("_ = %s // Use variable to satisfy Go compiler\n", varName))</span>
}

// handleImport processes import statements
func (t *Transpiler) handleImport(args []string) <span class="cov5" title="14">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                t.output.WriteString("// Error: import requires package path\n")
                return
        }</span>

        <span class="cov5" title="14">importPath := args[0]
        // Remove quotes if present
        importPath = strings.Trim(importPath, "\"")
        
        // Store import for later use at package level
        t.imports[importPath] = true
        
        // Track third-party modules for go.mod generation
        if t.isThirdPartyModule(importPath) </span><span class="cov3" title="4">{
                t.goModules[importPath] = "v1.0.0" // Use a reasonable default version
        }</span>
}

// isThirdPartyModule checks if an import is a third-party module
func (t *Transpiler) isThirdPartyModule(importPath string) bool <span class="cov6" title="19">{
        // Standard library packages don't need go.mod entries
        standardPkgs := []string{
                "fmt", "strings", "strconv", "time", "os", "io", "net", "http",
                "database", "encoding", "crypto", "math", "sort", "regexp",
                "context", "sync", "testing", "flag", "log", "path", "reflect",
        }
        
        for _, stdPkg := range standardPkgs </span><span class="cov10" title="161">{
                if strings.HasPrefix(importPath, stdPkg) </span><span class="cov5" title="12">{
                        return false
                }</span>
        }
        
        // If it contains a dot, it's likely a third-party module
        <span class="cov4" title="7">return strings.Contains(importPath, ".")</span>
}

// handleArithmetic processes arithmetic operations
func (t *Transpiler) handleArithmetic(op string, args []string) <span class="cov3" title="4">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                t.output.WriteString("// Error: arithmetic requires at least 2 operands\n")
                return
        }</span>

        // Left-associative chaining for multiple operands
        <span class="cov3" title="4">result := "(" + args[0] + " " + op + " " + args[1] + ")"
        for i := 2; i &lt; len(args); i++ </span><span class="cov1" title="1">{
                result = "(" + result + " " + op + " " + args[i] + ")"
        }</span>

        <span class="cov3" title="4">t.output.WriteString("_ = " + result + "\n")</span>
}

// handleFunctionCall processes regular function calls
func (t *Transpiler) handleFunctionCall(funcName string, args []string) <span class="cov3" title="4">{
        // Handle package/function notation (fmt/Println -&gt; fmt.Println)
        if strings.Contains(funcName, "/") </span><span class="cov0" title="0">{
                funcName = strings.ReplaceAll(funcName, "/", ".")
        }</span>

        <span class="cov3" title="4">argStr := strings.Join(args, ", ")
        
        // For functions that return multiple values or don't need assignment, just call them
        if strings.Contains(funcName, "Println") || strings.Contains(funcName, "Printf") </span><span class="cov0" title="0">{
                t.output.WriteString(fmt.Sprintf("%s(%s)\n", funcName, argStr))
        }</span> else<span class="cov3" title="4"> {
                t.output.WriteString(fmt.Sprintf("_ = %s(%s)\n", funcName, argStr))
        }</span>
}

// handleIf processes if conditionals: (if condition then-expr else-expr)
func (t *Transpiler) handleIf(args []string) <span class="cov1" title="1">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                t.output.WriteString("// Error: if requires at least condition and then-expr\n")
                return
        }</span>
        
        <span class="cov1" title="1">condition := args[0]
        thenExpr := args[1]
        var elseExpr string
        if len(args) &gt; 2 </span><span class="cov1" title="1">{
                elseExpr = args[2]
        }</span> else<span class="cov0" title="0"> {
                elseExpr = "nil"
        }</span>
        
        <span class="cov1" title="1">t.output.WriteString(fmt.Sprintf("if %s {\n\t%s\n} else {\n\t%s\n}\n", condition, thenExpr, elseExpr))</span>
}

// evaluateIf evaluates if conditionals as expressions
func (t *Transpiler) evaluateIf(args []string) string <span class="cov1" title="1">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        
        <span class="cov1" title="1">condition := args[0]
        thenExpr := args[1]
        var elseExpr string
        if len(args) &gt; 2 </span><span class="cov1" title="1">{
                elseExpr = args[2]
        }</span> else<span class="cov0" title="0"> {
                elseExpr = "nil"
        }</span>
        
        <span class="cov1" title="1">return fmt.Sprintf("func() interface{} { if %s { return %s } else { return %s } }()", condition, thenExpr, elseExpr)</span>
}

// handleDo processes do blocks: (do expr1 expr2 expr3)
func (t *Transpiler) handleDo(args []string) <span class="cov1" title="1">{
        for _, expr := range args </span><span class="cov2" title="2">{
                t.output.WriteString(expr + "\n")
        }</span>
}

// evaluateDo evaluates do blocks as expressions (returns last expression)
func (t *Transpiler) evaluateDo(args []string) string <span class="cov1" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        
        // Generate function that executes all expressions and returns the last one
        <span class="cov1" title="1">var statements []string
        for i, expr := range args </span><span class="cov2" title="2">{
                if i == len(args)-1 </span><span class="cov1" title="1">{
                        statements = append(statements, "return "+expr)
                }</span> else<span class="cov1" title="1"> {
                        statements = append(statements, expr)
                }</span>
        }
        
        <span class="cov1" title="1">return fmt.Sprintf("func() interface{} { %s }()", strings.Join(statements, "; "))</span>
}

// handleCollectionOp processes collection operations
func (t *Transpiler) handleCollectionOp(op string, args []string) <span class="cov3" title="4">{
        switch op </span>{
        case "first":<span class="cov1" title="1">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        t.output.WriteString("_ = nil // Error: first requires collection\n")
                        return
                }</span>
                <span class="cov1" title="1">t.output.WriteString(fmt.Sprintf("_ = func() interface{} { if len(%s) &gt; 0 { return %s[0] } else { return nil } }()\n", args[0], args[0]))</span>
        
        case "rest":<span class="cov0" title="0">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        t.output.WriteString("_ = []interface{}{} // Error: rest requires collection\n")
                        return
                }</span>
                <span class="cov0" title="0">t.output.WriteString(fmt.Sprintf("_ = func() []interface{} { if len(%s) &gt; 1 { return %s[1:] } else { return []interface{}{} } }()\n", args[0], args[0]))</span>
        
        case "cons":<span class="cov1" title="1">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        t.output.WriteString("_ = []interface{}{} // Error: cons requires element and collection\n")
                        return
                }</span>
                <span class="cov1" title="1">t.output.WriteString(fmt.Sprintf("_ = append([]interface{}{%s}, %s...)\n", args[0], args[1]))</span>
        
        case "count":<span class="cov1" title="1">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        t.output.WriteString("_ = 0 // Error: count requires collection\n")
                        return
                }</span>
                <span class="cov1" title="1">t.output.WriteString(fmt.Sprintf("_ = len(%s)\n", args[0]))</span>
        
        case "empty?":<span class="cov1" title="1">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        t.output.WriteString("_ = true // Error: empty? requires collection\n")
                        return
                }</span>
                <span class="cov1" title="1">t.output.WriteString(fmt.Sprintf("_ = len(%s) == 0\n", args[0]))</span>
        }
}

// evaluateCollectionOp evaluates collection operations as expressions
func (t *Transpiler) evaluateCollectionOp(op string, args []string) string <span class="cov3" title="5">{
        switch op </span>{
        case "first":<span class="cov1" title="1">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        return "nil"
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("func() interface{} { if len(%s) &gt; 0 { return %s[0] } else { return nil } }()", args[0], args[0])</span>
        
        case "rest":<span class="cov1" title="1">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        return "[]interface{}{}"
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("func() []interface{} { if len(%s) &gt; 1 { return %s[1:] } else { return []interface{}{} } }()", args[0], args[0])</span>
        
        case "cons":<span class="cov1" title="1">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return "[]interface{}{}"
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("append([]interface{}{%s}, %s...)", args[0], args[1])</span>
        
        case "count":<span class="cov1" title="1">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        return "0"
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("len(%s)", args[0])</span>
        
        case "empty?":<span class="cov1" title="1">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        return "true"
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("len(%s) == 0", args[0])</span>
        
        default:<span class="cov0" title="0">
                return "nil"</span>
        }
}

// generateGoCode wraps the generated code in a proper Go program
func (t *Transpiler) generateGoCode() string <span class="cov7" title="36">{
        var result strings.Builder

        // Package declaration
        result.WriteString("package main\n\n")

        // Add collected imports
        content := t.output.String()
        
        // Auto-detect imports from function calls if not explicitly imported
        if strings.Contains(content, "fmt.") &amp;&amp; !t.imports["fmt"] </span><span class="cov1" title="1">{
                t.imports["fmt"] = true
        }</span>
        
        // Write all imports
        <span class="cov7" title="36">for importPath := range t.imports </span><span class="cov5" title="13">{
                result.WriteString(fmt.Sprintf("import \"%s\"\n", importPath))
        }</span>
        
        <span class="cov7" title="36">if len(t.imports) &gt; 0 </span><span class="cov4" title="8">{
                result.WriteString("\n")
        }</span>

        // Main function
        <span class="cov7" title="36">result.WriteString("func main() {\n")
        
        // Add the generated code with indentation, but skip any import statements
        lines := strings.Split(strings.TrimSpace(content), "\n")
                for _, line := range lines </span><span class="cov8" title="87">{
                trimmed := strings.TrimSpace(line)
                if trimmed != "" &amp;&amp; !strings.HasPrefix(trimmed, "import ") </span><span class="cov8" title="87">{
                                result.WriteString("\t" + line + "\n")
                }</span>
        }
        
        <span class="cov7" title="36">result.WriteString("}\n")

        return result.String()</span>
}

// handleLastExpression processes the last expression in a program (implicit return)
func (t *Transpiler) handleLastExpression(ctx *parser.ListContext) <span class="cov7" title="36">{
        childCount := ctx.GetChildCount()
        if childCount &lt;= 2 </span><span class="cov0" title="0">{ // Just parentheses
                t.output.WriteString("_ = nil // Empty expression\n")
                return
        }</span>

        // Get the first element (function name)
        <span class="cov7" title="36">firstChild := ctx.GetChild(1)
        if firstChild == nil </span><span class="cov0" title="0">{
                t.output.WriteString("_ = nil // Invalid expression\n")
                return
        }</span>

        <span class="cov7" title="36">var funcName string
        if parseTree, ok := firstChild.(antlr.ParseTree); ok </span><span class="cov7" title="36">{
                funcName = parseTree.GetText()
        }</span> else<span class="cov0" title="0"> {
                t.output.WriteString("_ = nil // Invalid expression\n")
                return
        }</span>

        // Extract arguments
        <span class="cov7" title="36">args := make([]string, 0)
        for i := 2; i &lt; childCount-1; i++ </span><span class="cov8" title="65">{ // Skip '(' and ')'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov8" title="65">{
                        args = append(args, t.visitNode(child))
                }</span>
        }

        // Handle the last expression - ensure it's used
        <span class="cov7" title="36">switch funcName </span>{
        case "def":<span class="cov5" title="15">
                t.handleDefinition(args)
                // Return the defined variable
                if len(args) &gt;= 1 </span><span class="cov5" title="15">{
                        t.output.WriteString(fmt.Sprintf("_ = %s // Return last defined value\n", args[0]))
                }</span>
        case "import":<span class="cov1" title="1">
                t.handleImport(args)
                t.output.WriteString("_ = \"import completed\" // Import statement result\n")</span>
        case "if":<span class="cov1" title="1">
                t.handleIf(args)</span>
        case "do":<span class="cov1" title="1">
                t.handleDo(args)</span>
        case "first", "rest", "cons", "count", "empty?":<span class="cov3" title="4">
                t.handleCollectionOp(funcName, args)</span>
        case "+", "-", "*", "/":<span class="cov3" title="4">
                t.handleArithmetic(funcName, args)</span>
        default:<span class="cov5" title="10">
                // For function calls, capture the result
                if strings.Contains(funcName, "Println") || strings.Contains(funcName, "Printf") </span><span class="cov4" title="6">{
                        t.output.WriteString(fmt.Sprintf("%s(%s) // Last expression\n", 
                                strings.ReplaceAll(funcName, "/", "."), strings.Join(args, ", ")))
                }</span> else<span class="cov3" title="4"> {
                        t.handleFunctionCall(funcName, args)
                }</span>
        }
}

// GetDetectedModules returns the Go modules detected during transpilation
func (t *Transpiler) GetDetectedModules() map[string]string <span class="cov2" title="2">{
        return t.goModules
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
