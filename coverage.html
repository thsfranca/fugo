
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>transpiler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/thsfranca/vex/internal/transpiler/adapters.go (37.5%)</option>
				
				<option value="file1">github.com/thsfranca/vex/internal/transpiler/analysis/analyzer.go (94.9%)</option>
				
				<option value="file2">github.com/thsfranca/vex/internal/transpiler/analysis/errors.go (100.0%)</option>
				
				<option value="file3">github.com/thsfranca/vex/internal/transpiler/analysis/symbols.go (100.0%)</option>
				
				<option value="file4">github.com/thsfranca/vex/internal/transpiler/ast/ast.go (95.2%)</option>
				
				<option value="file5">github.com/thsfranca/vex/internal/transpiler/codegen/generator.go (90.5%)</option>
				
				<option value="file6">github.com/thsfranca/vex/internal/transpiler/core.go (80.0%)</option>
				
				<option value="file7">github.com/thsfranca/vex/internal/transpiler/interfaces.go (80.0%)</option>
				
				<option value="file8">github.com/thsfranca/vex/internal/transpiler/macro/expander.go (89.8%)</option>
				
				<option value="file9">github.com/thsfranca/vex/internal/transpiler/macro/interface_impl.go (89.6%)</option>
				
				<option value="file10">github.com/thsfranca/vex/internal/transpiler/macro/registry.go (91.6%)</option>
				
				<option value="file11">github.com/thsfranca/vex/internal/transpiler/orchestrator.go (72.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package transpiler

import (
        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/analysis"
        "github.com/thsfranca/vex/internal/transpiler/ast"
        "github.com/thsfranca/vex/internal/transpiler/codegen"
        "github.com/thsfranca/vex/internal/transpiler/macro"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// ParserAdapter adapts ast.VexParser to the Parser interface
type ParserAdapter struct {
        parser *ast.VexParser
}

func NewParserAdapter() *ParserAdapter <span class="cov10" title="213">{
        return &amp;ParserAdapter{
                parser: ast.NewParser(),
        }
}</span>

func (pa *ParserAdapter) Parse(input string) (AST, error) <span class="cov9" title="207">{
        astResult, err := pa.parser.Parse(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Convert ast.AST to our AST interface
        <span class="cov9" title="207">return NewConcreteAST(astResult.Root()), nil</span>
}

func (pa *ParserAdapter) ParseFile(filename string) (AST, error) <span class="cov1" title="1">{
        astResult, err := pa.parser.ParseFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov1" title="1">return NewConcreteAST(astResult.Root()), nil</span>
}

// AnalyzerAdapter adapts analysis.AnalyzerImpl to the Analyzer interface
type AnalyzerAdapter struct {
        analyzer *analysis.AnalyzerImpl
}

func NewAnalyzerAdapter() *AnalyzerAdapter <span class="cov9" title="211">{
        return &amp;AnalyzerAdapter{
                analyzer: analysis.NewAnalyzer(),
        }
}</span>

func (aa *AnalyzerAdapter) Analyze(ast AST) (SymbolTable, error) <span class="cov9" title="195">{
        // Create a compatible AST for the analyzer
        analysisAST := &amp;AnalysisAST{ast: ast}
        
        symbolTable, err := aa.analyzer.Analyze(analysisAST)
        if err != nil </span><span class="cov4" title="8">{
                return nil, err
        }</span>
        
        // Wrap the symbol table
        <span class="cov9" title="187">return &amp;SymbolTableAdapter{table: symbolTable}, nil</span>
}

func (aa *AnalyzerAdapter) SetErrorReporter(reporter ErrorReporter) <span class="cov1" title="1">{
        // Convert ErrorReporter to analysis.ErrorReporter
        analysisReporter := &amp;ErrorReporterAdapter{reporter: reporter}
        aa.analyzer.SetErrorReporter(analysisReporter)
}</span>

// CodeGeneratorAdapter adapts codegen.GoCodeGenerator to the CodeGenerator interface
type CodeGeneratorAdapter struct {
        generator *codegen.GoCodeGenerator
}

func NewCodeGeneratorAdapter(config codegen.Config) *CodeGeneratorAdapter <span class="cov9" title="211">{
        return &amp;CodeGeneratorAdapter{
                generator: codegen.NewGoCodeGenerator(config),
        }
}</span>

func (cga *CodeGeneratorAdapter) Generate(ast AST, symbols SymbolTable) (string, error) <span class="cov9" title="187">{
        // Create compatible types
        codegenAST := &amp;CodegenAST{ast: ast}
        codegenSymbols := &amp;CodegenSymbolTable{table: symbols}
        
        return cga.generator.Generate(codegenAST, codegenSymbols)
}</span>

func (cga *CodeGeneratorAdapter) AddImport(importPath string) <span class="cov1" title="1">{
        cga.generator.AddImport(importPath)
}</span>

func (cga *CodeGeneratorAdapter) SetPackageName(name string) <span class="cov1" title="1">{
        cga.generator.SetPackageName(name)
}</span>

// Adapter types for bridging interfaces

type AnalysisAST struct {
        ast AST
}

func (aast *AnalysisAST) Accept(visitor analysis.ASTVisitor) error <span class="cov9" title="195">{
        // Bridge the visitor interface
        bridgeVisitor := &amp;AnalysisVisitorBridge{visitor: visitor}
        return aast.ast.Accept(bridgeVisitor)
}</span>

type AnalysisVisitorBridge struct {
        visitor analysis.ASTVisitor
}

func (avb *AnalysisVisitorBridge) VisitProgram(ctx *parser.ProgramContext) error <span class="cov9" title="195">{
        return avb.visitor.VisitProgram(ctx)
}</span>

func (avb *AnalysisVisitorBridge) VisitList(ctx *parser.ListContext) (Value, error) <span class="cov0" title="0">{
        value, err := avb.visitor.VisitList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ValueAdapter{value: value}, nil</span>
}

func (avb *AnalysisVisitorBridge) VisitArray(ctx *parser.ArrayContext) (Value, error) <span class="cov0" title="0">{
        value, err := avb.visitor.VisitArray(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ValueAdapter{value: value}, nil</span>
}

func (avb *AnalysisVisitorBridge) VisitTerminal(node antlr.TerminalNode) (Value, error) <span class="cov0" title="0">{
        value, err := avb.visitor.VisitTerminal(node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ValueAdapter{value: value}, nil</span>
}

type ValueAdapter struct {
        value analysis.Value
}

func (va *ValueAdapter) String() string <span class="cov0" title="0">{
        return va.value.String()
}</span>

func (va *ValueAdapter) Type() string <span class="cov0" title="0">{
        return va.value.Type()
}</span>

type SymbolTableAdapter struct {
        table analysis.SymbolTable
}

func (sta *SymbolTableAdapter) Define(name string, value Value) error <span class="cov1" title="1">{
        // Convert Value to analysis.Value
        analysisValue := &amp;AnalysisValueAdapter{value: value}
        return sta.table.Define(name, analysisValue)
}</span>

func (sta *SymbolTableAdapter) Lookup(name string) (Value, bool) <span class="cov1" title="1">{
        value, exists := sta.table.Lookup(name)
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov1" title="1">return &amp;ValueAdapter{value: value}, true</span>
}

func (sta *SymbolTableAdapter) EnterScope() <span class="cov1" title="1">{
        sta.table.EnterScope()
}</span>

func (sta *SymbolTableAdapter) ExitScope() <span class="cov1" title="1">{
        sta.table.ExitScope()
}</span>

type AnalysisValueAdapter struct {
        value Value
}

func (ava *AnalysisValueAdapter) String() string <span class="cov0" title="0">{
        return ava.value.String()
}</span>

func (ava *AnalysisValueAdapter) Type() string <span class="cov1" title="1">{
        return ava.value.Type()
}</span>

// CodeGenerator adapters

type CodegenAST struct {
        ast AST
}

func (cast *CodegenAST) Accept(visitor codegen.ASTVisitor) error <span class="cov9" title="187">{
        bridgeVisitor := &amp;CodegenVisitorBridge{visitor: visitor}
        return cast.ast.Accept(bridgeVisitor)
}</span>

type CodegenVisitorBridge struct {
        visitor codegen.ASTVisitor
}

func (cvb *CodegenVisitorBridge) VisitProgram(ctx *parser.ProgramContext) error <span class="cov9" title="187">{
        return cvb.visitor.VisitProgram(ctx)
}</span>

func (cvb *CodegenVisitorBridge) VisitList(ctx *parser.ListContext) (Value, error) <span class="cov0" title="0">{
        value, err := cvb.visitor.VisitList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;CodegenValueAdapter{value: value}, nil</span>
}

func (cvb *CodegenVisitorBridge) VisitArray(ctx *parser.ArrayContext) (Value, error) <span class="cov0" title="0">{
        value, err := cvb.visitor.VisitArray(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;CodegenValueAdapter{value: value}, nil</span>
}

func (cvb *CodegenVisitorBridge) VisitTerminal(node antlr.TerminalNode) (Value, error) <span class="cov0" title="0">{
        value, err := cvb.visitor.VisitTerminal(node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;CodegenValueAdapter{value: value}, nil</span>
}

type CodegenValueAdapter struct {
        value codegen.Value
}

func (cva *CodegenValueAdapter) String() string <span class="cov0" title="0">{
        return cva.value.String()
}</span>

func (cva *CodegenValueAdapter) Type() string <span class="cov0" title="0">{
        return cva.value.Type()
}</span>

type CodegenSymbolTable struct {
        table SymbolTable
}

func (cst *CodegenSymbolTable) Define(name string, value codegen.Value) error <span class="cov0" title="0">{
        // Convert codegen.Value to our Value
        ourValue := &amp;CodegenValueAdapter{value: value}
        return cst.table.Define(name, ourValue)
}</span>

func (cst *CodegenSymbolTable) Lookup(name string) (codegen.Value, bool) <span class="cov0" title="0">{
        value, exists := cst.table.Lookup(name)
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;CodegenValueBridge{value: value}, true</span>
}

func (cst *CodegenSymbolTable) EnterScope() <span class="cov0" title="0">{
        cst.table.EnterScope()
}</span>

func (cst *CodegenSymbolTable) ExitScope() <span class="cov0" title="0">{
        cst.table.ExitScope()
}</span>

type CodegenValueBridge struct {
        value Value
}

func (cvb *CodegenValueBridge) String() string <span class="cov0" title="0">{
        return cvb.value.String()
}</span>

func (cvb *CodegenValueBridge) Type() string <span class="cov0" title="0">{
        return cvb.value.Type()
}</span>

// MacroExpanderAdapter adapts macro.MacroExpanderImpl to the MacroExpander interface
type MacroExpanderAdapter struct {
        expander *macro.MacroExpanderImpl
}

func NewMacroExpanderAdapter(expander *macro.MacroExpanderImpl) *MacroExpanderAdapter <span class="cov9" title="207">{
        return &amp;MacroExpanderAdapter{expander: expander}
}</span>

func (mea *MacroExpanderAdapter) ExpandMacros(ast AST) (AST, error) <span class="cov9" title="202">{
        // Convert AST to macro.AST
        macroAST := &amp;MacroASTAdapter{ast: ast}
        
        expandedAST, err := mea.expander.ExpandMacros(macroAST)
        if err != nil </span><span class="cov4" title="10">{
                return nil, err
        }</span>
        
        // Convert back to our AST interface
        <span class="cov9" title="192">return NewConcreteAST(expandedAST.Root()), nil</span>
}

func (mea *MacroExpanderAdapter) RegisterMacro(name string, ourMacro *macro.Macro) error <span class="cov0" title="0">{
        return mea.expander.RegisterMacro(name, ourMacro)
}</span>

func (mea *MacroExpanderAdapter) HasMacro(name string) bool <span class="cov0" title="0">{
        return mea.expander.HasMacro(name)
}</span>

func (mea *MacroExpanderAdapter) GetMacro(name string) (*macro.Macro, bool) <span class="cov0" title="0">{
        return mea.expander.GetMacro(name)
}</span>

// MacroASTAdapter adapts our AST to macro.AST
type MacroASTAdapter struct {
        ast AST
}

func (maa *MacroASTAdapter) Root() antlr.Tree <span class="cov9" title="202">{
        return maa.ast.Root()
}</span>

func (maa *MacroASTAdapter) Accept(visitor macro.ASTVisitor) error <span class="cov0" title="0">{
        // Bridge visitor interfaces
        bridgeVisitor := &amp;MacroVisitorBridge{visitor: visitor}
        return maa.ast.Accept(bridgeVisitor)
}</span>

type MacroVisitorBridge struct {
        visitor macro.ASTVisitor
}

func (mvb *MacroVisitorBridge) VisitProgram(ctx *parser.ProgramContext) error <span class="cov0" title="0">{
        return mvb.visitor.VisitProgram(ctx)
}</span>

func (mvb *MacroVisitorBridge) VisitList(ctx *parser.ListContext) (Value, error) <span class="cov0" title="0">{
        value, err := mvb.visitor.VisitList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;MacroValueAdapter{value: value}, nil</span>
}

func (mvb *MacroVisitorBridge) VisitArray(ctx *parser.ArrayContext) (Value, error) <span class="cov0" title="0">{
        value, err := mvb.visitor.VisitArray(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;MacroValueAdapter{value: value}, nil</span>
}

func (mvb *MacroVisitorBridge) VisitTerminal(node antlr.TerminalNode) (Value, error) <span class="cov0" title="0">{
        value, err := mvb.visitor.VisitTerminal(node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;MacroValueAdapter{value: value}, nil</span>
}

type MacroValueAdapter struct {
        value macro.Value
}

func (mva *MacroValueAdapter) String() string <span class="cov0" title="0">{
        return mva.value.String()
}</span>

func (mva *MacroValueAdapter) Type() string <span class="cov0" title="0">{
        return mva.value.Type()
}</span>

// ErrorReporterAdapter adapts our ErrorReporter to analysis.ErrorReporter
type ErrorReporterAdapter struct {
        reporter ErrorReporter
}

func (era *ErrorReporterAdapter) ReportError(line, column int, message string) <span class="cov0" title="0">{
        era.reporter.ReportError(line, column, message)
}</span>

func (era *ErrorReporterAdapter) ReportWarning(line, column int, message string) <span class="cov0" title="0">{
        era.reporter.ReportWarning(line, column, message)
}</span>

func (era *ErrorReporterAdapter) HasErrors() bool <span class="cov0" title="0">{
        return era.reporter.HasErrors()
}</span>

func (era *ErrorReporterAdapter) GetErrors() []analysis.CompilerError <span class="cov0" title="0">{
        errors := era.reporter.GetErrors()
        analysisErrors := make([]analysis.CompilerError, len(errors))
        
        for i, err := range errors </span><span class="cov0" title="0">{
                analysisErrors[i] = analysis.CompilerError{
                        Line:    err.Line,
                        Column:  err.Column,
                        Message: err.Message,
                        Type:    analysis.ErrorType(err.Type), // Assuming compatible enum values
                }
        }</span>
        
        <span class="cov0" title="0">return analysisErrors</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package analysis

import (
        "fmt"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// AnalyzerImpl implements the Analyzer interface
type AnalyzerImpl struct {
        symbolTable   *SymbolTableImpl
        errorReporter *ErrorReporterImpl
}

// NewAnalyzer creates a new analyzer
func NewAnalyzer() *AnalyzerImpl <span class="cov7" title="227">{
        return &amp;AnalyzerImpl{
                symbolTable:   NewSymbolTable(),
                errorReporter: NewErrorReporter(),
        }
}</span>

// Analyze performs semantic analysis on the AST
func (a *AnalyzerImpl) Analyze(ast AST) (SymbolTable, error) <span class="cov7" title="197">{
        // Reset for new analysis
        a.symbolTable = NewSymbolTable()
        a.errorReporter.Clear()
        
        // Visit the AST
        if err := ast.Accept(a); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Check for errors
        <span class="cov7" title="197">if a.errorReporter.HasErrors() </span><span class="cov3" title="9">{
                return nil, fmt.Errorf("analysis failed with errors:\n%s", a.errorReporter.FormatErrors())
        }</span>
        
        <span class="cov7" title="188">return a.symbolTable, nil</span>
}

// SetErrorReporter sets the error reporter
func (a *AnalyzerImpl) SetErrorReporter(reporter ErrorReporter) <span class="cov1" title="2">{
        if impl, ok := reporter.(*ErrorReporterImpl); ok </span><span class="cov1" title="1">{
                a.errorReporter = impl
        }</span>
}

// GetErrorReporter returns the current error reporter
func (a *AnalyzerImpl) GetErrorReporter() *ErrorReporterImpl <span class="cov1" title="1">{
        return a.errorReporter
}</span>

// VisitProgram analyzes a program node
func (a *AnalyzerImpl) VisitProgram(ctx *parser.ProgramContext) error <span class="cov7" title="198">{
        for _, child := range ctx.GetChildren() </span><span class="cov8" title="467">{
                if listCtx, ok := child.(*parser.ListContext); ok </span><span class="cov7" title="268">{
                        _, err := a.VisitList(listCtx)
                        if err != nil </span><span class="cov3" title="9">{
                                // Error already reported, continue analysis
                                continue</span>
                        }
                }
        }
        <span class="cov7" title="198">return nil</span>
}

// VisitList analyzes a list expression
func (a *AnalyzerImpl) VisitList(ctx *parser.ListContext) (Value, error) <span class="cov7" title="304">{
        childCount := ctx.GetChildCount()
        if childCount &lt; 3 </span><span class="cov1" title="1">{ // Need at least: '(', function, ')'
                line := ctx.GetStart().GetLine()
                column := ctx.GetStart().GetColumn()
                a.errorReporter.ReportError(line, column, "empty expression")
                return nil, fmt.Errorf("empty expression")
        }</span>

        // Get function name (first child after '(')
        <span class="cov7" title="303">funcNameNode := ctx.GetChild(1)
        funcName := a.nodeToString(funcNameNode)

        // Extract arguments
        var args []Value
        for i := 2; i &lt; childCount-1; i++ </span><span class="cov8" title="561">{ // Skip '(' and ')'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov8" title="561">{
                        // For special forms that need raw arguments, handle specially
                        if funcName == "macro" || funcName == "def" </span><span class="cov7" title="308">{
                                // For these special forms, just get the text representation
                                argText := a.nodeToString(child)
                                args = append(args, NewBasicValue(argText, "raw"))
                        }</span> else<span class="cov7" title="253"> {
                                arg, err := a.visitNode(child)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span> // Error already reported
                                }
                                <span class="cov7" title="253">args = append(args, arg)</span>
                        }
                }
        }

        // Analyze special forms
        <span class="cov7" title="303">switch funcName </span>{
        case "def":<span class="cov6" title="115">
                return a.analyzeDef(ctx, args)</span>
        case "if":<span class="cov3" title="8">
                return a.analyzeIf(ctx, args)</span>
        case "fn":<span class="cov1" title="2">
                return a.analyzeFn(ctx, args)</span>
        case "macro":<span class="cov5" title="30">
                return a.analyzeMacro(ctx, args)</span>
        default:<span class="cov6" title="148">
                return a.analyzeFunctionCall(ctx, funcName, args)</span>
        }
}

// VisitArray analyzes an array literal
func (a *AnalyzerImpl) VisitArray(ctx *parser.ArrayContext) (Value, error) <span class="cov5" title="30">{
        elements := make([]Value, 0)
        
        // Analyze all elements
        for i := 1; i &lt; ctx.GetChildCount()-1; i++ </span><span class="cov5" title="54">{ // Skip '[' and ']'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov5" title="54">{
                        element, err := a.visitNode(child)
                        if err != nil </span><span class="cov1" title="1">{
                                continue</span> // Error already reported
                        }
                        <span class="cov5" title="53">elements = append(elements, element)</span>
                }
        }
        
        // Create array value
        <span class="cov5" title="30">return NewBasicValue("array", "[]interface{}"), nil</span>
}

// VisitTerminal analyzes a terminal node
func (a *AnalyzerImpl) VisitTerminal(node antlr.TerminalNode) (Value, error) <span class="cov7" title="248">{
        text := node.GetText()
        
        // Determine type based on content
        if strings.HasPrefix(text, "\"") &amp;&amp; strings.HasSuffix(text, "\"") </span><span class="cov6" title="69">{
                return NewBasicValue(text, "string"), nil
        }</span>
        
        // Check if it's a number
        <span class="cov7" title="179">if isNumber(text) </span><span class="cov6" title="153">{
                return NewBasicValue(text, "number"), nil
        }</span>
        
        // Check if it's a boolean
        <span class="cov4" title="26">if text == "true" || text == "false" </span><span class="cov3" title="8">{
                return NewBasicValue(text, "bool"), nil
        }</span>
        
        // Must be a symbol - check if it's defined
        <span class="cov4" title="18">if value, exists := a.symbolTable.Lookup(text); exists </span><span class="cov4" title="16">{
                return value, nil
        }</span>
        
        // Undefined symbol
        <span class="cov1" title="2">line := 1
        column := 0
        if symbol := node.GetSymbol(); symbol != nil </span><span class="cov1" title="1">{
                line = symbol.GetLine()
                column = symbol.GetColumn()
        }</span>
        <span class="cov1" title="2">a.errorReporter.ReportError(line, column, fmt.Sprintf("undefined symbol '%s'", text))
        
        return NewBasicValue(text, "undefined"), fmt.Errorf("undefined symbol")</span>
}

// analyzeDef analyzes a definition
func (a *AnalyzerImpl) analyzeDef(ctx *parser.ListContext, args []Value) (Value, error) <span class="cov6" title="119">{
        if len(args) &lt; 2 </span><span class="cov2" title="4">{
                line := ctx.GetStart().GetLine()
                column := ctx.GetStart().GetColumn()
                a.errorReporter.ReportError(line, column, "def requires name and value")
                return nil, fmt.Errorf("invalid def")
        }</span>
        
        <span class="cov6" title="115">name := args[0].String()
        value := args[1]
        
        // Define the symbol
        if err := a.symbolTable.Define(name, value); err != nil </span><span class="cov0" title="0">{
                line := ctx.GetStart().GetLine()
                column := ctx.GetStart().GetColumn()
                a.errorReporter.ReportError(line, column, err.Error())
                return nil, err
        }</span>
        
        <span class="cov6" title="115">return value, nil</span>
}

// analyzeIf analyzes an if expression
func (a *AnalyzerImpl) analyzeIf(ctx *parser.ListContext, args []Value) (Value, error) <span class="cov3" title="11">{
        if len(args) &lt; 2 </span><span class="cov1" title="2">{
                line := ctx.GetStart().GetLine()
                column := ctx.GetStart().GetColumn()
                a.errorReporter.ReportError(line, column, "if requires condition and then-branch")
                return nil, fmt.Errorf("invalid if")
        }</span>
        
        // Analyze condition
        <span class="cov3" title="9">condition := args[0]
        thenBranch := args[1]
        
        // Optional else branch
        var elseBranch Value
        if len(args) &gt; 2 </span><span class="cov3" title="8">{
                elseBranch = args[2]
        }</span>
        
        // Type checking: condition should be boolean-compatible
        <span class="cov3" title="9">if condition.Type() != "bool" &amp;&amp; condition.Type() != "number" </span><span class="cov2" title="3">{
                line := ctx.GetStart().GetLine()
                column := ctx.GetStart().GetColumn()
                a.errorReporter.ReportWarning(line, column, 
                        fmt.Sprintf("condition has type '%s', expected bool", condition.Type()))
        }</span>
        
        // Result type is the type of the then branch
        // (In a more sophisticated system, we'd unify then and else types)
        <span class="cov3" title="9">resultType := thenBranch.Type()
        if elseBranch != nil &amp;&amp; elseBranch.Type() != resultType </span><span class="cov0" title="0">{
                resultType = "interface{}" // Mixed types
        }</span>
        
        <span class="cov3" title="9">return NewBasicValue("if-result", resultType), nil</span>
}

// analyzeFn analyzes a function definition
func (a *AnalyzerImpl) analyzeFn(ctx *parser.ListContext, args []Value) (Value, error) <span class="cov2" title="3">{
        if len(args) &lt; 2 </span><span class="cov1" title="2">{
                line := ctx.GetStart().GetLine()
                column := ctx.GetStart().GetColumn()
                a.errorReporter.ReportError(line, column, "fn requires parameter list and body")
                return nil, fmt.Errorf("invalid fn")
        }</span>
        
        // Enter new scope for function parameters
        <span class="cov1" title="1">a.symbolTable.EnterScope()
        defer a.symbolTable.ExitScope()
        
        // Analyze parameter list (args[0])
        // For now, we'll treat parameters as symbols with interface{} type
        paramList := args[0].String()
        if strings.HasPrefix(paramList, "[") &amp;&amp; strings.HasSuffix(paramList, "]") </span><span class="cov1" title="1">{
                // Extract parameter names
                inner := strings.TrimSpace(paramList[1 : len(paramList)-1])
                if inner != "" </span><span class="cov1" title="1">{
                        params := strings.Fields(inner)
                        for _, param := range params </span><span class="cov1" title="2">{
                                paramValue := NewBasicValue(param, "interface{}")
                                a.symbolTable.Define(param, paramValue)
                        }</span>
                }
        }
        
        // Analyze function body (args[1])
        <span class="cov1" title="1">_ = args[1] // bodyValue not used in this simplified implementation
        
        return NewBasicValue("function", "func"), nil</span>
}

// analyzeMacro analyzes a macro definition
func (a *AnalyzerImpl) analyzeMacro(ctx *parser.ListContext, args []Value) (Value, error) <span class="cov5" title="33">{
        if len(args) &lt; 3 </span><span class="cov2" title="5">{
                line := ctx.GetStart().GetLine()
                column := ctx.GetStart().GetColumn()
                a.errorReporter.ReportError(line, column, "macro requires name, parameters, and body")
                return nil, fmt.Errorf("invalid macro")
        }</span>
        
        <span class="cov4" title="28">name := args[0].String()
        
        // Check for valid macro name
        if isReservedWord(name) </span><span class="cov1" title="1">{
                line := ctx.GetStart().GetLine()
                column := ctx.GetStart().GetColumn()
                a.errorReporter.ReportError(line, column, 
                        fmt.Sprintf("'%s' is a reserved word and cannot be used as macro name", name))
                return nil, fmt.Errorf("invalid macro name")
        }</span>
        
        // Define the macro as a symbol
        <span class="cov4" title="27">macroValue := NewBasicValue(name, "macro")
        a.symbolTable.Define(name, macroValue)
        
        return macroValue, nil</span>
}

// analyzeFunctionCall analyzes a function call
func (a *AnalyzerImpl) analyzeFunctionCall(ctx *parser.ListContext, funcName string, args []Value) (Value, error) <span class="cov6" title="151">{
        // Check if function is defined
        if _, exists := a.symbolTable.Lookup(funcName); !exists </span><span class="cov6" title="140">{
                // For built-in functions, we'll allow them
                if !isBuiltinFunction(funcName) </span><span class="cov6" title="75">{
                        line := ctx.GetStart().GetLine()
                        column := ctx.GetStart().GetColumn()
                        a.errorReporter.ReportWarning(line, column, 
                                fmt.Sprintf("function '%s' may not be defined", funcName))
                }</span>
        }
        
        // For now, assume function calls return interface{}
        <span class="cov6" title="151">return NewBasicValue("call-result", "interface{}"), nil</span>
}

// Helper methods
func (a *AnalyzerImpl) visitNode(node antlr.Tree) (Value, error) <span class="cov7" title="307">{
        switch n := node.(type) </span>{
        case *parser.ListContext:<span class="cov5" title="35">
                return a.VisitList(n)</span>
        case *parser.ArrayContext:<span class="cov5" title="29">
                return a.VisitArray(n)</span>
        case antlr.TerminalNode:<span class="cov7" title="243">
                return a.VisitTerminal(n)</span>
        default:<span class="cov0" title="0">
                return NewBasicValue("unknown", "interface{}"), nil</span>
        }
}

func (a *AnalyzerImpl) nodeToString(node antlr.Tree) string <span class="cov8" title="611">{
        if terminal, ok := node.(antlr.TerminalNode); ok </span><span class="cov8" title="466">{
                return terminal.GetText()
        }</span>
        <span class="cov6" title="145">return "unknown"</span>
}

// Helper functions
func isNumber(s string) bool <span class="cov7" title="186">{
        for _, r := range s </span><span class="cov7" title="198">{
                if r &lt; '0' || r &gt; '9' </span><span class="cov5" title="29">{
                        return false
                }</span>
        }
        <span class="cov7" title="157">return len(s) &gt; 0</span>
}

func isReservedWord(word string) bool <span class="cov5" title="38">{
        reserved := []string{"if", "def", "fn", "let", "do", "when", "unless", "import"}
        for _, r := range reserved </span><span class="cov7" title="269">{
                if word == r </span><span class="cov3" title="9">{
                        return true
                }</span>
        }
        <span class="cov5" title="29">return false</span>
}

func isBuiltinFunction(name string) bool <span class="cov6" title="154">{
        builtins := []string{"+", "-", "*", "/", "&gt;", "&lt;", "=", "not", "and", "or", 
                "first", "rest", "cons", "count", "empty?", "println", "printf"}
        for _, b := range builtins </span><span class="cov10" title="1924">{
                if name == b </span><span class="cov5" title="52">{
                        return true
                }</span>
        }
        <span class="cov6" title="102">return strings.Contains(name, "/")</span> // Package functions like fmt/Println
}

// Interface implementations to satisfy the imports
type AST interface {
        Accept(visitor ASTVisitor) error
}

type ASTVisitor interface {
        VisitProgram(ctx *parser.ProgramContext) error
        VisitList(ctx *parser.ListContext) (Value, error)
        VisitArray(ctx *parser.ArrayContext) (Value, error)
        VisitTerminal(node antlr.TerminalNode) (Value, error)
}

type SymbolTable interface {
        Define(name string, value Value) error
        Lookup(name string) (Value, bool)
        EnterScope()
        ExitScope()
}

type ErrorReporter interface {
        ReportError(line, column int, message string)
        ReportWarning(line, column int, message string)
        HasErrors() bool
        GetErrors() []CompilerError
}

</pre>
		
		<pre class="file" id="file2" style="display: none">package analysis

import (
        "fmt"
        "sort"
)

// ErrorType represents the type of error
type ErrorType int

const (
        SyntaxError ErrorType = iota
        SemanticError
        MacroError
        TypeError
)

func (et ErrorType) String() string <span class="cov5" title="20">{
        switch et </span>{
        case SyntaxError:<span class="cov2" title="2">
                return "Syntax Error"</span>
        case SemanticError:<span class="cov5" title="14">
                return "Semantic Error"</span>
        case MacroError:<span class="cov1" title="1">
                return "Macro Error"</span>
        case TypeError:<span class="cov2" title="2">
                return "Type Error"</span>
        default:<span class="cov1" title="1">
                return "Unknown Error"</span>
        }
}

// CompilerError represents a compilation error
type CompilerError struct {
        Line    int
        Column  int
        Message string
        Type    ErrorType
}

func (e *CompilerError) String() string <span class="cov5" title="15">{
        return fmt.Sprintf("%s at line %d:%d: %s", e.Type, e.Line, e.Column, e.Message)
}</span>

// ErrorReporterImpl implements the ErrorReporter interface
type ErrorReporterImpl struct {
        errors   []CompilerError
        warnings []CompilerError
}

// NewErrorReporter creates a new error reporter
func NewErrorReporter() *ErrorReporterImpl <span class="cov10" title="242">{
        return &amp;ErrorReporterImpl{
                errors:   make([]CompilerError, 0),
                warnings: make([]CompilerError, 0),
        }
}</span>

// ReportError reports a compilation error
func (er *ErrorReporterImpl) ReportError(line, column int, message string) <span class="cov6" title="30">{
        er.ReportTypedError(line, column, message, SemanticError)
}</span>

// ReportWarning reports a compilation warning
func (er *ErrorReporterImpl) ReportWarning(line, column int, message string) <span class="cov8" title="90">{
        warning := CompilerError{
                Line:    line,
                Column:  column,
                Message: message,
                Type:    SemanticError, // Warnings are semantic by default
        }
        er.warnings = append(er.warnings, warning)
}</span>

// ReportTypedError reports an error with a specific type
func (er *ErrorReporterImpl) ReportTypedError(line, column int, message string, errorType ErrorType) <span class="cov6" title="33">{
        error := CompilerError{
                Line:    line,
                Column:  column,
                Message: message,
                Type:    errorType,
        }
        er.errors = append(er.errors, error)
}</span>

// HasErrors returns true if any errors have been reported
func (er *ErrorReporterImpl) HasErrors() bool <span class="cov9" title="217">{
        return len(er.errors) &gt; 0
}</span>

// GetErrors returns all reported errors
func (er *ErrorReporterImpl) GetErrors() []CompilerError <span class="cov5" title="14">{
        // Sort errors by line number for consistent output
        sorted := make([]CompilerError, len(er.errors))
        copy(sorted, er.errors)
        
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov4" title="8">{
                if sorted[i].Line == sorted[j].Line </span><span class="cov2" title="2">{
                        return sorted[i].Column &lt; sorted[j].Column
                }</span>
                <span class="cov3" title="6">return sorted[i].Line &lt; sorted[j].Line</span>
        })
        
        <span class="cov5" title="14">return sorted</span>
}

// GetWarnings returns all reported warnings
func (er *ErrorReporterImpl) GetWarnings() []CompilerError <span class="cov3" title="6">{
        // Sort warnings by line number for consistent output
        sorted := make([]CompilerError, len(er.warnings))
        copy(sorted, er.warnings)
        
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov3" title="4">{
                if sorted[i].Line == sorted[j].Line </span><span class="cov1" title="1">{
                        return sorted[i].Column &lt; sorted[j].Column
                }</span>
                <span class="cov2" title="3">return sorted[i].Line &lt; sorted[j].Line</span>
        })
        
        <span class="cov3" title="6">return sorted</span>
}

// GetErrorCount returns the number of errors
func (er *ErrorReporterImpl) GetErrorCount() int <span class="cov3" title="5">{
        return len(er.errors)
}</span>

// GetWarningCount returns the number of warnings
func (er *ErrorReporterImpl) GetWarningCount() int <span class="cov3" title="6">{
        return len(er.warnings)
}</span>

// Clear removes all errors and warnings
func (er *ErrorReporterImpl) Clear() <span class="cov9" title="210">{
        er.errors = er.errors[:0]
        er.warnings = er.warnings[:0]
}</span>

// FormatErrors returns a formatted string of all errors
func (er *ErrorReporterImpl) FormatErrors() string <span class="cov4" title="11">{
        if !er.HasErrors() </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        <span class="cov4" title="10">result := ""
        for _, err := range er.GetErrors() </span><span class="cov5" title="12">{
                result += err.String() + "\n"
        }</span>
        
        <span class="cov4" title="10">return result</span>
}

// FormatWarnings returns a formatted string of all warnings
func (er *ErrorReporterImpl) FormatWarnings() string <span class="cov2" title="2">{
        if len(er.warnings) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        <span class="cov1" title="1">result := ""
        for _, warning := range er.GetWarnings() </span><span class="cov2" title="2">{
                result += "Warning: " + warning.String() + "\n"
        }</span>
        
        <span class="cov1" title="1">return result</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package analysis

import (
        "fmt"
)

// Symbol represents a defined symbol (variable, function, etc.)
type Symbol struct {
        Name  string
        Type  string
        Value Value
        Scope int
}

// Value represents a value in the Vex language
type Value interface {
        String() string
        Type() string
}

// BasicValue implements Value for basic types
type BasicValue struct {
        value string
        typ   string
}

func NewBasicValue(value, typ string) *BasicValue <span class="cov10" title="2035">{
        return &amp;BasicValue{value: value, typ: typ}
}</span>

func (v *BasicValue) String() string <span class="cov9" title="1997">{
        return v.value
}</span>

func (v *BasicValue) Type() string <span class="cov7" title="199">{
        return v.typ
}</span>

// SymbolTableImpl implements the SymbolTable interface
type SymbolTableImpl struct {
        symbols     map[string]*Symbol
        scopes      []map[string]*Symbol
        currentScope int
}

// NewSymbolTable creates a new symbol table
func NewSymbolTable() *SymbolTableImpl <span class="cov8" title="443">{
        st := &amp;SymbolTableImpl{
                symbols:      make(map[string]*Symbol),
                scopes:       make([]map[string]*Symbol, 0),
                currentScope: 0,
        }
        
        // Add global scope
        st.scopes = append(st.scopes, make(map[string]*Symbol))
        
        return st
}</span>

// Define adds a new symbol to the current scope
func (st *SymbolTableImpl) Define(name string, value Value) error <span class="cov6" title="158">{
        if name == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("symbol name cannot be empty")
        }</span>
        
        // Check if already defined in current scope
        <span class="cov6" title="157">currentScopeSymbols := st.scopes[st.currentScope]
        if _, exists := currentScopeSymbols[name]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("symbol '%s' already defined in current scope", name)
        }</span>
        
        // Create new symbol
        <span class="cov6" title="156">symbol := &amp;Symbol{
                Name:  name,
                Type:  value.Type(),
                Value: value,
                Scope: st.currentScope,
        }
        
        // Add to current scope and global table
        currentScopeSymbols[name] = symbol
        st.symbols[name] = symbol
        
        return nil</span>
}

// Lookup finds a symbol by name, searching from current scope upward
func (st *SymbolTableImpl) Lookup(name string) (Value, bool) <span class="cov7" title="181">{
        // Search from current scope back to global scope
        for i := st.currentScope; i &gt;= 0; i-- </span><span class="cov7" title="182">{
                if symbol, exists := st.scopes[i][name]; exists </span><span class="cov5" title="37">{
                        return symbol.Value, true
                }</span>
        }
        
        <span class="cov6" title="144">return nil, false</span>
}

// EnterScope creates a new scope level
func (st *SymbolTableImpl) EnterScope() <span class="cov3" title="7">{
        st.currentScope++
        st.scopes = append(st.scopes, make(map[string]*Symbol))
}</span>

// ExitScope returns to the previous scope level
func (st *SymbolTableImpl) ExitScope() <span class="cov2" title="5">{
        if st.currentScope &gt; 0 </span><span class="cov2" title="4">{
                // Remove symbols from global table that were defined in this scope
                scopeToRemove := st.scopes[st.currentScope]
                for name := range scopeToRemove </span><span class="cov2" title="4">{
                        delete(st.symbols, name)
                }</span>
                
                // Remove the scope
                <span class="cov2" title="4">st.scopes = st.scopes[:len(st.scopes)-1]
                st.currentScope--</span>
        }
}

// GetCurrentScope returns the current scope level
func (st *SymbolTableImpl) GetCurrentScope() int <span class="cov1" title="2">{
        return st.currentScope
}</span>

// GetSymbol retrieves symbol information by name
func (st *SymbolTableImpl) GetSymbol(name string) (*Symbol, bool) <span class="cov1" title="2">{
        // Search from current scope back to global scope
        for i := st.currentScope; i &gt;= 0; i-- </span><span class="cov1" title="2">{
                if symbol, exists := st.scopes[i][name]; exists </span><span class="cov1" title="1">{
                        return symbol, true
                }</span>
        }
        
        <span class="cov1" title="1">return nil, false</span>
}

// GetAllSymbols returns all symbols in the current scope
func (st *SymbolTableImpl) GetAllSymbols() map[string]*Symbol <span class="cov2" title="3">{
        result := make(map[string]*Symbol)
        
        // Collect all symbols from global to current scope
        for i := 0; i &lt;= st.currentScope; i++ </span><span class="cov2" title="4">{
                for name, symbol := range st.scopes[i] </span><span class="cov2" title="4">{
                        result[name] = symbol
                }</span>
        }
        
        <span class="cov2" title="3">return result</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package ast

import (
        "fmt"
        "os"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// VexAST implements the AST interface
type VexAST struct {
        root antlr.Tree
}

// NewVexAST creates a new VexAST
func NewVexAST(root antlr.Tree) *VexAST <span class="cov10" title="219">{
        return &amp;VexAST{root: root}
}</span>

// Root returns the root node of the AST
func (ast *VexAST) Root() antlr.Tree <span class="cov9" title="213">{
        return ast.root
}</span>

// Accept applies a visitor to the AST
func (ast *VexAST) Accept(visitor ASTVisitor) error <span class="cov2" title="2">{
        if programCtx, ok := ast.root.(*parser.ProgramContext); ok </span><span class="cov1" title="1">{
                return visitor.VisitProgram(programCtx)
        }</span>
        <span class="cov1" title="1">return fmt.Errorf("invalid AST root type")</span>
}

// ASTVisitor interface for visiting AST nodes
type ASTVisitor interface {
        VisitProgram(ctx *parser.ProgramContext) error
        VisitList(ctx *parser.ListContext) (Value, error)
        VisitArray(ctx *parser.ArrayContext) (Value, error)
        VisitTerminal(node antlr.TerminalNode) (Value, error)
}

// Value represents a value in the Vex language
type Value interface {
        String() string
        Type() string
}

// BasicValue implements Value for basic types
type BasicValue struct {
        value string
        typ   string
}

func NewBasicValue(value, typ string) *BasicValue <span class="cov3" title="4">{
        return &amp;BasicValue{value: value, typ: typ}
}</span>

func (v *BasicValue) String() string <span class="cov3" title="4">{
        return v.value
}</span>

func (v *BasicValue) Type() string <span class="cov3" title="4">{
        return v.typ
}</span>

// VexParser implements the Parser interface
type VexParser struct{}

// NewParser creates a new VexParser
func NewParser() *VexParser <span class="cov9" title="217">{
        return &amp;VexParser{}
}</span>

// Parse parses source code into an AST
func (p *VexParser) Parse(input string) (AST, error) <span class="cov9" title="216">{
        inputStream := antlr.NewInputStream(input)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)

        // Parse the program
        tree := vexParser.Program()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse input")
        }</span>

        <span class="cov9" title="216">return NewVexAST(tree.(*parser.ProgramContext)), nil</span>
}

// ParseFile parses a file into an AST
func (p *VexParser) ParseFile(filename string) (AST, error) <span class="cov2" title="3">{
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read file %s: %v", filename, err)
        }</span>
        
        <span class="cov2" title="2">return p.Parse(string(content))</span>
}

// AST interface
type AST interface {
        Root() antlr.Tree
        Accept(visitor ASTVisitor) error
}</pre>
		
		<pre class="file" id="file5" style="display: none">package codegen

import (
        "fmt"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/analysis"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// GoCodeGenerator generates Go code from AST
type GoCodeGenerator struct {
        output      strings.Builder
        imports     map[string]bool
        goModules   map[string]string
        packageName string
        config      Config
}

// Config holds code generation configuration
type Config struct {
        PackageName      string
        GenerateComments bool
        IndentSize       int
}

// NewGoCodeGenerator creates a new Go code generator
func NewGoCodeGenerator(config Config) *GoCodeGenerator <span class="cov8" title="218">{
        return &amp;GoCodeGenerator{
                imports:     make(map[string]bool),
                goModules:   make(map[string]string),
                packageName: config.PackageName,
                config:      config,
        }
}</span>

// Generate generates Go code from AST and symbol table
func (g *GoCodeGenerator) Generate(ast AST, symbols SymbolTable) (string, error) <span class="cov7" title="187">{
        // Reset for new generation
        g.output.Reset()
        g.imports = make(map[string]bool)
        
        // Visit the AST
        if err := ast.Accept(g); err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        
        <span class="cov7" title="186">return g.buildFinalCode(), nil</span>
}

// AddImport adds an import to the generated code
func (g *GoCodeGenerator) AddImport(importPath string) <span class="cov5" title="23">{
        g.imports[importPath] = true
}</span>

// SetPackageName sets the package name for generated code
func (g *GoCodeGenerator) SetPackageName(name string) <span class="cov1" title="1">{
        g.packageName = name
}</span>

// VisitProgram generates code for a program node
func (g *GoCodeGenerator) VisitProgram(ctx *parser.ProgramContext) error <span class="cov7" title="194">{
        if g.config.GenerateComments </span><span class="cov7" title="186">{
                g.output.WriteString("// Generated by Vex transpiler\n")
        }</span>
        
        // Count def statements to determine comment style
        <span class="cov7" title="194">defCount := 0
        for _, child := range ctx.GetChildren() </span><span class="cov9" title="468">{
                if listCtx, ok := child.(*parser.ListContext); ok </span><span class="cov8" title="273">{
                        if g.isDefStatement(listCtx) </span><span class="cov7" title="114">{
                                defCount++
                        }</span>
                }
        }
        
        <span class="cov7" title="194">currentDef := 0
        for _, child := range ctx.GetChildren() </span><span class="cov9" title="467">{
                if listCtx, ok := child.(*parser.ListContext); ok </span><span class="cov8" title="273">{
                        value, err := g.VisitList(listCtx)
                        if err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                        // Write the generated value to output
                        <span class="cov8" title="272">if value != nil &amp;&amp; value.String() != "" </span><span class="cov8" title="246">{
                                // Special handling for def statements at top level
                                if strings.Contains(value.String(), " := ") </span><span class="cov7" title="114">{
                                        g.output.WriteString(value.String() + "\n")
                                        // Extract variable name for implicit return
                                        parts := strings.Split(value.String(), " := ")
                                        if len(parts) &gt;= 1 </span><span class="cov7" title="114">{
                                                varName := strings.TrimSpace(parts[0])
                                                currentDef++
                                                
                                                // Different comments for single vs multiple defs
                                                if defCount == 1 </span><span class="cov6" title="93">{
                                                        g.output.WriteString(fmt.Sprintf("_ = %s // Return last defined value\n", varName))
                                                }</span> else<span class="cov4" title="21"> {
                                                        g.output.WriteString(fmt.Sprintf("_ = %s // Use variable to satisfy Go compiler\n", varName))
                                                }</span>
                                        }
                                } else<span class="cov7" title="132"> {
                                        // Special handling for certain statements that don't need assignments
                                        valueStr := value.String()
                                        if strings.HasPrefix(valueStr, "fmt.Println(") || 
                                           strings.HasPrefix(valueStr, "fmt.Printf(") || 
                                           strings.HasPrefix(valueStr, "\"import completed\"") </span><span class="cov5" title="45">{
                                                // Don't assign these to _
                                                if !strings.HasPrefix(valueStr, "\"import completed\"") </span><span class="cov5" title="23">{
                                                        g.output.WriteString(valueStr + "\n")
                                                }</span>
                                                // Skip import completed messages entirely
                                        } else<span class="cov6" title="87"> {
                                                g.output.WriteString(fmt.Sprintf("_ = %s\n", valueStr))
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov7" title="193">return nil</span>
}

// isDefStatement checks if a list context is a def statement
func (g *GoCodeGenerator) isDefStatement(ctx *parser.ListContext) bool <span class="cov8" title="273">{
        if ctx.GetChildCount() &lt; 3 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="273">funcNameNode := ctx.GetChild(1)
        return g.nodeToString(funcNameNode) == "def"</span>
}

// VisitList generates code for a list expression
func (g *GoCodeGenerator) VisitList(ctx *parser.ListContext) (Value, error) <span class="cov9" title="463">{
        childCount := ctx.GetChildCount()
        if childCount &lt; 3 </span><span class="cov0" title="0">{ // Need at least: '(', function, ')'
                return nil, nil
        }</span>

        // Get function name (first child after '(')
        <span class="cov9" title="463">funcNameNode := ctx.GetChild(1)
        
        // Check if the function name is actually a nested expression
        if listCtx, ok := funcNameNode.(*parser.ListContext); ok </span><span class="cov1" title="2">{
                // This is a nested expression like ((+ 1 2) args...)
                // We need to evaluate the nested expression first
                funcResult, err := g.VisitList(listCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="2">funcName := funcResult.String()
                
                // Extract arguments for the function call
                args := make([]string, 0, childCount-3)
                for i := 2; i &lt; childCount-1; i++ </span><span class="cov2" title="3">{ // Skip '(' and ')'
                        child := ctx.GetChild(i)
                        if child != nil </span><span class="cov2" title="3">{
                                argValue, err := g.visitNode(child)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov2" title="3">args = append(args, argValue.String())</span>
                        }
                }
                
                // Generate function call with the evaluated function name
                <span class="cov1" title="2">argsStr := strings.Join(args, ", ")
                code := fmt.Sprintf("%s(%s)", funcName, argsStr)
                return analysis.NewBasicValue(code, "interface{}"), nil</span>
        }
        
        <span class="cov9" title="461">funcName := g.nodeToString(funcNameNode)

        // Extract arguments - pre-allocate with estimated capacity
        args := make([]string, 0, childCount-3)
        for i := 2; i &lt; childCount-1; i++ </span><span class="cov9" title="871">{ // Skip '(' and ')'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov9" title="871">{
                        // For macro definitions, don't visit children recursively
                        if funcName == "macro" </span><span class="cov6" title="78">{
                                // Just get the text representation
                                args = append(args, g.nodeToString(child))
                        }</span> else<span class="cov9" title="793"> {
                                argValue, err := g.visitNode(child)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov9" title="793">args = append(args, argValue.String())</span>
                        }
                }
        }

        // Generate code based on function type
        <span class="cov9" title="461">switch funcName </span>{
        case "def":<span class="cov7" title="119">
                return g.generateDef(args)</span>
        case "if":<span class="cov4" title="21">
                return g.generateIf(args)</span>
        case "do":<span class="cov4" title="14">
                return g.generateDo(args)</span>
        case "fn":<span class="cov5" title="29">
                return g.generateFn(args)</span>
        case "macro":<span class="cov5" title="26">
                return g.generateMacro(args)</span>
        case "import":<span class="cov5" title="23">
                return g.generateImport(args)</span>
        case "+", "-", "*", "/":<span class="cov6" title="78">
                return g.generateArithmetic(funcName, args)</span>
        case "&gt;", "&lt;", "=":<span class="cov4" title="19">
                return g.generateComparison(funcName, args)</span>
        case "get", "slice", "len", "append":<span class="cov6" title="52">
                return g.generatePrimitiveOp(funcName, args)</span>
        default:<span class="cov6" title="80">
                return g.generateFunctionCall(funcName, args)</span>
        }
}

// VisitArray generates code for an array literal
func (g *GoCodeGenerator) VisitArray(ctx *parser.ArrayContext) (Value, error) <span class="cov6" title="95">{
        var elements []string
        
        // Process all children except '[' and ']'
        for i := 1; i &lt; ctx.GetChildCount()-1; i++ </span><span class="cov7" title="166">{
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov7" title="166">{
                        elementValue, err := g.visitNode(child)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov7" title="166">elements = append(elements, elementValue.String())</span>
                }
        }
        
        <span class="cov6" title="95">arrayCode := fmt.Sprintf("[]interface{}{%s}", strings.Join(elements, ", "))
        return analysis.NewBasicValue(arrayCode, "[]interface{}"), nil</span>
}

// VisitTerminal generates code for a terminal node
func (g *GoCodeGenerator) VisitTerminal(node antlr.TerminalNode) (Value, error) <span class="cov9" title="679">{
        text := node.GetText()
        
        // Handle string literals
        if strings.HasPrefix(text, "\"") &amp;&amp; strings.HasSuffix(text, "\"") </span><span class="cov7" title="112">{
                return analysis.NewBasicValue(text, "string"), nil
        }</span>
        
        // Handle numbers
        <span class="cov9" title="567">if isNumber(text) </span><span class="cov8" title="333">{
                return analysis.NewBasicValue(text, "int"), nil
        }</span>
        
        // Handle booleans
        <span class="cov8" title="234">if text == "true" || text == "false" </span><span class="cov4" title="13">{
                return analysis.NewBasicValue(text, "bool"), nil
        }</span>
        
        // Handle symbols (convert hyphens to underscores for Go compatibility)
        <span class="cov8" title="221">goIdentifier := convertVexToGoIdentifier(text)
        return analysis.NewBasicValue(goIdentifier, "symbol"), nil</span>
}

// Code generation methods for different constructs
func (g *GoCodeGenerator) generateDef(args []string) (Value, error) <span class="cov7" title="119">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("def requires name and value")
        }</span>
        
        <span class="cov7" title="119">name := args[0]
        value := args[1]
        
        // Return assignment syntax for top-level processing
        result := name + " := " + value
        return analysis.NewBasicValue(result, "var"), nil</span>
}

func (g *GoCodeGenerator) generateIf(args []string) (Value, error) <span class="cov4" title="21">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("if requires condition and then-branch")
        }</span>
        
        <span class="cov4" title="21">condition := g.convertConditionToInfix(args[0])
        thenBranch := args[1]
        
        if len(args) &gt; 2 </span><span class="cov4" title="20">{
                elseBranch := args[2]
                code := fmt.Sprintf("func() interface{} { if %s { return %s } else { return %s } }()", 
                        condition, thenBranch, elseBranch)
                return analysis.NewBasicValue(code, "interface{}"), nil
        }</span> else<span class="cov1" title="1"> {
                code := fmt.Sprintf("func() interface{} { if %s { return %s } else { return nil } }()", 
                        condition, thenBranch)
                return analysis.NewBasicValue(code, "interface{}"), nil
        }</span>
}

// convertConditionToInfix converts function call format to infix for conditions
func (g *GoCodeGenerator) convertConditionToInfix(condition string) string <span class="cov4" title="21">{
        // Handle compile-time optimization for empty array checks
        if condition == "(len([]interface{}{}) == 0)" </span><span class="cov1" title="2">{
                return "true"
        }</span>
        
        // No need for conversion anymore since comparisons already generate proper infix
        <span class="cov4" title="19">return condition</span>
}

func (g *GoCodeGenerator) generateFn(args []string) (Value, error) <span class="cov5" title="29">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fn requires parameter list and body")
        }</span>
        
        <span class="cov5" title="29">paramList := args[0]
        body := args[1]
        
        // Parse parameter list
        params := g.parseParameterList(paramList)
        
        // Generate parameter declarations
        paramDecls := make([]string, len(params))
        for i, param := range params </span><span class="cov5" title="37">{
                paramDecls[i] = fmt.Sprintf("%s interface{}", param)
        }</span>
        
        <span class="cov5" title="29">paramString := strings.Join(paramDecls, ", ")
        
        // Generate function literal
        code := fmt.Sprintf("func(%s) interface{} { return %s }", paramString, body)
        return analysis.NewBasicValue(code, "func"), nil</span>
}

func (g *GoCodeGenerator) generateImport(args []string) (Value, error) <span class="cov5" title="23">{
        if len(args) &lt; 1 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("import requires package path")
        }</span>
        
        <span class="cov5" title="22">importPath := strings.Trim(args[0], "\"")
        g.AddImport(importPath)
        
        // Return a meaningful value for implicit returns
        return analysis.NewBasicValue("\"import completed\" // Import statement result", "string"), nil</span>
}

func (g *GoCodeGenerator) generateArithmetic(op string, args []string) (Value, error) <span class="cov6" title="78">{
        if len(args) &lt; 2 </span><span class="cov2" title="3">{
                return analysis.NewBasicValue("0", "int"), nil
        }</span>
        
        // Left-associative chaining for multiple operands
        <span class="cov6" title="75">result := "(" + args[0] + " " + op + " " + args[1] + ")"
        for i := 2; i &lt; len(args); i++ </span><span class="cov2" title="4">{
                result = "(" + result + " " + op + " " + args[i] + ")"
        }</span>
        
        <span class="cov6" title="75">return analysis.NewBasicValue(result, "int"), nil</span>
}

func (g *GoCodeGenerator) generateComparison(op string, args []string) (Value, error) <span class="cov4" title="19">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return analysis.NewBasicValue("false", "bool"), nil
        }</span>
        
        // Convert Vex operators to Go operators
        <span class="cov4" title="19">goOp := op
        if op == "=" </span><span class="cov3" title="9">{
                goOp = "=="
        }</span>
        
        // Generate infix format as expected by tests: (a == b)
        <span class="cov4" title="19">result := "(" + args[0] + " " + goOp + " " + args[1] + ")"
        return analysis.NewBasicValue(result, "bool"), nil</span>
}

func (g *GoCodeGenerator) generateDo(args []string) (Value, error) <span class="cov4" title="14">{
        if len(args) == 0 </span><span class="cov1" title="1">{
                return analysis.NewBasicValue("func() interface{} { return nil }()", "interface{}"), nil
        }</span>
        
        // Generate a function that executes all expressions and returns the last one
        <span class="cov4" title="13">var statements []string
        for i, arg := range args </span><span class="cov5" title="24">{
                // Convert def assignments to function call format inside do blocks
                processedArg := arg
                if strings.Contains(arg, " := ") </span><span class="cov3" title="5">{
                        // Convert "x := 10" to "def(x, 10)"
                        parts := strings.Split(arg, " := ")
                        if len(parts) == 2 </span><span class="cov3" title="5">{
                                processedArg = "def(" + strings.TrimSpace(parts[0]) + ", " + strings.TrimSpace(parts[1]) + ")"
                        }</span>
                }
                
                <span class="cov5" title="24">if i == len(args)-1 </span><span class="cov4" title="13">{
                        // Last expression is the return value
                        statements = append(statements, "return "+processedArg)
                }</span> else<span class="cov4" title="11"> {
                        // Other expressions are executed for side effects
                        statements = append(statements, processedArg)
                }</span>
        }
        
        <span class="cov4" title="13">result := "func() interface{} { " + strings.Join(statements, "; ") + " }()"
        return analysis.NewBasicValue(result, "interface{}"), nil</span>
}

func (g *GoCodeGenerator) generatePrimitiveOp(op string, args []string) (Value, error) <span class="cov6" title="52">{
        switch op </span>{
        case "get":<span class="cov4" title="12">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return analysis.NewBasicValue("nil", "interface{}"), nil
                }</span>
                // Array/slice access with bounds checking
                <span class="cov4" title="12">code := fmt.Sprintf("func() interface{} { if len(%s) &gt; %s { return %s[%s] } else { return nil } }()", args[0], args[1], args[0], args[1])
                return analysis.NewBasicValue(code, "interface{}"), nil</span>
        case "slice":<span class="cov4" title="10">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return analysis.NewBasicValue("[]interface{}{}", "[]interface{}"), nil
                }</span>
                // Slice operation with bounds checking
                <span class="cov4" title="10">code := fmt.Sprintf("func() []interface{} { if len(%s) &gt; %s { return %s[%s:] } else { return []interface{}{} } }()", args[0], args[1], args[0], args[1])
                return analysis.NewBasicValue(code, "[]interface{}"), nil</span>
        case "len":<span class="cov4" title="20">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        return analysis.NewBasicValue("0", "int"), nil
                }</span>
                // Simple len() function call
                <span class="cov4" title="20">code := fmt.Sprintf("len(%s)", args[0])
                return analysis.NewBasicValue(code, "int"), nil</span>
        case "append":<span class="cov4" title="10">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return analysis.NewBasicValue("[]interface{}{}", "[]interface{}"), nil
                }</span>
                // Append operation - use spread operator for array arguments
                <span class="cov4" title="10">code := fmt.Sprintf("append(%s, %s...)", args[0], args[1])
                return analysis.NewBasicValue(code, "[]interface{}"), nil</span>
        default:<span class="cov0" title="0">
                return analysis.NewBasicValue("nil", "interface{}"), nil</span>
        }
}

func (g *GoCodeGenerator) generateFunctionCall(funcName string, args []string) (Value, error) <span class="cov6" title="80">{
        // Handle package/function notation
        if strings.Contains(funcName, "/") </span><span class="cov5" title="29">{
                funcName = strings.ReplaceAll(funcName, "/", ".")
        }</span>
        
        // Special case: handle variable access in packages (like os.Args)
        <span class="cov6" title="80">if len(args) == 0 &amp;&amp; isPackageVariable(funcName) </span><span class="cov1" title="2">{
                // This is a variable access, not a function call
                code := funcName
                return analysis.NewBasicValue(code, "interface{}"), nil
        }</span>
        
        // Generate function call
        <span class="cov6" title="78">argsStr := strings.Join(args, ", ")
        code := fmt.Sprintf("%s(%s)", funcName, argsStr)
        
        return analysis.NewBasicValue(code, "interface{}"), nil</span>
}

// Helper methods
func (g *GoCodeGenerator) visitNode(node antlr.Tree) (Value, error) <span class="cov10" title="962">{
        switch n := node.(type) </span>{
        case *parser.ListContext:<span class="cov7" title="188">
                return g.VisitList(n)</span>
        case *parser.ArrayContext:<span class="cov6" title="95">
                return g.VisitArray(n)</span>
        case antlr.TerminalNode:<span class="cov9" title="679">
                return g.VisitTerminal(n)</span>
        default:<span class="cov0" title="0">
                return analysis.NewBasicValue("unknown", "interface{}"), nil</span>
        }
}

func (g *GoCodeGenerator) nodeToString(node antlr.Tree) string <span class="cov9" title="812">{
        if terminal, ok := node.(antlr.TerminalNode); ok </span><span class="cov9" title="758">{
                return terminal.GetText()
        }</span>
        <span class="cov6" title="54">if ctx, ok := node.(antlr.RuleNode); ok </span><span class="cov6" title="54">{
                return ctx.GetText()
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

func (g *GoCodeGenerator) parseParameterList(paramList string) []string <span class="cov5" title="29">{
        // Handle array syntax [param1 param2] or []interface{}{param1, param2}
        trimmed := strings.TrimSpace(paramList)
        
        if strings.HasPrefix(trimmed, "[") &amp;&amp; strings.HasSuffix(trimmed, "]") &amp;&amp; !strings.Contains(trimmed, "interface{}") </span><span class="cov0" title="0">{
                // Vex format
                inner := strings.TrimSpace(trimmed[1 : len(trimmed)-1])
                if inner == "" </span><span class="cov0" title="0">{
                        return []string{}
                }</span>
                <span class="cov0" title="0">return strings.Fields(inner)</span>
        } else<span class="cov5" title="29"> if strings.HasPrefix(trimmed, "[]interface{}") </span><span class="cov5" title="28">{
                // Go format
                if start := strings.Index(trimmed, "}{"); start != -1 </span><span class="cov5" title="28">{
                        start += 2
                        if end := strings.LastIndex(trimmed, "}"); end &gt; start </span><span class="cov5" title="24">{
                                inner := strings.TrimSpace(trimmed[start:end])
                                if inner == "" </span><span class="cov0" title="0">{
                                        return []string{}
                                }</span>
                                <span class="cov5" title="24">params := strings.Split(inner, ",")
                                for i, param := range params </span><span class="cov5" title="37">{
                                        params[i] = strings.TrimSpace(param)
                                }</span>
                                <span class="cov5" title="24">return params</span>
                        }
                }
        }
        
        <span class="cov3" title="5">return []string{}</span>
}

func (g *GoCodeGenerator) buildFinalCode() string <span class="cov7" title="193">{
        var result strings.Builder
        
        // Package declaration
        result.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))
        
        // Imports
        if len(g.imports) &gt; 0 </span><span class="cov4" title="17">{
                for importPath := range g.imports </span><span class="cov4" title="21">{
                        result.WriteString(fmt.Sprintf("import \"%s\"\n", importPath))
                }</span>
                <span class="cov4" title="17">result.WriteString("\n")</span>
        }
        
        // Main function
        <span class="cov7" title="193">result.WriteString("func main() {\n")
        
        // Add the generated code with proper indentation
        lines := strings.Split(g.output.String(), "\n")
        for _, line := range lines </span><span class="cov9" title="716">{
                if strings.TrimSpace(line) != "" </span><span class="cov9" title="523">{
                        result.WriteString("\t" + line + "\n")
                }</span>
        }
        
        <span class="cov7" title="193">result.WriteString("}\n")
        
        return result.String()</span>
}

func isNumber(s string) bool <span class="cov9" title="567">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov9" title="567">for _, r := range s </span><span class="cov9" title="594">{
                if r &lt; '0' || r &gt; '9' </span><span class="cov8" title="234">{
                        return false
                }</span>
        }
        <span class="cov8" title="333">return true</span>
}

// convertVexToGoIdentifier converts Vex identifiers (with hyphens) to Go identifiers (with underscores)
func convertVexToGoIdentifier(vexIdentifier string) string <span class="cov8" title="221">{
        return strings.ReplaceAll(vexIdentifier, "-", "_")
}</span>

// isPackageVariable checks if a name refers to a package variable (not a function)
func isPackageVariable(name string) bool <span class="cov3" title="6">{
        // Known package variables
        packageVars := map[string]bool{
                "os.Args": true,
                // Add more as needed
        }
        return packageVars[name]
}</span>

// Interface types (to avoid import cycles)
type AST interface {
        Accept(visitor ASTVisitor) error
}

type ASTVisitor interface {
        VisitProgram(ctx *parser.ProgramContext) error
        VisitList(ctx *parser.ListContext) (Value, error)
        VisitArray(ctx *parser.ArrayContext) (Value, error)
        VisitTerminal(node antlr.TerminalNode) (Value, error)
}

type Value interface {
        String() string
        Type() string
}

type SymbolTable interface {
        Define(name string, value Value) error
        Lookup(name string) (Value, bool)
        EnterScope()
        ExitScope()
}

// generateMacro handles macro definitions (compile-time constructs)
func (g *GoCodeGenerator) generateMacro(args []string) (Value, error) <span class="cov5" title="26">{
        // Macro definitions are compile-time constructs and don't generate runtime code
        // They are handled by the macro expansion phase, so we just return a no-op
        return analysis.NewBasicValue("", "void"), nil
}</pre>
		
		<pre class="file" id="file6" style="display: none">// Package transpiler provides a minimal Vex to Go transpiler
package transpiler

import (
        "fmt"
)

// Transpiler interface for the new architecture
type Transpiler interface {
        TranspileFromInput(input string) (string, error)
        TranspileFromFile(filename string) (string, error)
        GetDetectedModules() map[string]string
}

// New creates a new transpiler instance
func New() Transpiler <span class="cov10" title="207">{
        transpiler, err := NewVexTranspiler()
        if err != nil </span><span class="cov0" title="0">{
                // In practice, this shouldn't happen with default config
                panic(fmt.Sprintf("Failed to create transpiler: %v", err))</span>
        }
        <span class="cov10" title="207">return transpiler</span>
}

// NewWithDebug creates a new transpiler instance with debug mode enabled
func NewWithDebug() Transpiler <span class="cov1" title="1">{
        // For now, return the same as New() - debug mode will be configurable later
        return New()
}</pre>
		
		<pre class="file" id="file7" style="display: none">package transpiler

import (
        "fmt"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/macro"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// Value represents a value in the Vex language
type Value interface {
        String() string
        Type() string
}

// AST represents an abstract syntax tree
type AST interface {
        Root() antlr.Tree
        Accept(visitor ASTVisitor) error
}

// ConcreteAST is a concrete implementation that bridges different AST types
type ConcreteAST struct {
        root antlr.Tree
}

func NewConcreteAST(root antlr.Tree) *ConcreteAST <span class="cov10" title="400">{
        return &amp;ConcreteAST{root: root}
}</span>

func (ast *ConcreteAST) Root() antlr.Tree <span class="cov8" title="202">{
        return ast.root
}</span>

func (ast *ConcreteAST) Accept(visitor ASTVisitor) error <span class="cov9" title="382">{
        if programCtx, ok := ast.root.(*parser.ProgramContext); ok </span><span class="cov9" title="382">{
                return visitor.VisitProgram(programCtx)
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("invalid AST root type")</span>
}

// ASTVisitor defines the interface for visiting AST nodes
type ASTVisitor interface {
        VisitProgram(ctx *parser.ProgramContext) error
        VisitList(ctx *parser.ListContext) (Value, error)
        VisitArray(ctx *parser.ArrayContext) (Value, error)
        VisitTerminal(node antlr.TerminalNode) (Value, error)
}

// MacroExpander handles macro expansion
type MacroExpander interface {
        ExpandMacros(ast AST) (AST, error)
        RegisterMacro(name string, macro *macro.Macro) error
        HasMacro(name string) bool
        GetMacro(name string) (*macro.Macro, bool)
}

// SymbolTable manages variable and function definitions
type SymbolTable interface {
        Define(name string, value Value) error
        Lookup(name string) (Value, bool)
        EnterScope() 
        ExitScope()
}

// ErrorReporter handles error reporting and collection
type ErrorReporter interface {
        ReportError(line, column int, message string)
        ReportWarning(line, column int, message string)
        HasErrors() bool
        GetErrors() []Error
}

// CodeGenerator generates target code from AST
type CodeGenerator interface {
        Generate(ast AST, symbols SymbolTable) (string, error)
        AddImport(importPath string)
        SetPackageName(name string)
}

// Parser handles parsing of source code into AST
type Parser interface {
        Parse(input string) (AST, error)
        ParseFile(filename string) (AST, error)
}

// Analyzer performs semantic analysis
type Analyzer interface {
        Analyze(ast AST) (SymbolTable, error)
        SetErrorReporter(reporter ErrorReporter)
}

// Error represents a compilation error
type Error struct {
        Line    int
        Column  int
        Message string
        Type    ErrorType
}

type ErrorType int

const (
        SyntaxError ErrorType = iota
        SemanticError
        MacroError
        TypeError
)

// TranspilerConfig holds configuration for the transpiler
type TranspilerConfig struct {
        EnableMacros     bool
        CoreMacroPath    string
        PackageName      string
        GenerateComments bool
}</pre>
		
		<pre class="file" id="file8" style="display: none">package macro

import (
        "fmt"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// Expander handles macro expansion in AST
type Expander struct {
        registry *Registry
}

// NewExpander creates a new macro expander
func NewExpander(registry *Registry) *Expander <span class="cov6" title="226">{
        return &amp;Expander{
                registry: registry,
        }
}</span>

// ExpandMacro expands a single macro call
func (e *Expander) ExpandMacro(macroName string, args []string) (string, error) <span class="cov5" title="109">{
        macro, exists := e.registry.GetMacro(macroName)
        if !exists </span><span class="cov1" title="2">{
                return "", fmt.Errorf("macro '%s' not found", macroName)
        }</span>

        <span class="cov5" title="107">if len(args) != len(macro.Params) </span><span class="cov3" title="13">{
                return "", fmt.Errorf("macro '%s' expects %d arguments, got %d", 
                        macroName, len(macro.Params), len(args))
        }</span>

        // Substitute parameters in macro body
        <span class="cov5" title="94">expanded := e.substituteParameters(macro.Body, macro.Params, args)
        
        // Recursively expand any nested macros
        return e.recursivelyExpandMacros(expanded)</span>
}

// substituteParameters substitutes macro parameters with arguments
func (e *Expander) substituteParameters(body string, params []string, args []string) string <span class="cov5" title="98">{
        // Create parameter mapping with recursive expansion of arguments
        paramMap := make(map[string]string)
        for i, param := range params </span><span class="cov6" title="149">{
                if i &lt; len(args) </span><span class="cov6" title="149">{
                        // Recursively expand any macros in the argument
                        expandedArg, _ := e.recursivelyExpandMacros(args[i])
                        paramMap[param] = expandedArg
                }</span>
        }

        // Handle simple parameter substitution
        <span class="cov5" title="98">if len(params) == 1 &amp;&amp; strings.TrimSpace(body) == params[0] </span><span class="cov1" title="2">{
                return paramMap[params[0]]
        }</span>

        // Try AST-based substitution for complex expressions
        <span class="cov5" title="96">return e.substituteParametersInAST(body, paramMap)</span>
}

// substituteParametersInAST performs AST-aware parameter substitution
func (e *Expander) substituteParametersInAST(body string, paramMap map[string]string) string <span class="cov5" title="96">{
        // Try to parse the body as an expression
        inputStream := antlr.NewInputStream(body)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)

        // Try parsing as different constructs
        if tree := vexParser.Program(); tree != nil </span><span class="cov5" title="96">{
                if programCtx, ok := tree.(*parser.ProgramContext); ok </span><span class="cov5" title="96">{
                        if len(programCtx.GetChildren()) &gt; 0 </span><span class="cov5" title="96">{
                                substituted := e.substituteInNode(programCtx.GetChildren()[0], paramMap)
                                return e.reconstructVexSyntax(substituted)
                        }</span>
                }
        }

        // Fallback to word-boundary replacement
        <span class="cov0" title="0">result := body
        for param, arg := range paramMap </span><span class="cov0" title="0">{
                result = e.replaceWholeWord(result, param, arg)
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// substituteInNode recursively substitutes parameters in an AST node
func (e *Expander) substituteInNode(node antlr.Tree, paramMap map[string]string) antlr.Tree <span class="cov7" title="734">{
        switch n := node.(type) </span>{
        case *parser.ListContext:<span class="cov6" title="127">
                return e.substituteInList(n, paramMap)</span>
        case *parser.ArrayContext:<span class="cov3" title="9">
                return e.substituteInArray(n, paramMap)</span>
        case *antlr.TerminalNodeImpl:<span class="cov7" title="597">
                if replacement, exists := paramMap[n.GetText()]; exists </span><span class="cov6" title="151">{
                        return &amp;substitutedTerminal{text: replacement}
                }</span>
                <span class="cov7" title="446">return n</span>
        case antlr.TerminalNode:<span class="cov1" title="1">
                if replacement, exists := paramMap[n.GetText()]; exists </span><span class="cov0" title="0">{
                        return &amp;substitutedTerminal{text: replacement}
                }</span>
                <span class="cov1" title="1">return n</span>
        default:<span class="cov0" title="0">
                return n</span>
        }
}

// substituteInList handles substitution in list contexts
func (e *Expander) substituteInList(ctx *parser.ListContext, paramMap map[string]string) antlr.Tree <span class="cov6" title="127">{
        // Reconstruct the list with substituted children
        var parts []string
        for _, child := range ctx.GetChildren() </span><span class="cov7" title="611">{
                if child != nil </span><span class="cov7" title="611">{
                        substituted := e.substituteInNode(child, paramMap)
                        parts = append(parts, e.reconstructVexSyntax(substituted))
                }</span>
        }
        
        // Use smart spacing like in reconstructVexSyntax
        <span class="cov6" title="127">reconstructed := ""
        for i, part := range parts </span><span class="cov7" title="611">{
                if i == 0 </span><span class="cov6" title="127">{
                        reconstructed += part // First part (usually '(')
                }</span> else<span class="cov7" title="484"> if part == ")" </span><span class="cov6" title="127">{
                        reconstructed += part // Last part, no space before
                }</span> else<span class="cov7" title="357"> if parts[i-1] == "(" </span><span class="cov6" title="127">{
                        reconstructed += part // No space after opening parenthesis
                }</span> else<span class="cov6" title="230"> {
                        reconstructed += " " + part // Add space before other parts
                }</span>
        }
        
        // Parse the reconstructed expression back into an AST node
        <span class="cov6" title="127">inputStream := antlr.NewInputStream(reconstructed)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)
        
        if listTree := vexParser.List(); listTree != nil </span><span class="cov6" title="127">{
                return listTree.(*parser.ListContext)
        }</span>
        
        <span class="cov0" title="0">return ctx</span> // Fallback
}

// substituteInArray handles substitution in array contexts
func (e *Expander) substituteInArray(ctx *parser.ArrayContext, paramMap map[string]string) antlr.Tree <span class="cov3" title="9">{
        // Similar to substituteInList but for arrays
        var parts []string
        for _, child := range ctx.GetChildren() </span><span class="cov4" title="27">{
                if child != nil </span><span class="cov4" title="27">{
                        substituted := e.substituteInNode(child, paramMap)
                        parts = append(parts, e.reconstructVexSyntax(substituted))
                }</span>
        }
        
        <span class="cov3" title="9">reconstructed := strings.Join(parts, " ")
        
        // Parse back into array
        inputStream := antlr.NewInputStream(reconstructed)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)
        
        if arrayTree := vexParser.Array(); arrayTree != nil </span><span class="cov3" title="9">{
                return arrayTree.(*parser.ArrayContext)
        }</span>
        
        <span class="cov0" title="0">return ctx</span> // Fallback
}

// recursivelyExpandMacros expands nested macros in an expression
func (e *Expander) recursivelyExpandMacros(expr string) (string, error) <span class="cov6" title="253">{
        // Check if the expression contains macro calls
        if !strings.Contains(expr, "(") </span><span class="cov6" title="134">{
                return expr, nil // No function calls, return as-is
        }</span>

        // For simple cases, check if the entire expression is a known macro
        <span class="cov5" title="119">trimmed := strings.TrimSpace(expr)
        if strings.HasPrefix(trimmed, "(") &amp;&amp; strings.HasSuffix(trimmed, ")") </span><span class="cov5" title="118">{
                // Extract the parts manually for simple cases
                inner := strings.TrimSpace(trimmed[1 : len(trimmed)-1])
                parts := strings.Fields(inner)

                if len(parts) &gt;= 1 </span><span class="cov5" title="118">{
                        macroName := parts[0]
                        if e.registry.HasMacro(macroName) </span><span class="cov2" title="3">{
                                // Extract arguments
                                args := parts[1:]

                                // Recursively expand arguments first
                                expandedArgs := make([]string, len(args))
                                for i, arg := range args </span><span class="cov2" title="3">{
                                        expanded, err := e.recursivelyExpandMacros(arg)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return expr, err
                                        }</span>
                                        <span class="cov2" title="3">expandedArgs[i] = expanded</span>
                                }

                                // Expand this macro
                                <span class="cov2" title="3">result, err := e.ExpandMacro(macroName, expandedArgs)
                                if err != nil </span><span class="cov0" title="0">{
                                        return expr, err
                                }</span>

                                // Check if the result contains more macros
                                <span class="cov2" title="3">if result != expr &amp;&amp; strings.Contains(result, "(") </span><span class="cov2" title="3">{
                                        return e.recursivelyExpandMacros(result)
                                }</span>

                                <span class="cov0" title="0">return result, nil</span>
                        }
                }
        }

        <span class="cov5" title="116">return expr, nil</span>
}

// replaceWholeWord replaces whole words with word boundaries
func (e *Expander) replaceWholeWord(text, param, arg string) string <span class="cov3" title="7">{
        result := ""
        i := 0
        for i &lt; len(text) </span><span class="cov3" title="12">{
                // Find the next occurrence of the parameter
                index := strings.Index(text[i:], param)
                if index == -1 </span><span class="cov2" title="4">{
                        result += text[i:]
                        break</span>
                }
                
                // Adjust index to absolute position
                <span class="cov3" title="8">index += i
                
                // Check if it's a whole word (not part of another identifier)
                isWholeWord := true
                
                // Check character before
                if index &gt; 0 </span><span class="cov2" title="4">{
                        prevChar := rune(text[index-1])
                        if e.isIdentifierChar(prevChar) </span><span class="cov0" title="0">{
                                isWholeWord = false
                        }</span>
                }
                
                // Check character after
                <span class="cov3" title="8">if index+len(param) &lt; len(text) </span><span class="cov2" title="5">{
                        nextChar := rune(text[index+len(param)])
                        if e.isIdentifierChar(nextChar) </span><span class="cov1" title="1">{
                                isWholeWord = false
                        }</span>
                }
                
                <span class="cov3" title="8">if isWholeWord </span><span class="cov3" title="7">{
                        // Replace the parameter
                        result += text[i:index] + arg
                        i = index + len(param)
                }</span> else<span class="cov1" title="1"> {
                        // Not a whole word, skip this occurrence
                        result += text[i:index+1]
                        i = index + 1
                }</span>
        }
        
        <span class="cov3" title="7">return result</span>
}

// isIdentifierChar checks if a character can be part of an identifier
func (e *Expander) isIdentifierChar(r rune) bool <span class="cov4" title="22">{
        return (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || 
                   (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '_' || r == '-' || r == '?' || r == '!'
}</span>

// reconstructVexSyntax reconstructs Vex syntax from an AST node
func (e *Expander) reconstructVexSyntax(node antlr.Tree) string <span class="cov10" title="5604">{
        switch n := node.(type) </span>{
        case *parser.ListContext:<span class="cov7" title="577">
                var parts []string
                for _, child := range n.GetChildren() </span><span class="cov9" title="2820">{
                        if child != nil </span><span class="cov9" title="2820">{
                                parts = append(parts, e.reconstructVexSyntax(child))
                        }</span>
                }
                // Smart spacing: spaces between tokens but not around parentheses
                <span class="cov7" title="577">result := ""
                for i, part := range parts </span><span class="cov9" title="2820">{
                        if i == 0 </span><span class="cov7" title="577">{
                                result += part // First part (usually '(')
                        }</span> else<span class="cov9" title="2243"> if part == ")" </span><span class="cov7" title="577">{
                                result += part // Last part, no space before
                        }</span> else<span class="cov8" title="1666"> if parts[i-1] == "(" </span><span class="cov7" title="577">{
                                result += part // No space after opening parenthesis
                        }</span> else<span class="cov8" title="1089"> {
                                result += " " + part // Add space before other parts
                        }</span>
                }
                <span class="cov7" title="577">return result</span>
        case *parser.ArrayContext:<span class="cov7" title="320">
                var parts []string
                for _, child := range n.GetChildren() </span><span class="cov8" title="1163">{
                        if child != nil </span><span class="cov8" title="1163">{
                                parts = append(parts, e.reconstructVexSyntax(child))
                        }</span>
                }
                <span class="cov7" title="320">return strings.Join(parts, " ")</span>
        case *parser.ProgramContext:<span class="cov0" title="0">
                if len(n.GetChildren()) &gt; 0 </span><span class="cov0" title="0">{
                        return e.reconstructVexSyntax(n.GetChildren()[0])
                }</span>
                <span class="cov0" title="0">return ""</span>
        case *substitutedTerminal:<span class="cov6" title="152">
                return n.GetText()</span>
        case *antlr.TerminalNodeImpl:<span class="cov9" title="4554">
                return n.GetText()</span>
        case antlr.TerminalNode:<span class="cov1" title="1">
                return n.GetText()</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// substitutedTerminal represents a terminal node with substituted text
type substitutedTerminal struct {
        text string
}

func (s *substitutedTerminal) GetText() string <span class="cov6" title="153">{ return s.text }</span>
func (s *substitutedTerminal) GetSymbol() antlr.Token <span class="cov1" title="1">{ return nil }</span>
func (s *substitutedTerminal) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov1" title="1">{ return nil }</span>
func (s *substitutedTerminal) GetChild(i int) antlr.Tree <span class="cov1" title="1">{ return nil }</span>
func (s *substitutedTerminal) GetChildCount() int <span class="cov1" title="1">{ return 0 }</span>
func (s *substitutedTerminal) GetChildren() []antlr.Tree <span class="cov1" title="1">{ return nil }</span>
func (s *substitutedTerminal) GetParent() antlr.Tree <span class="cov1" title="1">{ return nil }</span>
func (s *substitutedTerminal) GetPayload() interface{} <span class="cov1" title="1">{ return s.text }</span>
func (s *substitutedTerminal) GetSourceInterval() antlr.Interval <span class="cov1" title="1">{ return antlr.Interval{Start: -1, Stop: -1} }</span>
func (s *substitutedTerminal) SetParent(parent antlr.Tree) {<span class="cov1" title="1">}</span>
func (s *substitutedTerminal) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov1" title="1">{ return s.text }</pre>
		
		<pre class="file" id="file9" style="display: none">package macro

import (
        "fmt"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// MacroExpanderImpl implements the MacroExpander interface
type MacroExpanderImpl struct {
        *Expander
        registry *Registry
}

// NewMacroExpander creates a new macro expander that implements the interface
func NewMacroExpander(registry *Registry) *MacroExpanderImpl <span class="cov7" title="217">{
        return &amp;MacroExpanderImpl{
                Expander: NewExpander(registry),
                registry: registry,
        }
}</span>

// ExpandMacros expands all macros in an AST
func (me *MacroExpanderImpl) ExpandMacros(ast AST) (AST, error) <span class="cov7" title="203">{
        // Get the root node
        root := ast.Root()
        
        // Expand macros in the tree
        expandedRoot, err := me.expandMacrosInTree(root)
        if err != nil </span><span class="cov3" title="10">{
                return nil, err
        }</span>
        
        // Return new AST with expanded tree
        <span class="cov7" title="193">return NewVexAST(expandedRoot), nil</span>
}

// RegisterMacro registers a macro
func (me *MacroExpanderImpl) RegisterMacro(name string, macro *Macro) error <span class="cov2" title="3">{
        return me.registry.RegisterMacro(name, macro)
}</span>

// HasMacro checks if a macro exists
func (me *MacroExpanderImpl) HasMacro(name string) bool <span class="cov2" title="3">{
        return me.registry.HasMacro(name)
}</span>

// GetMacro retrieves a macro
func (me *MacroExpanderImpl) GetMacro(name string) (*Macro, bool) <span class="cov1" title="2">{
        return me.registry.GetMacro(name)
}</span>

// expandMacrosInTree recursively expands macros in an AST tree
func (me *MacroExpanderImpl) expandMacrosInTree(node antlr.Tree) (antlr.Tree, error) <span class="cov10" title="1807">{
        switch n := node.(type) </span>{
        case *parser.ProgramContext:<span class="cov7" title="204">
                return me.expandMacrosInProgram(n)</span>
        case *parser.ListContext:<span class="cov7" title="154">
                return me.expandMacrosInList(n)</span>
        case *parser.ArrayContext:<span class="cov6" title="79">
                return me.expandMacrosInArray(n)</span>
        default:<span class="cov9" title="1370">
                return node, nil</span> // Terminal nodes don't need expansion
        }
}

// expandMacrosInProgram expands macros in a program context
func (me *MacroExpanderImpl) expandMacrosInProgram(ctx *parser.ProgramContext) (antlr.Tree, error) <span class="cov7" title="204">{
        // Collect all expanded children
        var expandedChildren []antlr.Tree
        hasChanges := false
        
        for _, child := range ctx.GetChildren() </span><span class="cov8" title="472">{
                if listCtx, ok := child.(*parser.ListContext); ok </span><span class="cov7" title="275">{
                        expanded, err := me.expandMacrosInList(listCtx)
                        if err != nil </span><span class="cov3" title="10">{
                                return nil, err
                        }</span>
                        <span class="cov7" title="265">expandedChildren = append(expandedChildren, expanded)
                        // Check if the expansion actually changed the node
                        if expanded != listCtx </span><span class="cov6" title="84">{
                                hasChanges = true
                        }</span>
                } else<span class="cov7" title="197"> {
                        expandedChildren = append(expandedChildren, child)
                }</span>
        }
        
        // If no changes were made, return the original context
        <span class="cov7" title="194">if !hasChanges </span><span class="cov6" title="114">{
                return ctx, nil
        }</span>
        
        // Create a new program by re-parsing the expanded content
        <span class="cov6" title="80">return me.reconstructProgramFromChildren(expandedChildren)</span>
}

// expandMacrosInList expands macros in a list context
func (me *MacroExpanderImpl) expandMacrosInList(ctx *parser.ListContext) (antlr.Tree, error) <span class="cov8" title="432">{
        childCount := ctx.GetChildCount()
        if childCount &lt; 3 </span><span class="cov0" title="0">{ // Need at least: '(', function, ')'
                return ctx, nil
        }</span>

        // Get function name (first child after '(')
        <span class="cov8" title="432">funcNameNode := ctx.GetChild(1)
        funcName := me.nodeToString(funcNameNode)

        // Special case: macro definitions should not be expanded
        if funcName == "macro" </span><span class="cov5" title="32">{
                // This is a macro definition, not a call - don't expand it
                // Just register the macro and return the original context
                return me.processMacroDefinition(ctx)
        }</span>

        // Check if this is a macro call
        <span class="cov8" title="400">if me.registry.HasMacro(funcName) </span><span class="cov6" title="98">{
                // Extract arguments
                args := make([]string, 0)
                for i := 2; i &lt; childCount-1; i++ </span><span class="cov6" title="145">{ // Skip '(' and ')'
                        child := ctx.GetChild(i)
                        if child != nil </span><span class="cov6" title="145">{
                                // Recursively expand macros in arguments first
                                expandedChild, err := me.expandMacrosInTree(child)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov6" title="145">args = append(args, me.reconstructVexSyntax(expandedChild))</span>
                        }
                }

                // Expand the macro
                <span class="cov6" title="98">expanded, err := me.ExpandMacro(funcName, args)
                if err != nil </span><span class="cov3" title="10">{
                        return nil, err
                }</span>

                // Parse the expanded result back into an AST node
                <span class="cov6" title="88">return me.parseExpandedCode(expanded)</span>
        }

        // Not a macro call, but still need to recursively process children for nested macros
        <span class="cov7" title="302">hasChanges := false
        newChildren := make([]antlr.Tree, childCount)
        
        // Copy all children, recursively expanding any that need it
        for i := 0; i &lt; childCount; i++ </span><span class="cov9" title="1458">{
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov9" title="1458">{
                        expandedChild, err := me.expandMacrosInTree(child)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov9" title="1458">newChildren[i] = expandedChild
                        // Check if this child was actually changed
                        if expandedChild != child </span><span class="cov5" title="30">{
                                hasChanges = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        newChildren[i] = child
                }</span>
        }
        
        // If no changes were made, return original context
        <span class="cov7" title="302">if !hasChanges </span><span class="cov7" title="272">{
                return ctx, nil
        }</span>
        
        // Create a new list context with expanded children
        <span class="cov5" title="30">return me.reconstructListFromChildren(newChildren)</span>
}

// reconstructListFromChildren creates a new list context from expanded children
func (me *MacroExpanderImpl) reconstructListFromChildren(children []antlr.Tree) (antlr.Tree, error) <span class="cov5" title="30">{
        // For now, we'll reconstruct by creating Vex syntax and re-parsing
        // This is not the most efficient but ensures correctness
        
        var parts []string
        parts = append(parts, "(")
        
        for i := 1; i &lt; len(children)-1; i++ </span><span class="cov6" title="91">{ // Skip opening and closing parentheses
                if children[i] != nil </span><span class="cov6" title="91">{
                        parts = append(parts, me.reconstructVexSyntax(children[i]))
                }</span>
        }
        
        <span class="cov5" title="30">parts = append(parts, ")")
        vexCode := strings.Join(parts, " ")
        
        // Parse the reconstructed code back into an AST
        return me.parseExpandedCode(vexCode)</span>
}

// expandMacrosInArray expands macros in an array context
func (me *MacroExpanderImpl) expandMacrosInArray(ctx *parser.ArrayContext) (antlr.Tree, error) <span class="cov6" title="80">{
        // Arrays typically don't contain macro calls, but we should check elements
        for _, child := range ctx.GetChildren() </span><span class="cov7" title="302">{
                if listCtx, ok := child.(*parser.ListContext); ok </span><span class="cov1" title="2">{
                        _, err := me.expandMacrosInList(listCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }
        
        <span class="cov6" title="80">return ctx, nil</span>
}

// parseExpandedCode parses expanded macro code back into AST
func (me *MacroExpanderImpl) parseExpandedCode(code string) (antlr.Tree, error) <span class="cov6" title="122">{
        inputStream := antlr.NewInputStream(code)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)

        // Try to parse as a list first
        if listTree := vexParser.List(); listTree != nil </span><span class="cov6" title="122">{
                return listTree.(*parser.ListContext), nil
        }</span>

        // Reset and try as a program
        <span class="cov0" title="0">inputStream = antlr.NewInputStream(code)
        lexer = parser.NewVexLexer(inputStream)
        tokenStream = antlr.NewCommonTokenStream(lexer, 0)
        vexParser = parser.NewVexParser(tokenStream)

        if programTree := vexParser.Program(); programTree != nil </span><span class="cov0" title="0">{
                return programTree.(*parser.ProgramContext), nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to parse expanded macro code: %s", code)</span>
}

// Helper methods
func (me *MacroExpanderImpl) nodeToString(node antlr.Tree) string <span class="cov8" title="650">{
        // Always use reconstructVexSyntax for consistent spacing
        return me.Expander.reconstructVexSyntax(node)
}</span>

// Interface definitions (to avoid import cycles)
type AST interface {
        Root() antlr.Tree
        Accept(visitor ASTVisitor) error
}

type ASTVisitor interface {
        VisitProgram(ctx *parser.ProgramContext) error
        VisitList(ctx *parser.ListContext) (Value, error)
        VisitArray(ctx *parser.ArrayContext) (Value, error)
        VisitTerminal(node antlr.TerminalNode) (Value, error)
}

type Value interface {
        String() string
        Type() string
}

// VexAST implementation for macro expansion
type VexAST struct {
        root antlr.Tree
}

func NewVexAST(root antlr.Tree) *VexAST <span class="cov7" title="197">{
        return &amp;VexAST{root: root}
}</span>

func (ast *VexAST) Root() antlr.Tree <span class="cov7" title="195">{
        return ast.root
}</span>

func (ast *VexAST) Accept(visitor ASTVisitor) error <span class="cov1" title="2">{
        if programCtx, ok := ast.root.(*parser.ProgramContext); ok </span><span class="cov1" title="1">{
                return visitor.VisitProgram(programCtx)
        }</span>
        <span class="cov1" title="1">return fmt.Errorf("invalid AST root type")</span>
}

// processMacroDefinition handles macro definitions during expansion
func (me *MacroExpanderImpl) processMacroDefinition(ctx *parser.ListContext) (antlr.Tree, error) <span class="cov5" title="32">{
        childCount := ctx.GetChildCount()
        if childCount &lt; 5 </span><span class="cov2" title="3">{ // Need at least: '(', 'macro', name, params, body, ')'
                return ctx, nil // Let analyzer handle the error
        }</span>

        // Extract macro name
        <span class="cov5" title="29">nameNode := ctx.GetChild(2)
        macroName := me.nodeToString(nameNode)

        // Extract parameters
        paramsNode := ctx.GetChild(3)
        paramsStr := me.nodeToString(paramsNode)

        // Extract body
        bodyNode := ctx.GetChild(4)
        bodyStr := me.nodeToString(bodyNode)

        // Register the macro
        macro := &amp;Macro{
                Name:   macroName,
                Params: me.parseParameterList(paramsStr),
                Body:   bodyStr,
        }
        me.registry.RegisterMacro(macroName, macro)

        // Return the original context unchanged - macro definitions don't get expanded
        return ctx, nil</span>
}

// parseParameterList parses parameter list from string
func (me *MacroExpanderImpl) parseParameterList(paramStr string) []string <span class="cov5" title="29">{
        trimmed := strings.TrimSpace(paramStr)
        if strings.HasPrefix(trimmed, "[") &amp;&amp; strings.HasSuffix(trimmed, "]") </span><span class="cov5" title="29">{
                inner := strings.TrimSpace(trimmed[1 : len(trimmed)-1])
                if inner == "" </span><span class="cov1" title="2">{
                        return []string{}
                }</span>
                <span class="cov4" title="27">return strings.Fields(inner)</span>
        }
        <span class="cov0" title="0">return []string{}</span>
}

// reconstructProgramFromChildren creates a new program AST from expanded children
func (me *MacroExpanderImpl) reconstructProgramFromChildren(children []antlr.Tree) (antlr.Tree, error) <span class="cov6" title="80">{
        // Build the complete source code from all children, excluding EOF tokens
        var parts []string
        for _, child := range children </span><span class="cov7" title="212">{
                if child != nil </span><span class="cov7" title="212">{
                        // Skip EOF tokens and error nodes
                        if terminal, ok := child.(antlr.TerminalNode); ok </span><span class="cov6" title="82">{
                                if terminal.GetText() == "&lt;EOF&gt;" </span><span class="cov6" title="80">{
                                        continue</span>
                                }
                        }
                        <span class="cov6" title="132">if _, ok := child.(*antlr.ErrorNodeImpl); ok </span><span class="cov1" title="2">{
                                continue</span>
                        }
                        
                        <span class="cov6" title="130">childText := me.nodeToString(child)
                        if strings.TrimSpace(childText) != "" &amp;&amp; childText != "&lt;EOF&gt;" </span><span class="cov6" title="130">{
                                parts = append(parts, childText)
                        }</span>
                }
        }
        
        // Join with spaces for proper program structure
        <span class="cov6" title="80">programText := strings.Join(parts, " ")
        
        // Parse the reconstructed program
        inputStream := antlr.NewInputStream(programText)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)

        // Parse as a complete program
        if programTree := vexParser.Program(); programTree != nil </span><span class="cov6" title="80">{
                return programTree.(*parser.ProgramContext), nil
        }</span>
        
        <span class="cov0" title="0">return nil, fmt.Errorf("failed to reconstruct program AST from: %s", programText)</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package macro

import (
        "fmt"
        "os"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// Macro represents a registered macro with its parameters and body
type Macro struct {
        Name   string
        Params []string
        Body   string
}

// Registry manages macro registration and expansion
type Registry struct {
        macros     map[string]*Macro
        coreLoaded bool
        config     Config
}

// Config holds macro system configuration
type Config struct {
        CoreMacroPath    string
        EnableValidation bool
}

// NewRegistry creates a new macro registry
func NewRegistry(config Config) *Registry <span class="cov5" title="235">{
        return &amp;Registry{
                macros: make(map[string]*Macro),
                config: config,
        }
}</span>

// RegisterMacro registers a new macro
func (r *Registry) RegisterMacro(name string, macro *Macro) error <span class="cov7" title="1714">{
        if r.config.EnableValidation </span><span class="cov4" title="36">{
                if err := r.validateMacro(name, macro); err != nil </span><span class="cov2" title="4">{
                        return err
                }</span>
        }
        
        <span class="cov7" title="1710">r.macros[name] = macro
        return nil</span>
}

// HasMacro checks if a macro is registered
func (r *Registry) HasMacro(name string) bool <span class="cov6" title="524">{
        _, exists := r.macros[name]
        return exists
}</span>

// GetMacro retrieves a registered macro
func (r *Registry) GetMacro(name string) (*Macro, bool) <span class="cov5" title="114">{
        macro, exists := r.macros[name]
        return macro, exists
}</span>

// LoadCoreMacros loads core macros from file
func (r *Registry) LoadCoreMacros() error <span class="cov5" title="209">{
        if r.coreLoaded </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov5" title="208">r.coreLoaded = true

        // Try multiple possible paths for core.vx
        corePaths := []string{
                r.config.CoreMacroPath,
                "core/core.vx",           // From project root
                "../../core/core.vx",     // From test directory
                "../../../core/core.vx",  // From deeper test directories
        }

        for _, path := range corePaths </span><span class="cov6" title="625">{
                if path != "" </span><span class="cov6" title="417">{
                        if content, err := os.ReadFile(path); err == nil </span><span class="cov5" title="208">{
                                return r.loadMacrosFromContent(string(content))
                        }</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("no core macros available - tried paths: %v", corePaths)</span>
}

// loadMacrosFromContent parses macro definitions from Vex code
func (r *Registry) loadMacrosFromContent(content string) error <span class="cov5" title="208">{
        // Temporarily disable validation for core macros
        originalValidation := r.config.EnableValidation
        r.config.EnableValidation = false
        defer func() </span><span class="cov5" title="208">{
                r.config.EnableValidation = originalValidation
        }</span>()
        
        // Create a minimal parser for macro definitions
        <span class="cov5" title="208">inputStream := antlr.NewInputStream(content)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)

        tree := vexParser.Program()
        if tree == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse macro definitions")
        }</span>

        // Extract macro definitions
        <span class="cov5" title="208">return r.extractMacrosFromAST(tree.(*parser.ProgramContext))</span>
}

// extractMacrosFromAST extracts macro definitions from parsed AST
func (r *Registry) extractMacrosFromAST(ctx *parser.ProgramContext) error <span class="cov5" title="208">{
        for _, child := range ctx.GetChildren() </span><span class="cov7" title="1872">{
                if listCtx, ok := child.(*parser.ListContext); ok </span><span class="cov7" title="1664">{
                        if r.isMacroDefinition(listCtx) </span><span class="cov7" title="1664">{
                                if err := r.parseMacroDefinition(listCtx); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov5" title="208">return nil</span>
}

// isMacroDefinition checks if a list is a macro definition
func (r *Registry) isMacroDefinition(listCtx *parser.ListContext) bool <span class="cov7" title="1664">{
        children := listCtx.GetChildren()
        if len(children) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov7" title="1664">if terminal, ok := children[1].(*antlr.TerminalNodeImpl); ok </span><span class="cov7" title="1664">{
                return terminal.GetText() == "macro"
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

// parseMacroDefinition parses a macro definition from AST
func (r *Registry) parseMacroDefinition(listCtx *parser.ListContext) error <span class="cov7" title="1664">{
        children := listCtx.GetChildren()
        if len(children) &lt; 6 </span><span class="cov0" title="0">{ // ( macro name [params] body )
                return fmt.Errorf("invalid macro definition")
        }</span>

        // Extract macro name
        <span class="cov7" title="1664">nameNode := children[2]
        name := r.nodeToString(nameNode)

        // Extract parameters
        paramNode := children[3]
        paramList := r.nodeToString(paramNode)
        params, err := r.parseParameterList(paramList)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract body
        <span class="cov7" title="1664">bodyNode := children[4]
        body := r.reconstructVexSyntax(bodyNode)

        // Register the macro
        macro := &amp;Macro{
                Name:   name,
                Params: params,
                Body:   body,
        }

        return r.RegisterMacro(name, macro)</span>
}



// validateMacro validates a macro definition
func (r *Registry) validateMacro(name string, macro *Macro) error <span class="cov4" title="44">{
        if name == "" </span><span class="cov1" title="2">{
                return fmt.Errorf("macro name cannot be empty")
        }</span>

        // Check for reserved words
        <span class="cov4" title="42">reservedWords := []string{"if", "def", "fn", "let", "do", "when", "unless"}
        for _, reserved := range reservedWords </span><span class="cov6" title="277">{
                if name == reserved </span><span class="cov1" title="3">{
                        return fmt.Errorf("'%s' is a reserved word", name)
                }</span>
        }

        // Check for conflicts
        <span class="cov4" title="39">if _, exists := r.macros[name]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("macro '%s' is already defined", name)
        }</span>

        // Validate parameters
        <span class="cov4" title="38">paramSet := make(map[string]bool)
        for _, param := range macro.Params </span><span class="cov4" title="52">{
                if param == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("empty parameter name in macro '%s'", name)
                }</span>
                <span class="cov4" title="51">if paramSet[param] </span><span class="cov1" title="2">{
                        return fmt.Errorf("duplicate parameter '%s' in macro '%s'", param, name)
                }</span>
                <span class="cov4" title="49">paramSet[param] = true</span>
        }

        // Validate body
        <span class="cov4" title="35">if strings.TrimSpace(macro.Body) == "" </span><span class="cov1" title="2">{
                return fmt.Errorf("macro '%s' has empty body", name)
        }</span>

        <span class="cov4" title="33">return nil</span>
}

// Helper methods
func (r *Registry) nodeToString(node antlr.Tree) string <span class="cov8" title="3328">{
        if terminal, ok := node.(*antlr.TerminalNodeImpl); ok </span><span class="cov7" title="1664">{
                return terminal.GetText()
        }</span>
        <span class="cov7" title="1664">return r.reconstructVexSyntax(node)</span>
}

func (r *Registry) parseParameterList(paramList string) ([]string, error) <span class="cov7" title="1671">{
        trimmed := strings.TrimSpace(paramList)
        
        // Handle both Vex format [x y] and Go format []interface{}{x, y}
        if strings.HasPrefix(trimmed, "[") &amp;&amp; strings.HasSuffix(trimmed, "]") &amp;&amp; !strings.Contains(trimmed, "interface{}") </span><span class="cov7" title="1667">{
                // Vex format
                inner := strings.TrimSpace(trimmed[1 : len(trimmed)-1])
                if inner == "" </span><span class="cov1" title="1">{
                        return []string{}, nil
                }</span>
                <span class="cov7" title="1666">return strings.Fields(inner), nil</span>
        } else<span class="cov2" title="4"> if strings.HasPrefix(trimmed, "[]interface{}") </span><span class="cov1" title="3">{
                // Go format
                if start := strings.Index(trimmed, "}{"); start != -1 </span><span class="cov1" title="3">{
                        start += 2
                        if end := strings.LastIndex(trimmed, "}"); end &gt; start </span><span class="cov1" title="2">{
                                inner := strings.TrimSpace(trimmed[start:end])
                                if inner == "" </span><span class="cov0" title="0">{
                                        return []string{}, nil
                                }</span>
                                <span class="cov1" title="2">params := strings.Split(inner, ",")
                                for i, param := range params </span><span class="cov2" title="4">{
                                        params[i] = strings.TrimSpace(param)
                                }</span>
                                <span class="cov1" title="2">return params, nil</span>
                        }
                }
        }
        
        <span class="cov1" title="2">return nil, fmt.Errorf("invalid parameter list format: %s", paramList)</span>
}

func (r *Registry) reconstructVexSyntax(node antlr.Tree) string <span class="cov10" title="20800">{
        switch n := node.(type) </span>{
        case *parser.ListContext:<span class="cov8" title="2288">
                var parts []string
                for _, child := range n.GetChildren() </span><span class="cov9" title="10816">{
                        if child != nil </span><span class="cov9" title="10816">{
                                parts = append(parts, r.reconstructVexSyntax(child))
                        }</span>
                }
                // Smart spacing: spaces between tokens but not around parentheses
                <span class="cov8" title="2288">result := ""
                for i, part := range parts </span><span class="cov9" title="10816">{
                        if i == 0 </span><span class="cov8" title="2288">{
                                result += part // First part (usually '(')
                        }</span> else<span class="cov9" title="8528"> if part == ")" </span><span class="cov8" title="2288">{
                                result += part // Last part, no space before
                        }</span> else<span class="cov8" title="6240"> if parts[i-1] == "(" </span><span class="cov8" title="2288">{
                                result += part // No space after opening parenthesis
                        }</span> else<span class="cov8" title="3952"> {
                                result += " " + part // Add space before other parts
                        }</span>
                }
                <span class="cov8" title="2288">return result</span>
        case *parser.ArrayContext:<span class="cov7" title="1872">
                var parts []string
                for _, child := range n.GetChildren() </span><span class="cov8" title="6656">{
                        if child != nil </span><span class="cov8" title="6656">{
                                parts = append(parts, r.reconstructVexSyntax(child))
                        }</span>
                }
                <span class="cov7" title="1872">return strings.Join(parts, " ")</span>
        case *antlr.TerminalNodeImpl:<span class="cov9" title="16640">
                return n.GetText()</span>
        case antlr.TerminalNode:<span class="cov0" title="0">
                return n.GetText()</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}</pre>
		
		<pre class="file" id="file11" style="display: none">package transpiler

import (
        "fmt"
        "os"
        "strings"

        "github.com/thsfranca/vex/internal/transpiler/codegen"
        "github.com/thsfranca/vex/internal/transpiler/macro"
)

// VexTranspiler creates a transpiler with clean architecture
type VexTranspiler struct {
        parser          Parser
        macroSystem     MacroExpander
        analyzer        Analyzer
        codeGen         CodeGenerator
        config          TranspilerConfig
        detectedModules map[string]string
}

// TranspilerBuilder builds a transpiler with configurable components
type TranspilerBuilder struct {
        config TranspilerConfig
}

// NewBuilder creates a new transpiler builder
func NewBuilder() *TranspilerBuilder <span class="cov9" title="210">{
        return &amp;TranspilerBuilder{
                config: TranspilerConfig{
                        EnableMacros:     true,
                        CoreMacroPath:    "", // Will be determined dynamically
                        PackageName:      "main",
                        GenerateComments: true,
                },
        }
}</span>

// WithConfig sets the transpiler configuration
func (b *TranspilerBuilder) WithConfig(config TranspilerConfig) *TranspilerBuilder <span class="cov2" title="3">{
        b.config = config
        return b
}</span>

// WithMacros enables or disables macro support
func (b *TranspilerBuilder) WithMacros(enabled bool) *TranspilerBuilder <span class="cov0" title="0">{
        b.config.EnableMacros = enabled
        return b
}</span>

// WithCoreMacroPath sets the path to core macro definitions
func (b *TranspilerBuilder) WithCoreMacroPath(path string) *TranspilerBuilder <span class="cov0" title="0">{
        b.config.CoreMacroPath = path
        return b
}</span>

// WithPackageName sets the package name for generated code
func (b *TranspilerBuilder) WithPackageName(name string) *TranspilerBuilder <span class="cov0" title="0">{
        b.config.PackageName = name
        return b
}</span>

// Build creates the configured transpiler
func (b *TranspilerBuilder) Build() (*VexTranspiler, error) <span class="cov9" title="210">{
        // Create parser
        parser := NewParserAdapter()

        // Create macro system
        var macroSystem MacroExpander
        if b.config.EnableMacros </span><span class="cov9" title="207">{
                macroConfig := macro.Config{
                        CoreMacroPath:    b.config.CoreMacroPath,
                        EnableValidation: true,
                }
                registry := macro.NewRegistry(macroConfig)
                
                // Load core macros
                if err := registry.LoadCoreMacros(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load core macros: %v", err)
                }</span>
                
                <span class="cov9" title="207">macroSystem = NewMacroExpanderAdapter(macro.NewMacroExpander(registry))</span>
        }

        // Create analyzer
        <span class="cov9" title="210">analyzer := NewAnalyzerAdapter()

        // Create code generator
        codeGenConfig := codegen.Config{
                PackageName:      b.config.PackageName,
                GenerateComments: b.config.GenerateComments,
                IndentSize:       4,
        }
        codeGen := NewCodeGeneratorAdapter(codeGenConfig)

        return &amp;VexTranspiler{
                parser:          parser,
                macroSystem:     macroSystem,
                analyzer:        analyzer,
                codeGen:         codeGen,
                config:          b.config,
                detectedModules: make(map[string]string),
        }, nil</span>
}

// TranspileFromInput transpiles Vex source code to Go
func (vt *VexTranspiler) TranspileFromInput(input string) (string, error) <span class="cov9" title="204">{
        // Reset detected modules for each transpilation
        vt.detectedModules = make(map[string]string)
        
        // Detect third-party modules from imports
        vt.detectThirdPartyModules(input)
        
        // Phase 1: Parse
        ast, err := vt.parser.Parse(input)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("parse error: %v", err)
        }</span>

        // Phase 2: Macro expansion (if enabled)
        <span class="cov9" title="204">if vt.config.EnableMacros &amp;&amp; vt.macroSystem != nil </span><span class="cov9" title="202">{
                ast, err = vt.macroSystem.ExpandMacros(ast)
                if err != nil </span><span class="cov4" title="10">{
                        return "", fmt.Errorf("macro expansion error: %v", err)
                }</span>
        }

        // Phase 3: Semantic analysis
        <span class="cov9" title="194">symbolTable, err := vt.analyzer.Analyze(ast)
        if err != nil </span><span class="cov4" title="8">{
                return "", fmt.Errorf("analysis error: %v", err)
        }</span>

        // Phase 4: Code generation
        <span class="cov9" title="186">code, err := vt.codeGen.Generate(ast, symbolTable)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("code generation error: %v", err)
        }</span>

        <span class="cov9" title="185">return code, nil</span>
}

// TranspileFromFile transpiles a Vex file to Go
func (vt *VexTranspiler) TranspileFromFile(filename string) (string, error) <span class="cov4" title="11">{
        // Read file content and use TranspileFromInput
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov3" title="4">{
                return "", fmt.Errorf("failed to read file %s: %v", filename, err)
        }</span>
        
        <span class="cov4" title="7">return vt.TranspileFromInput(string(content))</span>
}

// GetMacroSystem returns the macro system (for testing/debugging)
func (vt *VexTranspiler) GetMacroSystem() MacroExpander <span class="cov0" title="0">{
        return vt.macroSystem
}</span>

// GetAnalyzer returns the analyzer (for testing/debugging)
func (vt *VexTranspiler) GetAnalyzer() Analyzer <span class="cov0" title="0">{
        return vt.analyzer
}</span>

// GetCodeGenerator returns the code generator (for testing/debugging)
func (vt *VexTranspiler) GetCodeGenerator() CodeGenerator <span class="cov0" title="0">{
        return vt.codeGen
}</span>

// GetDetectedModules returns detected third-party modules
func (vt *VexTranspiler) GetDetectedModules() map[string]string <span class="cov2" title="3">{
        // Basic implementation of third-party module detection
        // This should be enhanced to work with the actual import tracking in the future
        return vt.detectedModules
}</span>

// Helper method to convert AST back to string (for macro processing)
func (vt *VexTranspiler) astToString(ast AST) string <span class="cov0" title="0">{
        // This is a simplified implementation
        // In a real system, you'd want a proper AST-to-string converter
        return "/* AST conversion not implemented yet */"
}</span>

// Factory function for backward compatibility
func NewVexTranspiler() (*VexTranspiler, error) <span class="cov9" title="207">{
        return NewBuilder().Build()
}</span>

// Factory function with custom configuration
func NewTranspilerWithConfig(config TranspilerConfig) (*VexTranspiler, error) <span class="cov2" title="3">{
        return NewBuilder().WithConfig(config).Build()
}</span>

// Example usage demonstrating the clean architecture:
//
// transpiler, err := NewBuilder().
//     WithMacros(true).
//     WithCoreMacroPath("custom/macros.vx").
//     WithPackageName("mypackage").
//     Build()
// if err != nil {
//     return err
// }
//
// result, err := transpiler.TranspileFromInput(vexCode)
// if err != nil {
//     return err
// }
//
// fmt.Println(result)

// Adapter for legacy tests - this allows existing tests to work with minimal changes
type TranspilerAdapter struct {
        vexTranspiler *VexTranspiler
}

// NewTranspilerAdapter creates an adapter for legacy compatibility
func NewTranspilerAdapter() (*TranspilerAdapter, error) <span class="cov0" title="0">{
        vt, err := NewVexTranspiler()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;TranspilerAdapter{
                vexTranspiler: vt,
        }, nil</span>
}

// TranspileFromInput adapts to the old interface
func (ta *TranspilerAdapter) TranspileFromInput(input string) (string, error) <span class="cov0" title="0">{
        return ta.vexTranspiler.TranspileFromInput(input)
}</span>

// TranspileFromFile adapts to the old interface
func (ta *TranspilerAdapter) TranspileFromFile(filename string) (string, error) <span class="cov0" title="0">{
        return ta.vexTranspiler.TranspileFromFile(filename)
}</span>

// detectThirdPartyModules scans input for import statements and identifies third-party modules
func (vt *VexTranspiler) detectThirdPartyModules(input string) <span class="cov9" title="204">{
        // Simple regex-based detection for now - this could be enhanced to use the actual parser
        lines := strings.Split(input, "\n")
        for _, line := range lines </span><span class="cov10" title="262">{
                line = strings.TrimSpace(line)
                if strings.HasPrefix(line, "(import \"") &amp;&amp; strings.HasSuffix(line, "\")") </span><span class="cov5" title="20">{
                        // Extract the import path
                        start := strings.Index(line, "\"") + 1
                        end := strings.LastIndex(line, "\"")
                        if start &lt; end </span><span class="cov5" title="20">{
                                importPath := line[start:end]
                                if vt.isThirdPartyModule(importPath) </span><span class="cov1" title="1">{
                                        vt.detectedModules[importPath] = "third-party"
                                }</span>
                        }
                }
        }
}

// isThirdPartyModule determines if an import path is a third-party module
func (vt *VexTranspiler) isThirdPartyModule(importPath string) bool <span class="cov5" title="20">{
        // Standard library packages are typically short names without dots
        // Third-party packages usually have domain names
        return strings.Contains(importPath, ".") || strings.HasPrefix(importPath, "golang.org/")
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
