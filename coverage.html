
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>transpiler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/thsfranca/vex/internal/transpiler/transpiler.go (87.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package transpiler provides a minimal Vex to Go transpiler
package transpiler

import (
        "fmt"
        "os"
        "strings"

        "github.com/antlr4-go/antlr/v4"
        "github.com/thsfranca/vex/internal/transpiler/parser"
)

// Transpiler converts Vex code to Go code
type Transpiler struct {
        output     strings.Builder
        imports    map[string]bool
        goModules  map[string]string // Track third-party modules for go.mod
}

// New creates a new transpiler instance
func New() *Transpiler <span class="cov8" title="143">{
        return &amp;Transpiler{
                imports:   make(map[string]bool),
                goModules: make(map[string]string),
        }
}</span>

// TranspileFromInput transpiles Vex source code to Go
func (t *Transpiler) TranspileFromInput(input string) (string, error) <span class="cov7" title="137">{
        // Parse the input
        inputStream := antlr.NewInputStream(input)
        lexer := parser.NewVexLexer(inputStream)
        tokenStream := antlr.NewCommonTokenStream(lexer, 0)
        vexParser := parser.NewVexParser(tokenStream)

        // Parse the program
        tree := vexParser.Program()

        // Reset output, imports, and modules
        t.output.Reset()
        t.imports = make(map[string]bool)
        t.goModules = make(map[string]string)
        
        // Generate Go code
        if programCtx, ok := tree.(*parser.ProgramContext); ok </span><span class="cov7" title="137">{
                t.visitProgram(programCtx)
        }</span>
        
        <span class="cov7" title="137">return t.generateGoCode(), nil</span>
}

// TranspileFromFile transpiles a Vex file to Go
func (t *Transpiler) TranspileFromFile(filename string) (string, error) <span class="cov4" title="11">{
        // Read the file content
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov2" title="4">{
                return "", fmt.Errorf("error reading file %s: %v", filename, err)
        }</span>

        // Use the existing TranspileFromInput method
        <span class="cov3" title="7">return t.TranspileFromInput(string(content))</span>
}

// visitProgram processes the top-level program
func (t *Transpiler) visitProgram(ctx *parser.ProgramContext) <span class="cov7" title="137">{
        lists := ctx.AllList()
        
        // Visit all lists in the program
        for i, listCtx := range lists </span><span class="cov8" title="183">{
                if concreteList, ok := listCtx.(*parser.ListContext); ok </span><span class="cov8" title="183">{
                        // For the last expression, make it the return value
                        if i == len(lists)-1 </span><span class="cov7" title="132">{
                                t.handleLastExpression(concreteList)
                        }</span> else<span class="cov6" title="51"> {
                                t.visitList(concreteList)
                        }</span>
                }
        }
}

// visitList handles list expressions (function calls, special forms)
func (t *Transpiler) visitList(ctx *parser.ListContext) <span class="cov6" title="51">{
        childCount := ctx.GetChildCount()
        if childCount &lt;= 2 </span><span class="cov0" title="0">{ // Just parentheses
                return
        }</span>

        // Get the first element (function name)
        <span class="cov6" title="51">firstChild := ctx.GetChild(1)
        if firstChild == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="51">var funcName string
        if parseTree, ok := firstChild.(antlr.ParseTree); ok </span><span class="cov6" title="51">{
                funcName = parseTree.GetText()
        }</span> else<span class="cov0" title="0"> {
                return
        }</span>

        // Extract arguments
        <span class="cov6" title="51">args := make([]string, 0)
        for i := 2; i &lt; childCount-1; i++ </span><span class="cov7" title="81">{ // Skip '(' and ')'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov7" title="81">{
                        args = append(args, t.visitNode(child))
                }</span>
        }

        // Handle special forms
        <span class="cov6" title="51">switch funcName </span>{
        case "def":<span class="cov5" title="20">
                t.handleDefinition(args)</span>
        case "import":<span class="cov5" title="22">
                t.handleImport(args)</span>
        case "if":<span class="cov1" title="2">
                t.handleIf(args)</span>
        case "do":<span class="cov0" title="0">
                t.handleDo(args)</span>
        case "first", "rest", "cons", "count", "empty?":<span class="cov0" title="0">
                t.handleCollectionOp(funcName, args)</span>
        case "+", "-", "*", "/":<span class="cov3" title="6">
                t.handleArithmetic(funcName, args)</span>
        default:<span class="cov1" title="1">
                t.handleFunctionCall(funcName, args)</span>
        }
}

// visitNode handles any AST node and returns its value
func (t *Transpiler) visitNode(node antlr.Tree) string <span class="cov10" title="559">{
        switch n := node.(type) </span>{
        case *parser.ListContext:<span class="cov7" title="91">
                // For nested lists, evaluate them and return the expression
                return t.evaluateExpression(n)</span>
        case *parser.ArrayContext:<span class="cov6" title="55">
                return t.visitArray(n)</span>
        case antlr.TerminalNode:<span class="cov9" title="413">
                return n.GetText()</span>
        default:<span class="cov0" title="0">
                if parseTree, ok := node.(antlr.ParseTree); ok </span><span class="cov0" title="0">{
                        return parseTree.GetText()
                }</span>
                <span class="cov0" title="0">return "/* unknown */"</span>
        }
}

// evaluateExpression evaluates a list as an expression and returns the result
func (t *Transpiler) evaluateExpression(ctx *parser.ListContext) string <span class="cov7" title="91">{
        childCount := ctx.GetChildCount()
        if childCount &lt;= 2 </span><span class="cov0" title="0">{ // Just parentheses
                return "nil"
        }</span>

        // Get the first element (function name)
        <span class="cov7" title="91">firstChild := ctx.GetChild(1)
        if firstChild == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>

        <span class="cov7" title="91">var funcName string
        if parseTree, ok := firstChild.(antlr.ParseTree); ok </span><span class="cov7" title="91">{
                funcName = parseTree.GetText()
        }</span> else<span class="cov0" title="0"> {
                return "nil"
        }</span>

        // Extract arguments
        <span class="cov7" title="91">args := make([]string, 0)
        for i := 2; i &lt; childCount-1; i++ </span><span class="cov8" title="141">{ // Skip '(' and ')'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov8" title="141">{
                        args = append(args, t.visitNode(child))
                }</span>
        }

        // Handle special expressions
        <span class="cov7" title="91">switch funcName </span>{
        case "if":<span class="cov3" title="6">
                return t.evaluateIf(args)</span>
        case "do":<span class="cov2" title="3">
                return t.evaluateDo(args)</span>
        case "first", "rest", "cons", "count", "empty?":<span class="cov6" title="34">
                return t.evaluateCollectionOp(funcName, args)</span>
        case "+", "-", "*", "/":<span class="cov5" title="25">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return "0"
                }</span>
                // Left-associative chaining for multiple operands
                <span class="cov5" title="25">result := "(" + args[0] + " " + funcName + " " + args[1] + ")"
                for i := 2; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        result = "(" + result + " " + funcName + " " + args[i] + ")"
                }</span>
                <span class="cov5" title="25">return result</span>
        default:<span class="cov5" title="23">
                // Handle function calls
                if strings.Contains(funcName, "/") </span><span class="cov2" title="4">{
                        funcName = strings.ReplaceAll(funcName, "/", ".")
                }</span>
                <span class="cov5" title="23">argStr := strings.Join(args, ", ")
                return fmt.Sprintf("%s(%s)", funcName, argStr)</span>
        }
}

// visitArray handles array literals
func (t *Transpiler) visitArray(ctx *parser.ArrayContext) string <span class="cov6" title="55">{
        childCount := ctx.GetChildCount()
        if childCount &lt;= 2 </span><span class="cov4" title="14">{ // Just brackets
                return "[]interface{}{}"
        }</span>

        <span class="cov6" title="41">elements := make([]string, 0)
        for i := 1; i &lt; childCount-1; i++ </span><span class="cov7" title="109">{ // Skip '[' and ']'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov7" title="109">{
                        elements = append(elements, t.visitNode(child))
                }</span>
        }

        <span class="cov6" title="41">return "[]interface{}{" + strings.Join(elements, ", ") + "}"</span>
}

// handleDefinition processes variable definitions
func (t *Transpiler) handleDefinition(args []string) <span class="cov7" title="70">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                t.output.WriteString("// Error: def requires name and value\n")
                return
        }</span>

        <span class="cov7" title="70">varName := args[0]
        varValue := args[1]

        // Generate variable definition and use it immediately (functional style)
        t.output.WriteString(fmt.Sprintf("var %s = %s\n", varName, varValue))
        t.output.WriteString(fmt.Sprintf("_ = %s // Use variable to satisfy Go compiler\n", varName))</span>
}

// handleImport processes import statements
func (t *Transpiler) handleImport(args []string) <span class="cov5" title="24">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                t.output.WriteString("// Error: import requires package path\n")
                return
        }</span>

        <span class="cov5" title="24">importPath := args[0]
        // Remove quotes if present
        importPath = strings.Trim(importPath, "\"")
        
        // Store import for later use at package level
        t.imports[importPath] = true
        
        // Track third-party modules for go.mod generation
        if t.isThirdPartyModule(importPath) </span><span class="cov3" title="5">{
                t.goModules[importPath] = "v1.0.0" // Use a reasonable default version
        }</span>
}

// isThirdPartyModule checks if an import is a third-party module
func (t *Transpiler) isThirdPartyModule(importPath string) bool <span class="cov5" title="29">{
        // Standard library packages don't need go.mod entries
        standardPkgs := []string{
                "fmt", "strings", "strconv", "time", "os", "io", "net", "http",
                "database", "encoding", "crypto", "math", "sort", "regexp",
                "context", "sync", "testing", "flag", "log", "path", "reflect",
        }
        
        for _, stdPkg := range standardPkgs </span><span class="cov8" title="192">{
                if strings.HasPrefix(importPath, stdPkg) </span><span class="cov5" title="21">{
                        return false
                }</span>
        }
        
        // If it contains a dot, it's likely a third-party module
        <span class="cov3" title="8">return strings.Contains(importPath, ".")</span>
}

// handleArithmetic processes arithmetic operations
func (t *Transpiler) handleArithmetic(op string, args []string) <span class="cov5" title="21">{
        if len(args) &lt; 2 </span><span class="cov3" title="5">{
                t.output.WriteString("// Error: arithmetic requires at least 2 operands\n")
                return
        }</span>

        // Left-associative chaining for multiple operands
        <span class="cov4" title="16">result := "(" + args[0] + " " + op + " " + args[1] + ")"
        for i := 2; i &lt; len(args); i++ </span><span class="cov1" title="1">{
                result = "(" + result + " " + op + " " + args[i] + ")"
        }</span>

        <span class="cov4" title="16">t.output.WriteString("_ = " + result + "\n")</span>
}

// handleFunctionCall processes regular function calls
func (t *Transpiler) handleFunctionCall(funcName string, args []string) <span class="cov5" title="19">{
        // Handle package/function notation (fmt/Println -&gt; fmt.Println)
        if strings.Contains(funcName, "/") </span><span class="cov1" title="1">{
                funcName = strings.ReplaceAll(funcName, "/", ".")
        }</span>

        <span class="cov5" title="19">argStr := strings.Join(args, ", ")
        
        // For functions that return multiple values or don't need assignment, just call them
        if strings.Contains(funcName, "Println") || strings.Contains(funcName, "Printf") </span><span class="cov0" title="0">{
                t.output.WriteString(fmt.Sprintf("%s(%s)\n", funcName, argStr))
        }</span> else<span class="cov5" title="19"> {
                t.output.WriteString(fmt.Sprintf("_ = %s(%s)\n", funcName, argStr))
        }</span>
}

// handleIf processes if conditionals: (if condition then-expr else-expr)
func (t *Transpiler) handleIf(args []string) <span class="cov4" title="11">{
        if len(args) &lt; 2 </span><span class="cov1" title="2">{
                t.output.WriteString("// Error: if requires at least condition and then-expr\n")
                return
        }</span>
        
        <span class="cov4" title="9">condition := args[0]
        thenExpr := args[1]
        var elseExpr string
        if len(args) &gt; 2 </span><span class="cov4" title="9">{
                elseExpr = args[2]
        }</span> else<span class="cov0" title="0"> {
                elseExpr = "nil"
        }</span>
        
        <span class="cov4" title="9">t.output.WriteString(fmt.Sprintf("if %s {\n\t%s\n} else {\n\t%s\n}\n", condition, thenExpr, elseExpr))</span>
}

// evaluateIf evaluates if conditionals as expressions
func (t *Transpiler) evaluateIf(args []string) string <span class="cov3" title="6">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        
        <span class="cov3" title="6">condition := args[0]
        thenExpr := args[1]
        var elseExpr string
        if len(args) &gt; 2 </span><span class="cov3" title="6">{
                elseExpr = args[2]
        }</span> else<span class="cov0" title="0"> {
                elseExpr = "nil"
        }</span>
        
        <span class="cov3" title="6">return fmt.Sprintf("func() interface{} { if %s { return %s } else { return %s } }()", condition, thenExpr, elseExpr)</span>
}

// handleDo processes do blocks: (do expr1 expr2 expr3)
func (t *Transpiler) handleDo(args []string) <span class="cov3" title="5">{
        for _, expr := range args </span><span class="cov4" title="12">{
                t.output.WriteString(expr + "\n")
        }</span>
}

// evaluateDo evaluates do blocks as expressions (returns last expression)
func (t *Transpiler) evaluateDo(args []string) string <span class="cov2" title="3">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        
        // Generate function that executes all expressions and returns the last one
        <span class="cov2" title="3">var statements []string
        for i, expr := range args </span><span class="cov3" title="5">{
                if i == len(args)-1 </span><span class="cov2" title="3">{
                        statements = append(statements, "return "+expr)
                }</span> else<span class="cov1" title="2"> {
                        statements = append(statements, expr)
                }</span>
        }
        
        <span class="cov2" title="3">return fmt.Sprintf("func() interface{} { %s }()", strings.Join(statements, "; "))</span>
}

// handleCollectionOp processes collection operations
func (t *Transpiler) handleCollectionOp(op string, args []string) <span class="cov5" title="21">{
        switch op </span>{
        case "first":<span class="cov2" title="4">
                if len(args) &lt; 1 </span><span class="cov1" title="1">{
                        t.output.WriteString("_ = nil // Error: first requires collection\n")
                        return
                }</span>
                <span class="cov2" title="3">t.output.WriteString(fmt.Sprintf("_ = func() interface{} { if len(%s) &gt; 0 { return %s[0] } else { return nil } }()\n", args[0], args[0]))</span>
        
        case "rest":<span class="cov2" title="4">
                if len(args) &lt; 1 </span><span class="cov1" title="1">{
                        t.output.WriteString("_ = []interface{}{} // Error: rest requires collection\n")
                        return
                }</span>
                <span class="cov2" title="3">t.output.WriteString(fmt.Sprintf("_ = func() []interface{} { if len(%s) &gt; 1 { return %s[1:] } else { return []interface{}{} } }()\n", args[0], args[0]))</span>
        
        case "cons":<span class="cov3" title="5">
                if len(args) &lt; 2 </span><span class="cov1" title="1">{
                        t.output.WriteString("_ = []interface{}{} // Error: cons requires element and collection\n")
                        return
                }</span>
                <span class="cov2" title="4">t.output.WriteString(fmt.Sprintf("_ = append([]interface{}{%s}, %s...)\n", args[0], args[1]))</span>
        
        case "count":<span class="cov2" title="4">
                if len(args) &lt; 1 </span><span class="cov1" title="1">{
                        t.output.WriteString("_ = 0 // Error: count requires collection\n")
                        return
                }</span>
                <span class="cov2" title="3">t.output.WriteString(fmt.Sprintf("_ = len(%s)\n", args[0]))</span>
        
        case "empty?":<span class="cov2" title="4">
                if len(args) &lt; 1 </span><span class="cov1" title="1">{
                        t.output.WriteString("_ = true // Error: empty? requires collection\n")
                        return
                }</span>
                <span class="cov2" title="3">t.output.WriteString(fmt.Sprintf("_ = len(%s) == 0\n", args[0]))</span>
        }
}

// evaluateCollectionOp evaluates collection operations as expressions
func (t *Transpiler) evaluateCollectionOp(op string, args []string) string <span class="cov6" title="34">{
        switch op </span>{
        case "first":<span class="cov4" title="9">
                if len(args) &lt; 1 </span><span class="cov1" title="1">{
                        return "nil"
                }</span>
                <span class="cov3" title="8">return fmt.Sprintf("func() interface{} { if len(%s) &gt; 0 { return %s[0] } else { return nil } }()", args[0], args[0])</span>
        
        case "rest":<span class="cov3" title="7">
                if len(args) &lt; 1 </span><span class="cov1" title="1">{
                        return "[]interface{}{}"
                }</span>
                <span class="cov3" title="6">return fmt.Sprintf("func() []interface{} { if len(%s) &gt; 1 { return %s[1:] } else { return []interface{}{} } }()", args[0], args[0])</span>
        
        case "cons":<span class="cov3" title="6">
                if len(args) &lt; 2 </span><span class="cov1" title="1">{
                        return "[]interface{}{}"
                }</span>
                <span class="cov3" title="5">return fmt.Sprintf("append([]interface{}{%s}, %s...)", args[0], args[1])</span>
        
        case "count":<span class="cov3" title="7">
                if len(args) &lt; 1 </span><span class="cov1" title="1">{
                        return "0"
                }</span>
                <span class="cov3" title="6">return fmt.Sprintf("len(%s)", args[0])</span>
        
        case "empty?":<span class="cov3" title="5">
                if len(args) &lt; 1 </span><span class="cov1" title="1">{
                        return "true"
                }</span>
                <span class="cov2" title="4">return fmt.Sprintf("len(%s) == 0", args[0])</span>
        
        default:<span class="cov0" title="0">
                return "nil"</span>
        }
}

// generateGoCode wraps the generated code in a proper Go program
func (t *Transpiler) generateGoCode() string <span class="cov7" title="137">{
        var result strings.Builder

        // Package declaration
        result.WriteString("package main\n\n")

        // Add collected imports
        content := t.output.String()
        
        // Auto-detect imports from function calls if not explicitly imported
        if strings.Contains(content, "fmt.") &amp;&amp; !t.imports["fmt"] </span><span class="cov1" title="1">{
                t.imports["fmt"] = true
        }</span>
        
        // Write all imports
        <span class="cov7" title="137">for importPath := range t.imports </span><span class="cov5" title="23">{
                result.WriteString(fmt.Sprintf("import \"%s\"\n", importPath))
        }</span>
        
        <span class="cov7" title="137">if len(t.imports) &gt; 0 </span><span class="cov4" title="16">{
                result.WriteString("\n")
        }</span>

        // Main function
        <span class="cov7" title="137">result.WriteString("func main() {\n")
        
        // Add the generated code with indentation, but skip any import statements
        lines := strings.Split(strings.TrimSpace(content), "\n")
                for _, line := range lines </span><span class="cov9" title="329">{
                trimmed := strings.TrimSpace(line)
                if trimmed != "" &amp;&amp; !strings.HasPrefix(trimmed, "import ") </span><span class="cov9" title="324">{
                                result.WriteString("\t" + line + "\n")
                }</span>
        }
        
        <span class="cov7" title="137">result.WriteString("}\n")

        return result.String()</span>
}

// handleLastExpression processes the last expression in a program (implicit return)
func (t *Transpiler) handleLastExpression(ctx *parser.ListContext) <span class="cov7" title="132">{
        childCount := ctx.GetChildCount()
        if childCount &lt;= 2 </span><span class="cov0" title="0">{ // Just parentheses
                t.output.WriteString("_ = nil // Empty expression\n")
                return
        }</span>

        // Get the first element (function name)
        <span class="cov7" title="132">firstChild := ctx.GetChild(1)
        if firstChild == nil </span><span class="cov0" title="0">{
                t.output.WriteString("_ = nil // Invalid expression\n")
                return
        }</span>

        <span class="cov7" title="132">var funcName string
        if parseTree, ok := firstChild.(antlr.ParseTree); ok </span><span class="cov7" title="132">{
                funcName = parseTree.GetText()
        }</span> else<span class="cov0" title="0"> {
                t.output.WriteString("_ = nil // Invalid expression\n")
                return
        }</span>

        // Extract arguments
        <span class="cov7" title="132">args := make([]string, 0)
        for i := 2; i &lt; childCount-1; i++ </span><span class="cov8" title="228">{ // Skip '(' and ')'
                child := ctx.GetChild(i)
                if child != nil </span><span class="cov8" title="228">{
                        args = append(args, t.visitNode(child))
                }</span>
        }

        // Handle the last expression - ensure it's used
        <span class="cov7" title="132">switch funcName </span>{
        case "def":<span class="cov6" title="50">
                t.handleDefinition(args)
                // Return the defined variable
                if len(args) &gt;= 1 </span><span class="cov6" title="50">{
                        t.output.WriteString(fmt.Sprintf("_ = %s // Return last defined value\n", args[0]))
                }</span>
        case "import":<span class="cov1" title="2">
                t.handleImport(args)
                t.output.WriteString("_ = \"import completed\" // Import statement result\n")</span>
        case "if":<span class="cov4" title="9">
                t.handleIf(args)</span>
        case "do":<span class="cov3" title="5">
                t.handleDo(args)</span>
        case "first", "rest", "cons", "count", "empty?":<span class="cov5" title="21">
                t.handleCollectionOp(funcName, args)</span>
        case "+", "-", "*", "/":<span class="cov4" title="15">
                t.handleArithmetic(funcName, args)</span>
        default:<span class="cov5" title="30">
                // For function calls, capture the result
                if strings.Contains(funcName, "Println") || strings.Contains(funcName, "Printf") </span><span class="cov4" title="12">{
                        t.output.WriteString(fmt.Sprintf("%s(%s) // Last expression\n", 
                                strings.ReplaceAll(funcName, "/", "."), strings.Join(args, ", ")))
                }</span> else<span class="cov5" title="18"> {
                        t.handleFunctionCall(funcName, args)
                }</span>
        }
}

// GetDetectedModules returns the Go modules detected during transpilation
func (t *Transpiler) GetDetectedModules() map[string]string <span class="cov1" title="2">{
        return t.goModules
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
